/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 492);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {
  module.exports = require('./cjs/react.production.min.js');
} else {
  module.exports = __webpack_require__(82);
}


/***/ }),

/***/ 10:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = require('./cjs/react-dom.production.min.js');
} else {
  module.exports = __webpack_require__(81);
}


/***/ }),

/***/ 22:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),

/***/ 23:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (true) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),

/***/ 27:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(22);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (true) {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;

/***/ }),

/***/ 36:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ 37:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  var invariant = __webpack_require__(23);
  var warning = __webpack_require__(27);
  var ReactPropTypesSecret = __webpack_require__(61);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ 48:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (true) {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;

/***/ }),

/***/ 49:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),

/***/ 492:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(493);


/***/ }),

/***/ 493:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

!function (e, t) {
	"object" == ( false ? "undefined" : _typeof(exports)) && "object" == ( false ? "undefined" : _typeof(module)) ? module.exports = t(__webpack_require__(0), __webpack_require__(10)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(10)], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.ReactBootstrap = t(require("react"), require("react-dom")) : e.ReactBootstrap = t(e.React, e.ReactDOM);
}(this, function (e, t) {
	return function (e) {
		function t(o) {
			if (n[o]) return n[o].exports;var a = n[o] = { exports: {}, id: o, loaded: !1 };return e[o].call(a.exports, a, a.exports, t), a.loaded = !0, a.exports;
		}var n = {};return t.m = e, t.c = n, t.p = "", t(0);
	}([function (e, t, n) {
		"use strict";
		function o(e) {
			if (e && e.__esModule) return e;var t = {};if (null != e) for (var n in e) {
				Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
			}return t.default = e, t;
		}function a(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0, t.utils = t.Well = t.Tooltip = t.ToggleButtonGroup = t.ToggleButton = t.Thumbnail = t.Tabs = t.TabPane = t.Table = t.TabContent = t.TabContainer = t.Tab = t.SplitButton = t.SafeAnchor = t.Row = t.ResponsiveEmbed = t.Radio = t.ProgressBar = t.Popover = t.PanelGroup = t.Panel = t.PaginationButton = t.Pagination = t.Pager = t.PageItem = t.PageHeader = t.OverlayTrigger = t.Overlay = t.NavItem = t.NavDropdown = t.NavbarBrand = t.Navbar = t.Nav = t.ModalTitle = t.ModalHeader = t.ModalFooter = t.ModalBody = t.Modal = t.MenuItem = t.Media = t.ListGroupItem = t.ListGroup = t.Label = t.Jumbotron = t.InputGroup = t.Image = t.HelpBlock = t.Grid = t.Glyphicon = t.FormGroup = t.FormControl = t.Form = t.Fade = t.DropdownButton = t.Dropdown = t.Collapse = t.Col = t.ControlLabel = t.CloseButton = t.Clearfix = t.Checkbox = t.CarouselItem = t.Carousel = t.ButtonToolbar = t.ButtonGroup = t.Button = t.BreadcrumbItem = t.Breadcrumb = t.Badge = t.Alert = t.Accordion = void 0;var l = n(122),
		    r = a(l),
		    u = n(123),
		    i = a(u),
		    s = n(124),
		    d = a(s),
		    f = n(125),
		    c = a(f),
		    p = n(78),
		    h = a(p),
		    m = n(32),
		    v = a(m),
		    y = n(54),
		    b = a(y),
		    g = n(126),
		    _ = a(g),
		    C = n(127),
		    E = a(C),
		    x = n(79),
		    O = a(x),
		    S = n(129),
		    N = a(S),
		    M = n(130),
		    T = a(M),
		    w = n(55),
		    P = a(w),
		    k = n(132),
		    A = a(k),
		    R = n(131),
		    I = a(R),
		    L = n(56),
		    D = a(L),
		    j = n(40),
		    B = a(j),
		    K = n(133),
		    F = a(K),
		    H = n(41),
		    U = a(H),
		    z = n(135),
		    W = a(z),
		    $ = n(136),
		    G = a($),
		    V = n(139),
		    q = a(V),
		    Y = n(57),
		    X = a(Y),
		    Z = n(81),
		    J = a(Z),
		    Q = n(140),
		    ee = a(Q),
		    te = n(141),
		    ne = a(te),
		    oe = n(142),
		    ae = a(oe),
		    le = n(145),
		    re = a(le),
		    ue = n(146),
		    ie = a(ue),
		    se = n(147),
		    de = a(se),
		    fe = n(82),
		    ce = a(fe),
		    pe = n(42),
		    he = a(pe),
		    me = n(154),
		    ve = a(me),
		    ye = n(155),
		    be = a(ye),
		    ge = n(83),
		    _e = a(ge),
		    Ce = n(84),
		    Ee = a(Ce),
		    xe = n(85),
		    Oe = a(xe),
		    Se = n(86),
		    Ne = a(Se),
		    Me = n(87),
		    Te = a(Me),
		    we = n(158),
		    Pe = a(we),
		    ke = n(89),
		    Ae = a(ke),
		    Re = n(157),
		    Ie = a(Re),
		    Le = n(88),
		    De = a(Le),
		    je = n(90),
		    Be = a(je),
		    Ke = n(162),
		    Fe = a(Ke),
		    He = n(163),
		    Ue = a(He),
		    ze = n(164),
		    We = a(ze),
		    $e = n(165),
		    Ge = a($e),
		    Ve = n(166),
		    qe = a(Ve),
		    Ye = n(92),
		    Xe = a(Ye),
		    Ze = n(167),
		    Je = a(Ze),
		    Qe = n(93),
		    et = a(Qe),
		    tt = n(168),
		    nt = a(tt),
		    ot = n(169),
		    at = a(ot),
		    lt = n(170),
		    rt = a(lt),
		    ut = n(171),
		    it = a(ut),
		    st = n(172),
		    dt = a(st),
		    ft = n(16),
		    ct = a(ft),
		    pt = n(173),
		    ht = a(pt),
		    mt = n(175),
		    vt = a(mt),
		    yt = n(58),
		    bt = a(yt),
		    gt = n(59),
		    _t = a(gt),
		    Ct = n(176),
		    Et = a(Ct),
		    xt = n(94),
		    Ot = a(xt),
		    St = n(177),
		    Nt = a(St),
		    Mt = n(178),
		    Tt = a(Mt),
		    wt = n(95),
		    Pt = a(wt),
		    kt = n(179),
		    At = a(kt),
		    Rt = n(180),
		    It = a(Rt),
		    Lt = n(181),
		    Dt = a(Lt),
		    jt = n(185),
		    Bt = o(jt);t.Accordion = r.default, t.Alert = i.default, t.Badge = d.default, t.Breadcrumb = c.default, t.BreadcrumbItem = h.default, t.Button = v.default, t.ButtonGroup = b.default, t.ButtonToolbar = _.default, t.Carousel = E.default, t.CarouselItem = O.default, t.Checkbox = N.default, t.Clearfix = T.default, t.CloseButton = P.default, t.ControlLabel = A.default, t.Col = I.default, t.Collapse = D.default, t.Dropdown = B.default, t.DropdownButton = F.default, t.Fade = U.default, t.Form = W.default, t.FormControl = G.default, t.FormGroup = q.default, t.Glyphicon = X.default, t.Grid = J.default, t.HelpBlock = ee.default, t.Image = ne.default, t.InputGroup = ae.default, t.Jumbotron = re.default, t.Label = ie.default, t.ListGroup = de.default, t.ListGroupItem = ce.default, t.Media = he.default, t.MenuItem = ve.default, t.Modal = be.default, t.ModalBody = _e.default, t.ModalFooter = Ee.default, t.ModalHeader = Oe.default, t.ModalTitle = Ne.default, t.Nav = Te.default, t.Navbar = Pe.default, t.NavbarBrand = Ae.default, t.NavDropdown = Ie.default, t.NavItem = De.default, t.Overlay = Be.default, t.OverlayTrigger = Fe.default, t.PageHeader = Ue.default, t.PageItem = We.default, t.Pager = Ge.default, t.Pagination = qe.default, t.PaginationButton = Xe.default, t.Panel = Je.default, t.PanelGroup = et.default, t.Popover = nt.default, t.ProgressBar = at.default, t.Radio = rt.default, t.ResponsiveEmbed = it.default, t.Row = dt.default, t.SafeAnchor = ct.default, t.SplitButton = ht.default, t.Tab = vt.default, t.TabContainer = bt.default, t.TabContent = _t.default, t.Table = Et.default, t.TabPane = Ot.default, t.Tabs = Nt.default, t.Thumbnail = Tt.default, t.ToggleButton = Pt.default, t.ToggleButtonGroup = At.default, t.Tooltip = It.default, t.Well = Dt.default, t.utils = Bt;
	}, function (t, n) {
		t.exports = e;
	}, function (e, t) {
		"use strict";
		t.__esModule = !0, t.default = function (e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
		};
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(188),
		    l = o(a),
		    r = n(187),
		    u = o(r),
		    i = n(60),
		    s = o(i);t.default = function (e, t) {
			if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof t ? "undefined" : (0, s.default)(t)));e.prototype = (0, u.default)(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (l.default ? (0, l.default)(e, t) : e.__proto__ = t);
		};
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(60),
		    l = o(a);t.default = function (e, t) {
			if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" !== ("undefined" == typeof t ? "undefined" : (0, l.default)(t)) && "function" != typeof t ? e : t;
		};
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(97),
		    l = o(a);t.default = l.default || function (e) {
			for (var t = 1; t < arguments.length; t++) {
				var n = arguments[t];for (var o in n) {
					Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
				}
			}return e;
		};
	}, function (e, t) {
		"use strict";
		t.__esModule = !0, t.default = function (e, t) {
			var n = {};for (var o in e) {
				t.indexOf(o) >= 0 || Object.prototype.hasOwnProperty.call(e, o) && (n[o] = e[o]);
			}return n;
		};
	}, function (e, t, n) {
		var o, a; /*!
            Copyright (c) 2016 Jed Watson.
            Licensed under the MIT License (MIT), see
            http://jedwatson.github.io/classnames
            */
		!function () {
			"use strict";
			function n() {
				for (var e = [], t = 0; t < arguments.length; t++) {
					var o = arguments[t];if (o) {
						var a = typeof o === "undefined" ? "undefined" : _typeof(o);if ("string" === a || "number" === a) e.push(o);else if (Array.isArray(o)) e.push(n.apply(null, o));else if ("object" === a) for (var r in o) {
							l.call(o, r) && o[r] && e.push(r);
						}
					}
				}return e.join(" ");
			}var l = {}.hasOwnProperty;"undefined" != typeof e && e.exports ? e.exports = n : (o = [], a = function () {
				return n;
			}.apply(t, o), !(void 0 !== a && (e.exports = a)));
		}();
	}, function (e, t, n) {
		e.exports = n(252)();
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e) {
			return function () {
				for (var t = arguments.length, n = Array(t), o = 0; o < t; o++) {
					n[o] = arguments[o];
				}var a = n[n.length - 1];return "function" == typeof a ? e.apply(void 0, n) : function (t) {
					return e.apply(void 0, n.concat([t]));
				};
			};
		}function l(e, t) {
			return null == e.bsClass ? (0, y.default)(!1) : void 0, e.bsClass + (t ? "-" + t : "");
		}function r(e) {
			var t,
			    n = (t = {}, t[l(e)] = !0, t);if (e.bsSize) {
				var o = _.SIZE_MAP[e.bsSize] || e.bsSize;n[l(e, o)] = !0;
			}return e.bsStyle && (n[l(e, e.bsStyle)] = !0), n;
		}function u(e) {
			return { bsClass: e.bsClass, bsSize: e.bsSize, bsStyle: e.bsStyle, bsRole: e.bsRole };
		}function i(e) {
			return "bsClass" === e || "bsSize" === e || "bsStyle" === e || "bsRole" === e;
		}function s(e) {
			var t = {};return (0, p.default)(e).forEach(function (e) {
				var n = e[0],
				    o = e[1];i(n) || (t[n] = o);
			}), [u(e), t];
		}function d(e, t) {
			var n = {};t.forEach(function (e) {
				n[e] = !0;
			});var o = {};return (0, p.default)(e).forEach(function (e) {
				var t = e[0],
				    a = e[1];i(t) || n[t] || (o[t] = a);
			}), [u(e), o];
		}function f(e) {
			for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++) {
				n[o - 1] = arguments[o];
			}C(n, e);
		}t.__esModule = !0, t._curry = t.bsSizes = t.bsStyles = t.bsClass = void 0;var c = n(98),
		    p = o(c),
		    h = n(5),
		    m = o(h);t.prefix = l, t.getClassSet = r, t.splitBsProps = s, t.splitBsPropsAndOmit = d, t.addStyle = f;var v = n(48),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(12),
		    C = (t.bsClass = a(function (e, t) {
			var n = t.propTypes || (t.propTypes = {}),
			    o = t.defaultProps || (t.defaultProps = {});return n.bsClass = g.default.string, o.bsClass = e, t;
		}), t.bsStyles = a(function (e, t, n) {
			"string" != typeof t && (n = t, t = void 0);var o = n.STYLES || [],
			    a = n.propTypes || {};e.forEach(function (e) {
				o.indexOf(e) === -1 && o.push(e);
			});var l = g.default.oneOf(o);if (n.STYLES = o, l._values = o, n.propTypes = (0, m.default)({}, a, { bsStyle: l }), void 0 !== t) {
				var r = n.defaultProps || (n.defaultProps = {});r.bsStyle = t;
			}return n;
		}));t.bsSizes = a(function (e, t, n) {
			"string" != typeof t && (n = t, t = void 0);var o = n.SIZES || [],
			    a = n.propTypes || {};e.forEach(function (e) {
				o.indexOf(e) === -1 && o.push(e);
			});var l = [];o.forEach(function (e) {
				var t = _.SIZE_MAP[e];t && t !== e && l.push(t), l.push(e);
			});var r = g.default.oneOf(l);return r._values = l, n.SIZES = o, n.propTypes = (0, m.default)({}, a, { bsSize: r }), void 0 !== t && (n.defaultProps || (n.defaultProps = {}), n.defaultProps.bsSize = t), n;
		}), t._curry = a;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t, n, o, a) {
			var r = e[t],
			    i = "undefined" == typeof r ? "undefined" : l(r);return u.default.isValidElement(r) ? new Error("Invalid " + o + " `" + a + "` of type ReactElement " + ("supplied to `" + n + "`, expected an element type (a string ") + "or a ReactClass).") : "function" !== i && "string" !== i ? new Error("Invalid " + o + " `" + a + "` of value `" + r + "` " + ("supplied to `" + n + "`, expected an element type (a string ") + "or a ReactClass).") : null;
		}Object.defineProperty(t, "__esModule", { value: !0 });var l = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
			return typeof e === "undefined" ? "undefined" : _typeof(e);
		} : function (e) {
			return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
		},
		    r = n(1),
		    u = o(r),
		    i = n(52),
		    s = o(i);t.default = (0, s.default)(a), e.exports = t.default;
	}, function (e, t) {
		"use strict";
		function n() {
			for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) {
				t[n] = arguments[n];
			}return t.filter(function (e) {
				return null != e;
			}).reduce(function (e, t) {
				if ("function" != typeof t) throw new Error("Invalid Argument Type, must only provide functions, undefined, or null.");return null === e ? t : function () {
					for (var n = arguments.length, o = Array(n), a = 0; a < n; a++) {
						o[a] = arguments[a];
					}e.apply(this, o), t.apply(this, o);
				};
			}, null);
		}t.__esModule = !0, t.default = n, e.exports = t.default;
	}, function (e, t) {
		"use strict";
		t.__esModule = !0;t.Size = { LARGE: "large", SMALL: "small", XSMALL: "xsmall" }, t.SIZE_MAP = { large: "lg", medium: "md", small: "sm", xsmall: "xs", lg: "lg", md: "md", sm: "sm", xs: "xs" }, t.DEVICE_SIZES = ["lg", "md", "sm", "xs"], t.State = { SUCCESS: "success", WARNING: "warning", DANGER: "danger", INFO: "info" }, t.Style = { DEFAULT: "default", PRIMARY: "primary", LINK: "link", INVERSE: "inverse" };
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t, n) {
			var o = 0;return p.default.Children.map(e, function (e) {
				return p.default.isValidElement(e) ? t.call(n, e, o++) : e;
			});
		}function l(e, t, n) {
			var o = 0;p.default.Children.forEach(e, function (e) {
				p.default.isValidElement(e) && t.call(n, e, o++);
			});
		}function r(e) {
			var t = 0;return p.default.Children.forEach(e, function (e) {
				p.default.isValidElement(e) && ++t;
			}), t;
		}function u(e, t, n) {
			var o = 0,
			    a = [];return p.default.Children.forEach(e, function (e) {
				p.default.isValidElement(e) && t.call(n, e, o++) && a.push(e);
			}), a;
		}function i(e, t, n) {
			var o = 0,
			    a = void 0;return p.default.Children.forEach(e, function (e) {
				a || p.default.isValidElement(e) && t.call(n, e, o++) && (a = e);
			}), a;
		}function s(e, t, n) {
			var o = 0,
			    a = !0;return p.default.Children.forEach(e, function (e) {
				a && p.default.isValidElement(e) && (t.call(n, e, o++) || (a = !1));
			}), a;
		}function d(e, t, n) {
			var o = 0,
			    a = !1;return p.default.Children.forEach(e, function (e) {
				a || p.default.isValidElement(e) && t.call(n, e, o++) && (a = !0);
			}), a;
		}function f(e) {
			var t = [];return p.default.Children.forEach(e, function (e) {
				p.default.isValidElement(e) && t.push(e);
			}), t;
		}t.__esModule = !0;var c = n(1),
		    p = o(c);t.default = { map: a, forEach: l, count: r, find: i, filter: u, every: s, some: d, toArray: f }, e.exports = t.default;
	}, function (e, n) {
		e.exports = t;
	}, function (e, t, n) {
		"use strict";
		var o = function o() {};e.exports = o;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e) {
			return !e || "#" === e.trim();
		}t.__esModule = !0;var l = n(5),
		    r = o(l),
		    u = n(6),
		    i = o(u),
		    s = n(2),
		    d = o(s),
		    f = n(4),
		    c = o(f),
		    p = n(3),
		    h = o(p),
		    m = n(1),
		    v = o(m),
		    y = n(8),
		    b = o(y),
		    g = n(10),
		    _ = o(g),
		    C = n(11),
		    E = o(C),
		    x = { href: b.default.string, onClick: b.default.func, onKeyDown: b.default.func, disabled: b.default.bool, role: b.default.string, tabIndex: b.default.oneOfType([b.default.number, b.default.string]), componentClass: _.default },
		    O = { componentClass: "a" },
		    S = function (e) {
			function t(n, o) {
				(0, d.default)(this, t);var a = (0, c.default)(this, e.call(this, n, o));return a.handleClick = a.handleClick.bind(a), a.handleKeyDown = a.handleKeyDown.bind(a), a;
			}return (0, h.default)(t, e), t.prototype.handleClick = function (e) {
				var t = this.props,
				    n = t.disabled,
				    o = t.href,
				    l = t.onClick;return (n || a(o)) && e.preventDefault(), n ? void e.stopPropagation() : void (l && l(e));
			}, t.prototype.handleKeyDown = function (e) {
				" " === e.key && (e.preventDefault(), this.handleClick(e));
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.disabled,
				    o = e.onKeyDown,
				    l = (0, i.default)(e, ["componentClass", "disabled", "onKeyDown"]);return a(l.href) && (l.role = l.role || "button", l.href = l.href || "#"), n && (l.tabIndex = -1, l.style = (0, r.default)({ pointerEvents: "none" }, l.style)), v.default.createElement(t, (0, r.default)({}, l, { onClick: this.handleClick, onKeyDown: (0, E.default)(this.handleKeyDown, o) }));
			}, t;
		}(v.default.Component);S.propTypes = x, S.defaultProps = O, t.default = S, e.exports = t.default;
	}, function (e, t) {
		var n = e.exports = { version: "2.5.1" };"number" == typeof __e && (__e = n);
	}, function (e, t, n) {
		var o = n(70)("wks"),
		    a = n(44),
		    l = n(20).Symbol,
		    r = "function" == typeof l,
		    u = e.exports = function (e) {
			return o[e] || (o[e] = r && l[e] || (r ? l : a)("Symbol." + e));
		};u.store = o;
	}, function (e, t, n) {
		var o = n(20),
		    a = n(17),
		    l = n(62),
		    r = n(28),
		    u = "prototype",
		    i = function i(e, t, n) {
			var s,
			    d,
			    f,
			    c = e & i.F,
			    p = e & i.G,
			    h = e & i.S,
			    m = e & i.P,
			    v = e & i.B,
			    y = e & i.W,
			    b = p ? a : a[t] || (a[t] = {}),
			    g = b[u],
			    _ = p ? o : h ? o[t] : (o[t] || {})[u];p && (n = t);for (s in n) {
				d = !c && _ && void 0 !== _[s], d && s in b || (f = d ? _[s] : n[s], b[s] = p && "function" != typeof _[s] ? n[s] : v && d ? l(f, o) : y && _[s] == f ? function (e) {
					var t = function t(_t2, n, o) {
						if (this instanceof e) {
							switch (arguments.length) {case 0:
									return new e();case 1:
									return new e(_t2);case 2:
									return new e(_t2, n);}return new e(_t2, n, o);
						}return e.apply(this, arguments);
					};return t[u] = e[u], t;
				}(f) : m && "function" == typeof f ? l(Function.call, f) : f, m && ((b.virtual || (b.virtual = {}))[s] = f, e & i.R && g && !g[s] && r(g, s, f)));
			}
		};i.F = 1, i.G = 2, i.S = 4, i.P = 8, i.B = 16, i.W = 32, i.U = 64, i.R = 128, e.exports = i;
	}, function (e, t) {
		var n = e.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();"number" == typeof __g && (__g = n);
	}, function (e, t) {
		"use strict";
		Object.defineProperty(t, "__esModule", { value: !0 }), t.default = !("undefined" == typeof window || !window.document || !window.document.createElement), e.exports = t.default;
	}, function (e, t) {
		var n = {}.hasOwnProperty;e.exports = function (e, t) {
			return n.call(e, t);
		};
	}, function (e, t, n) {
		var o = n(26),
		    a = n(100),
		    l = n(73),
		    r = Object.defineProperty;t.f = n(27) ? Object.defineProperty : function (e, t, n) {
			if (o(e), t = l(t, !0), o(n), a) try {
				return r(e, t, n);
			} catch (e) {}if ("get" in n || "set" in n) throw TypeError("Accessors not supported!");return "value" in n && (e[t] = n.value), e;
		};
	}, function (e, t, n) {
		var o = n(101),
		    a = n(63);e.exports = function (e) {
			return o(a(e));
		};
	}, function (e, t, n) {
		e.exports = { default: n(196), __esModule: !0 };
	}, function (e, t, n) {
		var o = n(34);e.exports = function (e) {
			if (!o(e)) throw TypeError(e + " is not an object!");return e;
		};
	}, function (e, t, n) {
		e.exports = !n(33)(function () {
			return 7 != Object.defineProperty({}, "a", { get: function get() {
					return 7;
				} }).a;
		});
	}, function (e, t, n) {
		var o = n(23),
		    a = n(38);e.exports = n(27) ? function (e, t, n) {
			return o.f(e, t, a(1, n));
		} : function (e, t, n) {
			return e[t] = n, e;
		};
	}, function (e, t) {
		"use strict";
		function n(e) {
			return e && e.ownerDocument || document;
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = n, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			if (t) do {
				if (t === e) return !0;
			} while (t = t.parentNode);return !1;
		}Object.defineProperty(t, "__esModule", { value: !0 });var l = n(21),
		    r = o(l);t.default = function () {
			return r.default ? function (e, t) {
				return e.contains ? e.contains(t) : e.compareDocumentPosition ? e === t || !!(16 & e.compareDocumentPosition(t)) : a(e, t);
			} : a;
		}(), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0, t.default = function (e) {
			return (0, u.default)(l.default.findDOMNode(e));
		};var a = n(14),
		    l = o(a),
		    r = n(29),
		    u = o(r);e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(25),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(5),
		    s = o(i),
		    d = n(2),
		    f = o(d),
		    c = n(4),
		    p = o(c),
		    h = n(3),
		    m = o(h),
		    v = n(7),
		    y = o(v),
		    b = n(1),
		    g = o(b),
		    _ = n(8),
		    C = o(_),
		    E = n(10),
		    x = o(E),
		    O = n(9),
		    S = n(12),
		    N = n(16),
		    M = o(N),
		    T = { active: C.default.bool, disabled: C.default.bool, block: C.default.bool, onClick: C.default.func, componentClass: x.default, href: C.default.string, type: C.default.oneOf(["button", "reset", "submit"]) },
		    w = { active: !1, block: !1, disabled: !1 },
		    P = function (e) {
			function t() {
				return (0, f.default)(this, t), (0, p.default)(this, e.apply(this, arguments));
			}return (0, m.default)(t, e), t.prototype.renderAnchor = function (e, t) {
				return g.default.createElement(M.default, (0, s.default)({}, e, { className: (0, y.default)(t, e.disabled && "disabled") }));
			}, t.prototype.renderButton = function (e, t) {
				var n = e.componentClass,
				    o = (0, u.default)(e, ["componentClass"]),
				    a = n || "button";return g.default.createElement(a, (0, s.default)({}, o, { type: o.type || "button", className: t }));
			}, t.prototype.render = function () {
				var e,
				    t = this.props,
				    n = t.active,
				    o = t.block,
				    a = t.className,
				    l = (0, u.default)(t, ["active", "block", "className"]),
				    r = (0, O.splitBsProps)(l),
				    i = r[0],
				    d = r[1],
				    f = (0, s.default)({}, (0, O.getClassSet)(i), (e = { active: n }, e[(0, O.prefix)(i, "block")] = o, e)),
				    c = (0, y.default)(a, f);return d.href ? this.renderAnchor(d, c) : this.renderButton(d, c);
			}, t;
		}(g.default.Component);P.propTypes = T, P.defaultProps = w, t.default = (0, O.bsClass)("btn", (0, O.bsSizes)([S.Size.LARGE, S.Size.SMALL, S.Size.XSMALL], (0, O.bsStyles)([].concat((0, l.default)(S.State), [S.Style.DEFAULT, S.Style.PRIMARY, S.Style.LINK]), S.Style.DEFAULT, P))), e.exports = t.default;
	}, function (e, t) {
		e.exports = function (e) {
			try {
				return !!e();
			} catch (e) {
				return !0;
			}
		};
	}, function (e, t) {
		e.exports = function (e) {
			return "object" == (typeof e === "undefined" ? "undefined" : _typeof(e)) ? null !== e : "function" == typeof e;
		};
	}, function (e, t) {
		e.exports = {};
	}, function (e, t, n) {
		var o = n(105),
		    a = n(64);e.exports = Object.keys || function (e) {
			return o(e, a);
		};
	}, function (e, t) {
		t.f = {}.propertyIsEnumerable;
	}, function (e, t) {
		e.exports = function (e, t) {
			return { enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t };
		};
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t, n, o, a) {
			n && (e._notifying = !0, n.call.apply(n, [e, o].concat(a)), e._notifying = !1), e._values[t] = o, e.unmounted || e.forceUpdate();
		}t.__esModule = !0;var l = n(263),
		    r = o(l),
		    u = { shouldComponentUpdate: function shouldComponentUpdate() {
				return !this._notifying;
			} };t.default = (0, r.default)(u, a), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(110),
		    y = o(v),
		    b = n(30),
		    g = o(b),
		    _ = n(77),
		    C = o(_),
		    E = n(1),
		    x = o(E),
		    O = n(8),
		    S = o(O),
		    N = n(14),
		    M = o(N),
		    T = n(49),
		    w = o(T),
		    P = n(10),
		    k = o(P),
		    A = n(51),
		    R = o(A),
		    I = n(39),
		    L = o(I),
		    D = n(15),
		    j = (o(D), n(54)),
		    B = o(j),
		    K = n(134),
		    F = o(K),
		    H = n(80),
		    U = o(H),
		    z = n(9),
		    W = n(11),
		    $ = o(W),
		    G = n(182),
		    V = n(13),
		    q = o(V),
		    Y = U.default.defaultProps.bsRole,
		    X = F.default.defaultProps.bsRole,
		    Z = { dropup: S.default.bool, id: (0, R.default)(S.default.oneOfType([S.default.string, S.default.number])), componentClass: k.default, children: (0, w.default)((0, G.requiredRoles)(Y, X), (0, G.exclusiveRoles)(X)), disabled: S.default.bool, pullRight: S.default.bool, open: S.default.bool, defaultOpen: S.default.bool, onToggle: S.default.func, onSelect: S.default.func, role: S.default.string, rootCloseEvent: S.default.oneOf(["click", "mousedown"]), onMouseEnter: S.default.func, onMouseLeave: S.default.func },
		    J = { componentClass: B.default },
		    Q = function (e) {
			function t(n, o) {
				(0, s.default)(this, t);var a = (0, f.default)(this, e.call(this, n, o));return a.handleClick = a.handleClick.bind(a), a.handleKeyDown = a.handleKeyDown.bind(a), a.handleClose = a.handleClose.bind(a), a._focusInDropdown = !1, a.lastOpenEventType = null, a;
			}return (0, p.default)(t, e), t.prototype.componentDidMount = function () {
				this.focusNextOnOpen();
			}, t.prototype.componentWillUpdate = function (e) {
				!e.open && this.props.open && (this._focusInDropdown = (0, g.default)(M.default.findDOMNode(this.menu), (0, y.default)(document)));
			}, t.prototype.componentDidUpdate = function (e) {
				var t = this.props.open,
				    n = e.open;t && !n && this.focusNextOnOpen(), !t && n && this._focusInDropdown && (this._focusInDropdown = !1, this.focus());
			}, t.prototype.focus = function () {
				var e = M.default.findDOMNode(this.toggle);e && e.focus && e.focus();
			}, t.prototype.focusNextOnOpen = function () {
				var e = this.menu;e.focusNext && ("keydown" !== this.lastOpenEventType && "menuitem" !== this.props.role || e.focusNext());
			}, t.prototype.handleClick = function (e) {
				this.props.disabled || this.toggleOpen(e, { source: "click" });
			}, t.prototype.handleClose = function (e, t) {
				this.props.open && this.toggleOpen(e, t);
			}, t.prototype.handleKeyDown = function (e) {
				if (!this.props.disabled) switch (e.keyCode) {case C.default.codes.down:
						this.props.open ? this.menu.focusNext && this.menu.focusNext() : this.toggleOpen(e, { source: "keydown" }), e.preventDefault();break;case C.default.codes.esc:case C.default.codes.tab:
						this.handleClose(e, { source: "keydown" });}
			}, t.prototype.toggleOpen = function (e, t) {
				var n = !this.props.open;n && (this.lastOpenEventType = t.source), this.props.onToggle && this.props.onToggle(n, e, t);
			}, t.prototype.renderMenu = function (e, t) {
				var n = this,
				    o = t.id,
				    a = t.onSelect,
				    r = t.rootCloseEvent,
				    i = (0, u.default)(t, ["id", "onSelect", "rootCloseEvent"]),
				    s = function s(e) {
					n.menu = e;
				};return "string" == typeof e.ref || (s = (0, $.default)(e.ref, s)), (0, E.cloneElement)(e, (0, l.default)({}, i, { ref: s, labelledBy: o, bsClass: (0, z.prefix)(i, "menu"), onClose: (0, $.default)(e.props.onClose, this.handleClose), onSelect: (0, $.default)(e.props.onSelect, a, function (e, t) {
						return n.handleClose(t, { source: "select" });
					}), rootCloseEvent: r }));
			}, t.prototype.renderToggle = function (e, t) {
				var n = this,
				    o = function o(e) {
					n.toggle = e;
				};return "string" == typeof e.ref || (o = (0, $.default)(e.ref, o)), (0, E.cloneElement)(e, (0, l.default)({}, t, { ref: o, bsClass: (0, z.prefix)(t, "toggle"), onClick: (0, $.default)(e.props.onClick, this.handleClick), onKeyDown: (0, $.default)(e.props.onKeyDown, this.handleKeyDown) }));
			}, t.prototype.render = function () {
				var e,
				    t = this,
				    n = this.props,
				    o = n.componentClass,
				    a = n.id,
				    r = n.dropup,
				    i = n.disabled,
				    s = n.pullRight,
				    d = n.open,
				    f = n.onSelect,
				    c = n.role,
				    p = n.bsClass,
				    h = n.className,
				    v = n.rootCloseEvent,
				    y = n.children,
				    b = (0, u.default)(n, ["componentClass", "id", "dropup", "disabled", "pullRight", "open", "onSelect", "role", "bsClass", "className", "rootCloseEvent", "children"]);delete b.onToggle;var g = (e = {}, e[p] = !0, e.open = d, e.disabled = i, e);return r && (g[p] = !1, g.dropup = !0), x.default.createElement(o, (0, l.default)({}, b, { className: (0, m.default)(h, g) }), q.default.map(y, function (e) {
					switch (e.props.bsRole) {case Y:
							return t.renderToggle(e, { id: a, disabled: i, open: d, role: c, bsClass: p });case X:
							return t.renderMenu(e, { id: a, open: d, pullRight: s, bsClass: p, onSelect: f, rootCloseEvent: v });default:
							return e;}
				}));
			}, t;
		}(x.default.Component);Q.propTypes = Z, Q.defaultProps = J, (0, z.bsClass)("dropdown", Q);var ee = (0, L.default)(Q, { open: "onToggle" });ee.Toggle = U.default, ee.Menu = F.default, t.default = ee, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(2),
		    u = o(r),
		    i = n(4),
		    s = o(i),
		    d = n(3),
		    f = o(d),
		    c = n(7),
		    p = o(c),
		    h = n(1),
		    m = o(h),
		    v = n(8),
		    y = o(v),
		    b = n(119),
		    g = o(b),
		    _ = { in: y.default.bool, mountOnEnter: y.default.bool, unmountOnExit: y.default.bool, transitionAppear: y.default.bool, timeout: y.default.number, onEnter: y.default.func, onEntering: y.default.func, onEntered: y.default.func, onExit: y.default.func, onExiting: y.default.func, onExited: y.default.func },
		    C = { in: !1, timeout: 300, mountOnEnter: !1, unmountOnExit: !1, transitionAppear: !1 },
		    E = function (e) {
			function t() {
				return (0, u.default)(this, t), (0, s.default)(this, e.apply(this, arguments));
			}return (0, f.default)(t, e), t.prototype.render = function () {
				return m.default.createElement(g.default, (0, l.default)({}, this.props, { className: (0, p.default)(this.props.className, "fade"), enteredClassName: "in", enteringClassName: "in" }));
			}, t;
		}(m.default.Component);E.propTypes = _, E.defaultProps = C, t.default = E, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(10),
		    g = o(b),
		    _ = n(148),
		    C = o(_),
		    E = n(149),
		    x = o(E),
		    O = n(150),
		    S = o(O),
		    N = n(151),
		    M = o(N),
		    T = n(152),
		    w = o(T),
		    P = n(153),
		    k = o(P),
		    A = n(9),
		    R = { componentClass: g.default },
		    I = { componentClass: "div" },
		    L = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.className,
				    o = (0, u.default)(e, ["componentClass", "className"]),
				    a = (0, A.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = (0, A.getClassSet)(r);return y.default.createElement(t, (0, l.default)({}, i, { className: (0, m.default)(n, s) }));
			}, t;
		}(y.default.Component);L.propTypes = R, L.defaultProps = I, L.Heading = x.default, L.Body = C.default, L.Left = S.default, L.Right = k.default, L.List = M.default, L.ListItem = w.default, t.default = (0, A.bsClass)("media", L), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			var n = t.propTypes,
			    o = {},
			    a = {};return (0, r.default)(e).forEach(function (e) {
				var t = e[0],
				    l = e[1];n[t] ? o[t] = l : a[t] = l;
			}), [o, a];
		}t.__esModule = !0;var l = n(98),
		    r = o(l);t.default = a, e.exports = t.default;
	}, function (e, t) {
		var n = 0,
		    o = Math.random();e.exports = function (e) {
			return "Symbol(".concat(void 0 === e ? "" : e, ")_", (++n + o).toString(36));
		};
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}Object.defineProperty(t, "__esModule", { value: !0 });var a = n(21),
		    l = o(a),
		    r = function r() {};l.default && (r = function () {
			return document.addEventListener ? function (e, t, n, o) {
				return e.addEventListener(t, n, o || !1);
			} : document.attachEvent ? function (e, t, n) {
				return e.attachEvent("on" + t, function (t) {
					t = t || window.event, t.target = t.target || t.srcElement, t.currentTarget = e, n.call(e, t);
				});
			} : void 0;
		}()), t.default = r, e.exports = t.default;
	}, function (e, t) {
		"use strict";
		function n(e) {
			return e === e.window ? e : 9 === e.nodeType && (e.defaultView || e.parentWindow);
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = n, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t, n) {
			var o = "",
			    a = "",
			    l = t;if ("string" == typeof t) {
				if (void 0 === n) return e.style[(0, r.default)(t)] || (0, d.default)(e).getPropertyValue((0, i.default)(t));(l = {})[t] = n;
			}Object.keys(l).forEach(function (t) {
				var n = l[t];n || 0 === n ? (0, m.default)(t) ? a += t + "(" + n + ") " : o += (0, i.default)(t) + ": " + n + ";" : (0, c.default)(e, (0, i.default)(t));
			}), a && (o += p.transform + ": " + a + ";"), e.style.cssText += ";" + o;
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;var l = n(115),
		    r = o(l),
		    u = n(248),
		    i = o(u),
		    s = n(243),
		    d = o(s),
		    f = n(244),
		    c = o(f),
		    p = n(114),
		    h = n(245),
		    m = o(h);e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		var o = function o(e, t, n, _o, a, l, r, u) {
			if (!e) {
				var i;if (void 0 === t) i = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else {
					var s = [n, _o, a, l, r, u],
					    d = 0;i = new Error(t.replace(/%s/g, function () {
						return s[d++];
					})), i.name = "Invariant Violation";
				}throw i.framesToPop = 1, i;
			}
		};e.exports = o;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a() {
			function e() {
				for (var e = arguments.length, t = Array(e), o = 0; o < e; o++) {
					t[o] = arguments[o];
				}var a = null;return n.forEach(function (e) {
					if (null == a) {
						var n = e.apply(void 0, t);null != n && (a = n);
					}
				}), a;
			}for (var t = arguments.length, n = Array(t), o = 0; o < t; o++) {
				n[o] = arguments[o];
			}return (0, r.default)(e);
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;var l = n(52),
		    r = o(l);e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t, n, o, a) {
			var r = e[t],
			    i = "undefined" == typeof r ? "undefined" : l(r);return u.default.isValidElement(r) ? new Error("Invalid " + o + " `" + a + "` of type ReactElement " + ("supplied to `" + n + "`, expected a ReactComponent or a ") + "DOMElement. You can usually obtain a ReactComponent or DOMElement from a ReactElement by attaching a ref to it.") : "object" === i && "function" == typeof r.render || 1 === r.nodeType ? null : new Error("Invalid " + o + " `" + a + "` of value `" + r + "` " + ("supplied to `" + n + "`, expected a ReactComponent or a ") + "DOMElement.");
		}Object.defineProperty(t, "__esModule", { value: !0 });var l = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
			return typeof e === "undefined" ? "undefined" : _typeof(e);
		} : function (e) {
			return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
		},
		    r = n(1),
		    u = o(r),
		    i = n(52),
		    s = o(i);t.default = (0, s.default)(a), e.exports = t.default;
	}, function (e, t) {
		"use strict";
		function n(e) {
			return function (t, n, o, a, l) {
				var r = o || "<<anonymous>>",
				    u = l || n;if (null == t[n]) return new Error("The " + a + " `" + u + "` is required to make " + ("`" + r + "` accessible for users of assistive ") + "technologies such as screen readers.");for (var i = arguments.length, s = Array(i > 5 ? i - 5 : 0), d = 5; d < i; d++) {
					s[d - 5] = arguments[d];
				}return e.apply(void 0, [t, n, o, a, l].concat(s));
			};
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = n, e.exports = t.default;
	}, function (e, t) {
		"use strict";
		function n(e) {
			function t(t, n, o, a, l, r) {
				var u = a || "<<anonymous>>",
				    i = r || o;if (null == n[o]) return t ? new Error("Required " + l + " `" + i + "` was not specified " + ("in `" + u + "`.")) : null;for (var s = arguments.length, d = Array(s > 6 ? s - 6 : 0), f = 6; f < s; f++) {
					d[f - 6] = arguments[f];
				}return e.apply(void 0, [n, o, u, l, i].concat(d));
			}var n = t.bind(null, !1);return n.isRequired = t.bind(null, !0), n;
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = n, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			return e = "function" == typeof e ? e() : e, r.default.findDOMNode(e) || t;
		}t.__esModule = !0, t.default = a;var l = n(14),
		    r = o(l);e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(49),
		    C = o(_),
		    E = n(32),
		    x = o(E),
		    O = n(9),
		    S = { vertical: g.default.bool, justified: g.default.bool, block: (0, C.default)(g.default.bool, function (e) {
				var t = e.block,
				    n = e.vertical;return t && !n ? new Error("`block` requires `vertical` to be set to have any effect") : null;
			}) },
		    N = { block: !1, justified: !1, vertical: !1 },
		    M = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e,
				    t = this.props,
				    n = t.block,
				    o = t.justified,
				    a = t.vertical,
				    r = t.className,
				    i = (0, u.default)(t, ["block", "justified", "vertical", "className"]),
				    s = (0, O.splitBsProps)(i),
				    d = s[0],
				    f = s[1],
				    c = (0, l.default)({}, (0, O.getClassSet)(d), (e = {}, e[(0, O.prefix)(d)] = !a, e[(0, O.prefix)(d, "vertical")] = a, e[(0, O.prefix)(d, "justified")] = o, e[(0, O.prefix)(x.default.defaultProps, "block")] = n, e));return y.default.createElement("div", (0, l.default)({}, f, { className: (0, m.default)(r, c) }));
			}, t;
		}(y.default.Component);M.propTypes = S, M.defaultProps = N, t.default = (0, O.bsClass)("btn-group", M), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(2),
		    l = o(a),
		    r = n(4),
		    u = o(r),
		    i = n(3),
		    s = o(i),
		    d = n(8),
		    f = o(d),
		    c = n(1),
		    p = o(c),
		    h = { label: f.default.string.isRequired, onClick: f.default.func },
		    m = { label: "Close" },
		    v = function (e) {
			function t() {
				return (0, l.default)(this, t), (0, u.default)(this, e.apply(this, arguments));
			}return (0, s.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.label,
				    n = e.onClick;return p.default.createElement("button", { type: "button", className: "close", onClick: n }, p.default.createElement("span", { "aria-hidden": "true" }, "×"), p.default.createElement("span", { className: "sr-only" }, t));
			}, t;
		}(p.default.Component);v.propTypes = h, v.defaultProps = m, t.default = v, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e) {
			e.offsetHeight;
		}function l(e, t) {
			var n = t["offset" + (0, M.default)(e)],
			    o = P[e];return n + parseInt((0, g.default)(t, o[0]), 10) + parseInt((0, g.default)(t, o[1]), 10);
		}t.__esModule = !0;var r = n(5),
		    u = o(r),
		    i = n(6),
		    s = o(i),
		    d = n(2),
		    f = o(d),
		    c = n(4),
		    p = o(c),
		    h = n(3),
		    m = o(h),
		    v = n(7),
		    y = o(v),
		    b = n(47),
		    g = o(b),
		    _ = n(1),
		    C = o(_),
		    E = n(8),
		    x = o(E),
		    O = n(119),
		    S = o(O),
		    N = n(96),
		    M = o(N),
		    T = n(11),
		    w = o(T),
		    P = { height: ["marginTop", "marginBottom"], width: ["marginLeft", "marginRight"] },
		    k = { in: x.default.bool, mountOnEnter: x.default.bool, unmountOnExit: x.default.bool, transitionAppear: x.default.bool, timeout: x.default.number, onEnter: x.default.func, onEntering: x.default.func, onEntered: x.default.func, onExit: x.default.func, onExiting: x.default.func, onExited: x.default.func, dimension: x.default.oneOfType([x.default.oneOf(["height", "width"]), x.default.func]), getDimensionValue: x.default.func, role: x.default.string },
		    A = { in: !1, timeout: 300, mountOnEnter: !1, unmountOnExit: !1, transitionAppear: !1, dimension: "height", getDimensionValue: l },
		    R = function (e) {
			function t(n, o) {
				(0, f.default)(this, t);var a = (0, p.default)(this, e.call(this, n, o));return a.handleEnter = a.handleEnter.bind(a), a.handleEntering = a.handleEntering.bind(a), a.handleEntered = a.handleEntered.bind(a), a.handleExit = a.handleExit.bind(a), a.handleExiting = a.handleExiting.bind(a), a;
			}return (0, m.default)(t, e), t.prototype._dimension = function () {
				return "function" == typeof this.props.dimension ? this.props.dimension() : this.props.dimension;
			}, t.prototype._getScrollDimensionValue = function (e, t) {
				return e["scroll" + (0, M.default)(t)] + "px";
			}, t.prototype.handleEnter = function (e) {
				var t = this._dimension();e.style[t] = "0";
			}, t.prototype.handleEntered = function (e) {
				var t = this._dimension();e.style[t] = null;
			}, t.prototype.handleEntering = function (e) {
				var t = this._dimension();e.style[t] = this._getScrollDimensionValue(e, t);
			}, t.prototype.handleExit = function (e) {
				var t = this._dimension();e.style[t] = this.props.getDimensionValue(t, e) + "px", a(e);
			}, t.prototype.handleExiting = function (e) {
				var t = this._dimension();e.style[t] = "0";
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.onEnter,
				    n = e.onEntering,
				    o = e.onEntered,
				    a = e.onExit,
				    l = e.onExiting,
				    r = e.className,
				    i = (0, s.default)(e, ["onEnter", "onEntering", "onEntered", "onExit", "onExiting", "className"]);delete i.dimension, delete i.getDimensionValue;var d = (0, w.default)(this.handleEnter, t),
				    f = (0, w.default)(this.handleEntering, n),
				    c = (0, w.default)(this.handleEntered, o),
				    p = (0, w.default)(this.handleExit, a),
				    h = (0, w.default)(this.handleExiting, l),
				    m = { width: "width" === this._dimension() };return C.default.createElement(S.default, (0, u.default)({}, i, { "aria-expanded": i.role ? i.in : null, className: (0, y.default)(r, m), exitedClassName: "collapse", exitingClassName: "collapsing", enteredClassName: "collapse in", enteringClassName: "collapsing", onEnter: d, onEntering: f, onEntered: c, onExit: p, onExiting: h }));
			}, t;
		}(C.default.Component);R.propTypes = k, R.defaultProps = A, t.default = R, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(9),
		    C = { glyph: g.default.string.isRequired },
		    E = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e,
				    t = this.props,
				    n = t.glyph,
				    o = t.className,
				    a = (0, u.default)(t, ["glyph", "className"]),
				    r = (0, _.splitBsProps)(a),
				    i = r[0],
				    s = r[1],
				    d = (0, l.default)({}, (0, _.getClassSet)(i), (e = {}, e[(0, _.prefix)(i, n)] = !0, e));return y.default.createElement("span", (0, l.default)({}, s, { className: (0, m.default)(o, d) }));
			}, t;
		}(y.default.Component);E.propTypes = C, t.default = (0, _.bsClass)("glyphicon", E), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(6),
		    l = o(a),
		    r = n(2),
		    u = o(r),
		    i = n(4),
		    s = o(i),
		    d = n(3),
		    f = o(d),
		    c = n(1),
		    p = o(c),
		    h = n(8),
		    m = o(h),
		    v = n(39),
		    y = o(v),
		    b = "tab",
		    g = "pane",
		    _ = m.default.oneOfType([m.default.string, m.default.number]),
		    C = { id: function id(e) {
				var t = null;if (!e.generateChildId) {
					for (var n = arguments.length, o = Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++) {
						o[a - 1] = arguments[a];
					}t = _.apply(void 0, [e].concat(o)), t || e.id || (t = new Error("In order to properly initialize Tabs in a way that is accessible to assistive technologies (such as screen readers) an `id` or a `generateChildId` prop to TabContainer is required"));
				}return t;
			}, generateChildId: m.default.func, onSelect: m.default.func, activeKey: m.default.any },
		    E = { $bs_tabContainer: m.default.shape({ activeKey: m.default.any, onSelect: m.default.func.isRequired, getTabId: m.default.func.isRequired, getPaneId: m.default.func.isRequired }) },
		    x = function (e) {
			function t() {
				return (0, u.default)(this, t), (0, s.default)(this, e.apply(this, arguments));
			}return (0, f.default)(t, e), t.prototype.getChildContext = function () {
				var e = this.props,
				    t = e.activeKey,
				    n = e.onSelect,
				    o = e.generateChildId,
				    a = e.id,
				    l = o || function (e, t) {
					return a ? a + "-" + t + "-" + e : null;
				};return { $bs_tabContainer: { activeKey: t, onSelect: n, getTabId: function getTabId(e) {
							return l(e, b);
						}, getPaneId: function getPaneId(e) {
							return l(e, g);
						} } };
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.children,
				    n = (0, l.default)(e, ["children"]);return delete n.generateChildId, delete n.onSelect, delete n.activeKey, p.default.cloneElement(p.default.Children.only(t), n);
			}, t;
		}(p.default.Component);x.propTypes = C, x.childContextTypes = E, t.default = (0, y.default)(x, { activeKey: "onSelect" }), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(10),
		    C = o(_),
		    E = n(9),
		    x = { componentClass: C.default, animation: g.default.oneOfType([g.default.bool, C.default]), mountOnEnter: g.default.bool, unmountOnExit: g.default.bool },
		    O = { componentClass: "div", animation: !0, mountOnEnter: !1, unmountOnExit: !1 },
		    S = { $bs_tabContainer: g.default.shape({ activeKey: g.default.any }) },
		    N = { $bs_tabContent: g.default.shape({ bsClass: g.default.string, animation: g.default.oneOfType([g.default.bool, C.default]), activeKey: g.default.any, mountOnEnter: g.default.bool, unmountOnExit: g.default.bool, onPaneEnter: g.default.func.isRequired, onPaneExited: g.default.func.isRequired, exiting: g.default.bool.isRequired }) },
		    M = function (e) {
			function t(n, o) {
				(0, s.default)(this, t);var a = (0, f.default)(this, e.call(this, n, o));return a.handlePaneEnter = a.handlePaneEnter.bind(a), a.handlePaneExited = a.handlePaneExited.bind(a), a.state = { activeKey: null, activeChild: null }, a;
			}return (0, p.default)(t, e), t.prototype.getChildContext = function () {
				var e = this.props,
				    t = e.bsClass,
				    n = e.animation,
				    o = e.mountOnEnter,
				    a = e.unmountOnExit,
				    l = this.state.activeKey,
				    r = this.getContainerActiveKey(),
				    u = null != l ? l : r,
				    i = null != l && l !== r;
				return { $bs_tabContent: { bsClass: t, animation: n, activeKey: u, mountOnEnter: o, unmountOnExit: a, onPaneEnter: this.handlePaneEnter, onPaneExited: this.handlePaneExited, exiting: i } };
			}, t.prototype.componentWillReceiveProps = function (e) {
				!e.animation && this.state.activeChild && this.setState({ activeKey: null, activeChild: null });
			}, t.prototype.componentWillUnmount = function () {
				this.isUnmounted = !0;
			}, t.prototype.getContainerActiveKey = function () {
				var e = this.context.$bs_tabContainer;return e && e.activeKey;
			}, t.prototype.handlePaneEnter = function (e, t) {
				return !!this.props.animation && t === this.getContainerActiveKey() && (this.setState({ activeKey: t, activeChild: e }), !0);
			}, t.prototype.handlePaneExited = function (e) {
				this.isUnmounted || this.setState(function (t) {
					var n = t.activeChild;return n !== e ? null : { activeKey: null, activeChild: null };
				});
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.className,
				    o = (0, u.default)(e, ["componentClass", "className"]),
				    a = (0, E.splitBsPropsAndOmit)(o, ["animation", "mountOnEnter", "unmountOnExit"]),
				    r = a[0],
				    i = a[1];return y.default.createElement(t, (0, l.default)({}, i, { className: (0, m.default)(n, (0, E.prefix)(r, "content")) }));
			}, t;
		}(y.default.Component);M.propTypes = x, M.defaultProps = O, M.contextTypes = S, M.childContextTypes = N, t.default = (0, E.bsClass)("tab", M), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(190),
		    l = o(a),
		    r = n(189),
		    u = o(r),
		    i = "function" == typeof u.default && "symbol" == _typeof(l.default) ? function (e) {
			return typeof e === "undefined" ? "undefined" : _typeof(e);
		} : function (e) {
			return e && "function" == typeof u.default && e.constructor === u.default && e !== u.default.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
		};t.default = "function" == typeof u.default && "symbol" === i(l.default) ? function (e) {
			return "undefined" == typeof e ? "undefined" : i(e);
		} : function (e) {
			return e && "function" == typeof u.default && e.constructor === u.default && e !== u.default.prototype ? "symbol" : "undefined" == typeof e ? "undefined" : i(e);
		};
	}, function (e, t) {
		var n = {}.toString;e.exports = function (e) {
			return n.call(e).slice(8, -1);
		};
	}, function (e, t, n) {
		var o = n(199);e.exports = function (e, t, n) {
			if (o(e), void 0 === t) return e;switch (n) {case 1:
					return function (n) {
						return e.call(t, n);
					};case 2:
					return function (n, o) {
						return e.call(t, n, o);
					};case 3:
					return function (n, o, a) {
						return e.call(t, n, o, a);
					};}return function () {
				return e.apply(t, arguments);
			};
		};
	}, function (e, t) {
		e.exports = function (e) {
			if (void 0 == e) throw TypeError("Can't call method on  " + e);return e;
		};
	}, function (e, t) {
		e.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
	}, function (e, t) {
		e.exports = !0;
	}, function (e, t, n) {
		var o = n(26),
		    a = n(214),
		    l = n(64),
		    r = n(69)("IE_PROTO"),
		    u = function u() {},
		    i = "prototype",
		    _s = function s() {
			var e,
			    t = n(99)("iframe"),
			    o = l.length,
			    a = "<",
			    r = ">";for (t.style.display = "none", n(205).appendChild(t), t.src = "javascript:", e = t.contentWindow.document, e.open(), e.write(a + "script" + r + "document.F=Object" + a + "/script" + r), e.close(), _s = e.F; o--;) {
				delete _s[i][l[o]];
			}return _s();
		};e.exports = Object.create || function (e, t) {
			var n;return null !== e ? (u[i] = o(e), n = new u(), u[i] = null, n[r] = e) : n = _s(), void 0 === t ? n : a(n, t);
		};
	}, function (e, t) {
		t.f = Object.getOwnPropertySymbols;
	}, function (e, t, n) {
		var o = n(23).f,
		    a = n(22),
		    l = n(18)("toStringTag");e.exports = function (e, t, n) {
			e && !a(e = n ? e : e.prototype, l) && o(e, l, { configurable: !0, value: t });
		};
	}, function (e, t, n) {
		var o = n(70)("keys"),
		    a = n(44);e.exports = function (e) {
			return o[e] || (o[e] = a(e));
		};
	}, function (e, t, n) {
		var o = n(20),
		    a = "__core-js_shared__",
		    l = o[a] || (o[a] = {});e.exports = function (e) {
			return l[e] || (l[e] = {});
		};
	}, function (e, t) {
		var n = Math.ceil,
		    o = Math.floor;e.exports = function (e) {
			return isNaN(e = +e) ? 0 : (e > 0 ? o : n)(e);
		};
	}, function (e, t, n) {
		var o = n(63);e.exports = function (e) {
			return Object(o(e));
		};
	}, function (e, t, n) {
		var o = n(34);e.exports = function (e, t) {
			if (!o(e)) return e;var n, a;if (t && "function" == typeof (n = e.toString) && !o(a = n.call(e))) return a;if ("function" == typeof (n = e.valueOf) && !o(a = n.call(e))) return a;if (!t && "function" == typeof (n = e.toString) && !o(a = n.call(e))) return a;throw TypeError("Can't convert object to primitive value");
		};
	}, function (e, t, n) {
		var o = n(20),
		    a = n(17),
		    l = n(65),
		    r = n(75),
		    u = n(23).f;e.exports = function (e) {
			var t = a.Symbol || (a.Symbol = l ? {} : o.Symbol || {});"_" == e.charAt(0) || e in t || u(t, e, { value: r.f(e) });
		};
	}, function (e, t, n) {
		t.f = n(18);
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}Object.defineProperty(t, "__esModule", { value: !0 });var a = n(21),
		    l = o(a),
		    r = function r() {};l.default && (r = function () {
			return document.addEventListener ? function (e, t, n, o) {
				return e.removeEventListener(t, n, o || !1);
			} : document.attachEvent ? function (e, t, n) {
				return e.detachEvent("on" + t, n);
			} : void 0;
		}()), t.default = r, e.exports = t.default;
	}, function (e, t) {
		t = e.exports = function (e) {
			if (e && "object" == (typeof e === "undefined" ? "undefined" : _typeof(e))) {
				var t = e.which || e.keyCode || e.charCode;t && (e = t);
			}if ("number" == typeof e) return l[e];var a = String(e),
			    r = n[a.toLowerCase()];if (r) return r;var r = o[a.toLowerCase()];return r ? r : 1 === a.length ? a.charCodeAt(0) : void 0;
		};var n = t.code = t.codes = { backspace: 8, tab: 9, enter: 13, shift: 16, ctrl: 17, alt: 18, "pause/break": 19, "caps lock": 20, esc: 27, space: 32, "page up": 33, "page down": 34, end: 35, home: 36, left: 37, up: 38, right: 39, down: 40, insert: 45, delete: 46, command: 91, "left command": 91, "right command": 93, "numpad *": 106, "numpad +": 107, "numpad -": 109, "numpad .": 110, "numpad /": 111, "num lock": 144, "scroll lock": 145, "my computer": 182, "my calculator": 183, ";": 186, "=": 187, ",": 188, "-": 189, ".": 190, "/": 191, "`": 192, "[": 219, "\\": 220, "]": 221, "'": 222 },
		    o = t.aliases = { windows: 91, "⇧": 16, "⌥": 18, "⌃": 17, "⌘": 91, ctl: 17, control: 17, option: 18, pause: 19, break: 19, caps: 20, return: 13, escape: 27, spc: 32, pgup: 33, pgdn: 34, ins: 45, del: 46, cmd: 91 }; /*!
                                                                                                                                                                                                                             * Programatically add the following
                                                                                                                                                                                                                             */
		for (a = 97; a < 123; a++) {
			n[String.fromCharCode(a)] = a - 32;
		}for (var a = 48; a < 58; a++) {
			n[a - 48] = a;
		}for (a = 1; a < 13; a++) {
			n["f" + a] = a + 111;
		}for (a = 0; a < 10; a++) {
			n["numpad " + a] = a + 96;
		}var l = t.names = t.title = {};for (a in n) {
			l[n[a]] = a;
		}for (var r in o) {
			n[r] = o[r];
		}
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(16),
		    C = o(_),
		    E = { active: g.default.bool, href: g.default.string, title: g.default.node, target: g.default.string },
		    x = { active: !1 },
		    O = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.active,
				    n = e.href,
				    o = e.title,
				    a = e.target,
				    r = e.className,
				    i = (0, u.default)(e, ["active", "href", "title", "target", "className"]),
				    s = { href: n, title: o, target: a };return y.default.createElement("li", { className: (0, m.default)(r, { active: t }) }, t ? y.default.createElement("span", i) : y.default.createElement(C.default, (0, l.default)({}, i, s)));
			}, t;
		}(y.default.Component);O.propTypes = E, O.defaultProps = x, t.default = O, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(14),
		    C = o(_),
		    E = n(183),
		    x = o(E),
		    O = { direction: g.default.oneOf(["prev", "next"]), onAnimateOutEnd: g.default.func, active: g.default.bool, animateIn: g.default.bool, animateOut: g.default.bool, index: g.default.number },
		    S = { active: !1, animateIn: !1, animateOut: !1 },
		    N = function (e) {
			function t(n, o) {
				(0, s.default)(this, t);var a = (0, f.default)(this, e.call(this, n, o));return a.handleAnimateOutEnd = a.handleAnimateOutEnd.bind(a), a.state = { direction: null }, a.isUnmounted = !1, a;
			}return (0, p.default)(t, e), t.prototype.componentWillReceiveProps = function (e) {
				this.props.active !== e.active && this.setState({ direction: null });
			}, t.prototype.componentDidUpdate = function (e) {
				var t = this,
				    n = this.props.active,
				    o = e.active;!n && o && x.default.addEndEventListener(C.default.findDOMNode(this), this.handleAnimateOutEnd), n !== o && setTimeout(function () {
					return t.startAnimation();
				}, 20);
			}, t.prototype.componentWillUnmount = function () {
				this.isUnmounted = !0;
			}, t.prototype.handleAnimateOutEnd = function () {
				this.isUnmounted || this.props.onAnimateOutEnd && this.props.onAnimateOutEnd(this.props.index);
			}, t.prototype.startAnimation = function () {
				this.isUnmounted || this.setState({ direction: "prev" === this.props.direction ? "right" : "left" });
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.direction,
				    n = e.active,
				    o = e.animateIn,
				    a = e.animateOut,
				    r = e.className,
				    i = (0, u.default)(e, ["direction", "active", "animateIn", "animateOut", "className"]);delete i.onAnimateOutEnd, delete i.index;var s = { item: !0, active: n && !o || a };return t && n && o && (s[t] = !0), this.state.direction && (o || a) && (s[this.state.direction] = !0), y.default.createElement("div", (0, l.default)({}, i, { className: (0, m.default)(r, s) }));
			}, t;
		}(y.default.Component);N.propTypes = O, N.defaultProps = S, t.default = N, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(1),
		    m = o(h),
		    v = n(8),
		    y = o(v),
		    b = n(7),
		    g = o(b),
		    _ = n(32),
		    C = o(_),
		    E = n(16),
		    x = o(E),
		    O = n(9),
		    S = { noCaret: y.default.bool, open: y.default.bool, title: y.default.string, useAnchor: y.default.bool },
		    N = { open: !1, useAnchor: !1, bsRole: "toggle" },
		    M = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.noCaret,
				    n = e.open,
				    o = e.useAnchor,
				    a = e.bsClass,
				    r = e.className,
				    i = e.children,
				    s = (0, u.default)(e, ["noCaret", "open", "useAnchor", "bsClass", "className", "children"]);delete s.bsRole;var d = o ? x.default : C.default,
				    f = !t;return m.default.createElement(d, (0, l.default)({}, s, { role: "button", className: (0, g.default)(r, a), "aria-haspopup": !0, "aria-expanded": n }), i || s.title, f && " ", f && m.default.createElement("span", { className: "caret" }));
			}, t;
		}(m.default.Component);M.propTypes = S, M.defaultProps = N, t.default = (0, O.bsClass)("dropdown-toggle", M), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(10),
		    C = o(_),
		    E = n(9),
		    x = { fluid: g.default.bool, componentClass: C.default },
		    O = { componentClass: "div", fluid: !1 },
		    S = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.fluid,
				    n = e.componentClass,
				    o = e.className,
				    a = (0, u.default)(e, ["fluid", "componentClass", "className"]),
				    r = (0, E.splitBsProps)(a),
				    i = r[0],
				    s = r[1],
				    d = (0, E.prefix)(i, t && "fluid");return y.default.createElement(n, (0, l.default)({}, s, { className: (0, m.default)(o, d) }));
			}, t;
		}(y.default.Component);S.propTypes = x, S.defaultProps = O, t.default = (0, E.bsClass)("container", S), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(25),
		    l = o(a),
		    r = n(5),
		    u = o(r),
		    i = n(6),
		    s = o(i),
		    d = n(2),
		    f = o(d),
		    c = n(4),
		    p = o(c),
		    h = n(3),
		    m = o(h),
		    v = n(7),
		    y = o(v),
		    b = n(1),
		    g = o(b),
		    _ = n(8),
		    C = o(_),
		    E = n(9),
		    x = n(12),
		    O = { active: C.default.any, disabled: C.default.any, header: C.default.node, listItem: C.default.bool, onClick: C.default.func, href: C.default.string, type: C.default.string },
		    S = { listItem: !1 },
		    N = function (e) {
			function t() {
				return (0, f.default)(this, t), (0, p.default)(this, e.apply(this, arguments));
			}return (0, m.default)(t, e), t.prototype.renderHeader = function (e, t) {
				return g.default.isValidElement(e) ? (0, b.cloneElement)(e, { className: (0, y.default)(e.props.className, t) }) : g.default.createElement("h4", { className: t }, e);
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.active,
				    n = e.disabled,
				    o = e.className,
				    a = e.header,
				    l = e.listItem,
				    r = e.children,
				    i = (0, s.default)(e, ["active", "disabled", "className", "header", "listItem", "children"]),
				    d = (0, E.splitBsProps)(i),
				    f = d[0],
				    c = d[1],
				    p = (0, u.default)({}, (0, E.getClassSet)(f), { active: t, disabled: n }),
				    h = void 0;return c.href ? h = "a" : c.onClick ? (h = "button", c.type = c.type || "button") : h = l ? "li" : "span", c.className = (0, y.default)(o, p), a ? g.default.createElement(h, c, this.renderHeader(a, (0, E.prefix)(f, "heading")), g.default.createElement("p", { className: (0, E.prefix)(f, "text") }, r)) : g.default.createElement(h, c, r);
			}, t;
		}(g.default.Component);N.propTypes = O, N.defaultProps = S, t.default = (0, E.bsClass)("list-group-item", (0, E.bsStyles)((0, l.default)(x.State), N)), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(10),
		    g = o(b),
		    _ = n(9),
		    C = { componentClass: g.default },
		    E = { componentClass: "div" },
		    x = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.className,
				    o = (0, u.default)(e, ["componentClass", "className"]),
				    a = (0, _.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = (0, _.getClassSet)(r);return y.default.createElement(t, (0, l.default)({}, i, { className: (0, m.default)(n, s) }));
			}, t;
		}(y.default.Component);x.propTypes = C, x.defaultProps = E, t.default = (0, _.bsClass)("modal-body", x), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(10),
		    g = o(b),
		    _ = n(9),
		    C = { componentClass: g.default },
		    E = { componentClass: "div" },
		    x = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.className,
				    o = (0, u.default)(e, ["componentClass", "className"]),
				    a = (0, _.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = (0, _.getClassSet)(r);return y.default.createElement(t, (0, l.default)({}, i, { className: (0, m.default)(n, s) }));
			}, t;
		}(y.default.Component);x.propTypes = C, x.defaultProps = E, t.default = (0, _.bsClass)("modal-footer", x), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(9),
		    C = n(11),
		    E = o(C),
		    x = n(55),
		    O = o(x),
		    S = { closeLabel: g.default.string, closeButton: g.default.bool, onHide: g.default.func },
		    N = { closeLabel: "Close", closeButton: !1 },
		    M = { $bs_modal: g.default.shape({ onHide: g.default.func }) },
		    T = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.closeLabel,
				    n = e.closeButton,
				    o = e.onHide,
				    a = e.className,
				    r = e.children,
				    i = (0, u.default)(e, ["closeLabel", "closeButton", "onHide", "className", "children"]),
				    s = this.context.$bs_modal,
				    d = (0, _.splitBsProps)(i),
				    f = d[0],
				    c = d[1],
				    p = (0, _.getClassSet)(f);return y.default.createElement("div", (0, l.default)({}, c, { className: (0, m.default)(a, p) }), n && y.default.createElement(O.default, { label: t, onClick: (0, E.default)(s && s.onHide, o) }), r);
			}, t;
		}(y.default.Component);T.propTypes = S, T.defaultProps = N, T.contextTypes = M, t.default = (0, _.bsClass)("modal-header", T), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(10),
		    g = o(b),
		    _ = n(9),
		    C = { componentClass: g.default },
		    E = { componentClass: "h4" },
		    x = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.className,
				    o = (0, u.default)(e, ["componentClass", "className"]),
				    a = (0, _.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = (0, _.getClassSet)(r);return y.default.createElement(t, (0, l.default)({}, i, { className: (0, m.default)(n, s) }));
			}, t;
		}(y.default.Component);x.propTypes = C, x.defaultProps = E, t.default = (0, _.bsClass)("modal-title", x), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(77),
		    y = o(v),
		    b = n(1),
		    g = o(b),
		    _ = n(8),
		    C = o(_),
		    E = n(14),
		    x = o(E),
		    O = n(49),
		    S = o(O),
		    N = n(15),
		    M = (o(N), n(9)),
		    T = n(11),
		    w = o(T),
		    P = n(13),
		    k = o(P),
		    A = { activeKey: C.default.any, activeHref: C.default.string, stacked: C.default.bool, justified: (0, S.default)(C.default.bool, function (e) {
				var t = e.justified,
				    n = e.navbar;return t && n ? Error("justified navbar `Nav`s are not supported") : null;
			}), onSelect: C.default.func, role: C.default.string, navbar: C.default.bool, pullRight: C.default.bool, pullLeft: C.default.bool },
		    R = { justified: !1, pullRight: !1, pullLeft: !1, stacked: !1 },
		    I = { $bs_navbar: C.default.shape({ bsClass: C.default.string, onSelect: C.default.func }), $bs_tabContainer: C.default.shape({ activeKey: C.default.any, onSelect: C.default.func.isRequired, getTabId: C.default.func.isRequired, getPaneId: C.default.func.isRequired }) },
		    L = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.componentDidUpdate = function () {
				var e = this;if (this._needsRefocus) {
					this._needsRefocus = !1;var t = this.props.children,
					    n = this.getActiveProps(),
					    o = n.activeKey,
					    a = n.activeHref,
					    l = k.default.find(t, function (t) {
						return e.isActive(t, o, a);
					}),
					    r = k.default.toArray(t),
					    u = r.indexOf(l),
					    i = x.default.findDOMNode(this).children,
					    s = i && i[u];s && s.firstChild && s.firstChild.focus();
				}
			}, t.prototype.getActiveProps = function () {
				var e = this.context.$bs_tabContainer;return e ? e : this.props;
			}, t.prototype.getNextActiveChild = function (e) {
				var t = this,
				    n = this.props.children,
				    o = n.filter(function (e) {
					return null != e.props.eventKey && !e.props.disabled;
				}),
				    a = this.getActiveProps(),
				    l = a.activeKey,
				    r = a.activeHref,
				    u = k.default.find(n, function (e) {
					return t.isActive(e, l, r);
				}),
				    i = o.indexOf(u);if (i === -1) return o[0];var s = i + e,
				    d = o.length;return s >= d ? s = 0 : s < 0 && (s = d - 1), o[s];
			}, t.prototype.getTabProps = function (e, t, n, o, a) {
				var l = this;if (!t && "tablist" !== n) return null;var r = e.props,
				    u = r.id,
				    i = r["aria-controls"],
				    s = r.eventKey,
				    d = r.role,
				    f = r.onKeyDown,
				    c = r.tabIndex;return t && (u = t.getTabId(s), i = t.getPaneId(s)), "tablist" === n && (d = d || "tab", f = (0, w.default)(function (e) {
					return l.handleTabKeyDown(a, e);
				}, f), c = o ? c : -1), { id: u, role: d, onKeyDown: f, "aria-controls": i, tabIndex: c };
			}, t.prototype.handleTabKeyDown = function (e, t) {
				var n = void 0;switch (t.keyCode) {case y.default.codes.left:case y.default.codes.up:
						n = this.getNextActiveChild(-1);break;case y.default.codes.right:case y.default.codes.down:
						n = this.getNextActiveChild(1);break;default:
						return;}t.preventDefault(), e && n && null != n.props.eventKey && e(n.props.eventKey), this._needsRefocus = !0;
			}, t.prototype.isActive = function (e, t, n) {
				var o = e.props;return !!(o.active || null != t && o.eventKey === t || n && o.href === n) || o.active;
			}, t.prototype.render = function () {
				var e,
				    t = this,
				    n = this.props,
				    o = n.stacked,
				    a = n.justified,
				    r = n.onSelect,
				    i = n.role,
				    s = n.navbar,
				    d = n.pullRight,
				    f = n.pullLeft,
				    c = n.className,
				    p = n.children,
				    h = (0, u.default)(n, ["stacked", "justified", "onSelect", "role", "navbar", "pullRight", "pullLeft", "className", "children"]),
				    v = this.context.$bs_tabContainer,
				    y = i || (v ? "tablist" : null),
				    _ = this.getActiveProps(),
				    C = _.activeKey,
				    E = _.activeHref;delete h.activeKey, delete h.activeHref;var x = (0, M.splitBsProps)(h),
				    O = x[0],
				    S = x[1],
				    N = (0, l.default)({}, (0, M.getClassSet)(O), (e = {}, e[(0, M.prefix)(O, "stacked")] = o, e[(0, M.prefix)(O, "justified")] = a, e)),
				    T = null != s ? s : this.context.$bs_navbar,
				    P = void 0,
				    A = void 0;if (T) {
					var R = this.context.$bs_navbar || { bsClass: "navbar" };N[(0, M.prefix)(R, "nav")] = !0, A = (0, M.prefix)(R, "right"), P = (0, M.prefix)(R, "left");
				} else A = "pull-right", P = "pull-left";return N[A] = d, N[P] = f, g.default.createElement("ul", (0, l.default)({}, S, { role: y, className: (0, m.default)(c, N) }), k.default.map(p, function (e) {
					var n = t.isActive(e, C, E),
					    o = (0, w.default)(e.props.onSelect, r, T && T.onSelect, v && v.onSelect);return (0, b.cloneElement)(e, (0, l.default)({}, t.getTabProps(e, v, y, n, o), { active: n, activeKey: C, activeHref: E, onSelect: o }));
				}));
			}, t;
		}(g.default.Component);L.propTypes = A, L.defaultProps = R, L.contextTypes = I, t.default = (0, M.bsClass)("nav", (0, M.bsStyles)(["tabs", "pills"], L)), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(16),
		    C = o(_),
		    E = n(11),
		    x = o(E),
		    O = { active: g.default.bool, disabled: g.default.bool, role: g.default.string, href: g.default.string, onClick: g.default.func, onSelect: g.default.func, eventKey: g.default.any },
		    S = { active: !1, disabled: !1 },
		    N = function (e) {
			function t(n, o) {
				(0, s.default)(this, t);var a = (0, f.default)(this, e.call(this, n, o));return a.handleClick = a.handleClick.bind(a), a;
			}return (0, p.default)(t, e), t.prototype.handleClick = function (e) {
				this.props.onSelect && (e.preventDefault(), this.props.disabled || this.props.onSelect(this.props.eventKey, e));
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.active,
				    n = e.disabled,
				    o = e.onClick,
				    a = e.className,
				    r = e.style,
				    i = (0, u.default)(e, ["active", "disabled", "onClick", "className", "style"]);return delete i.onSelect, delete i.eventKey, delete i.activeKey, delete i.activeHref, i.role ? "tab" === i.role && (i["aria-selected"] = t) : "#" === i.href && (i.role = "button"), y.default.createElement("li", { role: "presentation", className: (0, m.default)(a, { active: t, disabled: n }), style: r }, y.default.createElement(C.default, (0, l.default)({}, i, { disabled: n, onClick: (0, x.default)(o, this.handleClick) })));
			}, t;
		}(y.default.Component);N.propTypes = O, N.defaultProps = S, t.default = N, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(9),
		    C = { $bs_navbar: g.default.shape({ bsClass: g.default.string }) },
		    E = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.className,
				    n = e.children,
				    o = (0, u.default)(e, ["className", "children"]),
				    a = this.context.$bs_navbar || { bsClass: "navbar" },
				    r = (0, _.prefix)(a, "brand");return y.default.isValidElement(n) ? y.default.cloneElement(n, { className: (0, m.default)(n.props.className, t, r) }) : y.default.createElement("span", (0, l.default)({}, o, { className: (0, m.default)(t, r) }), n);
			}, t;
		}(y.default.Component);E.contextTypes = C, t.default = E, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(6),
		    l = o(a),
		    r = n(2),
		    u = o(r),
		    i = n(4),
		    s = o(i),
		    d = n(3),
		    f = o(d),
		    c = n(5),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(257),
		    C = o(_),
		    E = n(10),
		    x = o(E),
		    O = n(41),
		    S = o(O),
		    N = (0, p.default)({}, C.default.propTypes, { show: g.default.bool, rootClose: g.default.bool, onHide: g.default.func, animation: g.default.oneOfType([g.default.bool, x.default]), onEnter: g.default.func, onEntering: g.default.func, onEntered: g.default.func, onExit: g.default.func, onExiting: g.default.func, onExited: g.default.func, placement: g.default.oneOf(["top", "right", "bottom", "left"]) }),
		    M = { animation: S.default, rootClose: !1, show: !1, placement: "right" },
		    T = function (e) {
			function t() {
				return (0, u.default)(this, t), (0, s.default)(this, e.apply(this, arguments));
			}return (0, f.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.animation,
				    n = e.children,
				    o = (0, l.default)(e, ["animation", "children"]),
				    a = t === !0 ? S.default : t || null,
				    r = void 0;return r = a ? n : (0, v.cloneElement)(n, { className: (0, m.default)(n.props.className, "in") }), y.default.createElement(C.default, (0, p.default)({}, o, { transition: a }), r);
			}, t;
		}(y.default.Component);T.propTypes = N, T.defaultProps = M, t.default = T, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(16),
		    C = o(_),
		    E = n(11),
		    x = o(E),
		    O = { disabled: g.default.bool, previous: g.default.bool, next: g.default.bool, onClick: g.default.func, onSelect: g.default.func, eventKey: g.default.any },
		    S = { disabled: !1, previous: !1, next: !1 },
		    N = function (e) {
			function t(n, o) {
				(0, s.default)(this, t);var a = (0, f.default)(this, e.call(this, n, o));return a.handleSelect = a.handleSelect.bind(a), a;
			}return (0, p.default)(t, e), t.prototype.handleSelect = function (e) {
				var t = this.props,
				    n = t.disabled,
				    o = t.onSelect,
				    a = t.eventKey;(o || n) && e.preventDefault(), n || o && o(a, e);
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.disabled,
				    n = e.previous,
				    o = e.next,
				    a = e.onClick,
				    r = e.className,
				    i = e.style,
				    s = (0, u.default)(e, ["disabled", "previous", "next", "onClick", "className", "style"]);return delete s.onSelect, delete s.eventKey, y.default.createElement("li", { className: (0, m.default)(r, { disabled: t, previous: n, next: o }), style: i }, y.default.createElement(C.default, (0, l.default)({}, s, { disabled: t, onClick: (0, x.default)(a, this.handleSelect) })));
			}, t;
		}(y.default.Component);N.propTypes = O, N.defaultProps = S, t.default = N, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(10),
		    C = o(_),
		    E = n(16),
		    x = o(E),
		    O = n(11),
		    S = o(O),
		    N = { componentClass: C.default, className: g.default.string, eventKey: g.default.any, onSelect: g.default.func, disabled: g.default.bool, active: g.default.bool, onClick: g.default.func },
		    M = { componentClass: x.default, active: !1, disabled: !1 },
		    T = function (e) {
			function t(n, o) {
				(0, s.default)(this, t);var a = (0, f.default)(this, e.call(this, n, o));return a.handleClick = a.handleClick.bind(a), a;
			}return (0, p.default)(t, e), t.prototype.handleClick = function (e) {
				var t = this.props,
				    n = t.disabled,
				    o = t.onSelect,
				    a = t.eventKey;n || o && o(a, e);
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.active,
				    o = e.disabled,
				    a = e.onClick,
				    r = e.className,
				    i = e.style,
				    s = (0, u.default)(e, ["componentClass", "active", "disabled", "onClick", "className", "style"]);return t === x.default && delete s.eventKey, delete s.onSelect, y.default.createElement("li", { className: (0, m.default)(r, { active: n, disabled: o }), style: i }, y.default.createElement(t, (0, l.default)({}, s, { disabled: o, onClick: (0, S.default)(a, this.handleClick) })));
			}, t;
		}(y.default.Component);T.propTypes = N, T.defaultProps = M, t.default = T, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(97),
		    u = o(r),
		    i = n(6),
		    s = o(i),
		    d = n(2),
		    f = o(d),
		    c = n(4),
		    p = o(c),
		    h = n(3),
		    m = o(h),
		    v = n(7),
		    y = o(v),
		    b = n(1),
		    g = o(b),
		    _ = n(8),
		    C = o(_),
		    E = n(9),
		    x = n(11),
		    O = o(x),
		    S = n(13),
		    N = o(S),
		    M = { accordion: C.default.bool, activeKey: C.default.any, defaultActiveKey: C.default.any, onSelect: C.default.func, role: C.default.string },
		    T = { accordion: !1 },
		    w = function (e) {
			function t(n, o) {
				(0, f.default)(this, t);var a = (0, p.default)(this, e.call(this, n, o));return a.handleSelect = a.handleSelect.bind(a), a.state = { activeKey: n.defaultActiveKey }, a;
			}return (0, m.default)(t, e), t.prototype.handleSelect = function (e, t) {
				t.preventDefault(), this.props.onSelect && this.props.onSelect(e, t), this.state.activeKey === e && (e = null), this.setState({ activeKey: e });
			}, t.prototype.render = function () {
				var e = this,
				    t = this.props,
				    n = t.accordion,
				    o = t.activeKey,
				    a = t.className,
				    r = t.children,
				    i = (0, s.default)(t, ["accordion", "activeKey", "className", "children"]),
				    d = (0, E.splitBsPropsAndOmit)(i, ["defaultActiveKey", "onSelect"]),
				    f = d[0],
				    c = d[1],
				    p = void 0;n && (p = null != o ? o : this.state.activeKey, c.role = c.role || "tablist");var h = (0, E.getClassSet)(f);return g.default.createElement("div", (0, l.default)({}, c, { className: (0, y.default)(a, h) }), N.default.map(r, function (t) {
					var o = { bsStyle: t.props.bsStyle || f.bsStyle };return n && (0, u.default)(o, { headerRole: "tab", panelRole: "tabpanel", collapsible: !0, expanded: t.props.eventKey === p, onSelect: (0, O.default)(e.handleSelect, t.props.onSelect) }), (0, b.cloneElement)(t, o);
				}));
			}, t;
		}(g.default.Component);w.propTypes = M, w.defaultProps = T, t.default = (0, E.bsClass)("panel-group", w), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(10),
		    C = o(_),
		    E = n(15),
		    x = (o(E), n(9)),
		    O = n(11),
		    S = o(O),
		    N = n(41),
		    M = o(N),
		    T = { eventKey: g.default.any, animation: g.default.oneOfType([g.default.bool, C.default]), id: g.default.string, "aria-labelledby": g.default.string, bsClass: g.default.string, onEnter: g.default.func, onEntering: g.default.func, onEntered: g.default.func, onExit: g.default.func, onExiting: g.default.func, onExited: g.default.func, mountOnEnter: g.default.bool, unmountOnExit: g.default.bool },
		    w = { $bs_tabContainer: g.default.shape({ getTabId: g.default.func, getPaneId: g.default.func }), $bs_tabContent: g.default.shape({ bsClass: g.default.string, animation: g.default.oneOfType([g.default.bool, C.default]), activeKey: g.default.any, mountOnEnter: g.default.bool, unmountOnExit: g.default.bool, onPaneEnter: g.default.func.isRequired, onPaneExited: g.default.func.isRequired, exiting: g.default.bool.isRequired }) },
		    P = { $bs_tabContainer: g.default.oneOf([null]) },
		    k = function (e) {
			function t(n, o) {
				(0, s.default)(this, t);var a = (0, f.default)(this, e.call(this, n, o));return a.handleEnter = a.handleEnter.bind(a), a.handleExited = a.handleExited.bind(a), a.in = !1, a;
			}return (0, p.default)(t, e), t.prototype.getChildContext = function () {
				return { $bs_tabContainer: null };
			}, t.prototype.componentDidMount = function () {
				this.shouldBeIn() && this.handleEnter();
			}, t.prototype.componentDidUpdate = function () {
				this.in ? this.shouldBeIn() || this.handleExited() : this.shouldBeIn() && this.handleEnter();
			}, t.prototype.componentWillUnmount = function () {
				this.in && this.handleExited();
			}, t.prototype.getAnimation = function () {
				if (null != this.props.animation) return this.props.animation;var e = this.context.$bs_tabContent;return e && e.animation;
			}, t.prototype.handleEnter = function () {
				var e = this.context.$bs_tabContent;e && (this.in = e.onPaneEnter(this, this.props.eventKey));
			}, t.prototype.handleExited = function () {
				var e = this.context.$bs_tabContent;e && (e.onPaneExited(this), this.in = !1);
			}, t.prototype.isActive = function () {
				var e = this.context.$bs_tabContent,
				    t = e && e.activeKey;return this.props.eventKey === t;
			}, t.prototype.shouldBeIn = function () {
				return this.getAnimation() && this.isActive();
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.eventKey,
				    n = e.className,
				    o = e.onEnter,
				    a = e.onEntering,
				    r = e.onEntered,
				    i = e.onExit,
				    s = e.onExiting,
				    d = e.onExited,
				    f = e.mountOnEnter,
				    c = e.unmountOnExit,
				    p = (0, u.default)(e, ["eventKey", "className", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "mountOnEnter", "unmountOnExit"]),
				    h = this.context,
				    v = h.$bs_tabContent,
				    b = h.$bs_tabContainer,
				    g = (0, x.splitBsPropsAndOmit)(p, ["animation"]),
				    _ = g[0],
				    C = g[1],
				    E = this.isActive(),
				    O = this.getAnimation(),
				    N = null != f ? f : v && v.mountOnEnter,
				    T = null != c ? c : v && v.unmountOnExit;if (!E && !O && T) return null;var w = O === !0 ? M.default : O || null;v && (_.bsClass = (0, x.prefix)(v, "pane"));var P = (0, l.default)({}, (0, x.getClassSet)(_), { active: E });b && (C.id = b.getPaneId(t), C["aria-labelledby"] = b.getTabId(t));var k = y.default.createElement("div", (0, l.default)({}, C, { role: "tabpanel", "aria-hidden": !E, className: (0, m.default)(n, P) }));if (w) {
					var A = v && v.exiting;return y.default.createElement(w, { in: E && !A, onEnter: (0, S.default)(this.handleEnter, o), onEntering: a, onEntered: r, onExit: i, onExiting: s, onExited: (0, S.default)(this.handleExited, d), mountOnEnter: N, unmountOnExit: T }, k);
				}return k;
			}, t;
		}(y.default.Component);k.propTypes = T, k.contextTypes = w, k.childContextTypes = P, t.default = (0, x.bsClass)("tab-pane", k), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(8),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(32),
		    g = o(b),
		    _ = { type: m.default.oneOf(["checkbox", "radio"]), name: m.default.string, checked: m.default.bool, disabled: m.default.bool, onChange: m.default.func, value: m.default.any.isRequired },
		    C = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.children,
				    n = e.name,
				    o = e.checked,
				    a = e.type,
				    r = e.onChange,
				    i = e.value,
				    s = (0, u.default)(e, ["children", "name", "checked", "type", "onChange", "value"]),
				    d = s.disabled;return y.default.createElement(g.default, (0, l.default)({}, s, { active: !!o, componentClass: "label" }), y.default.createElement("input", { name: n, type: a, autoComplete: "off", value: i, checked: !!o, disabled: !!d, onChange: r }), t);
			}, t;
		}(y.default.Component);C.propTypes = _, t.default = C, e.exports = t.default;
	}, function (e, t) {
		"use strict";
		function n(e) {
			return "" + e.charAt(0).toUpperCase() + e.slice(1);
		}t.__esModule = !0, t.default = n, e.exports = t.default;
	}, function (e, t, n) {
		e.exports = { default: n(192), __esModule: !0 };
	}, function (e, t, n) {
		e.exports = { default: n(194), __esModule: !0 };
	}, function (e, t, n) {
		var o = n(34),
		    a = n(20).document,
		    l = o(a) && o(a.createElement);e.exports = function (e) {
			return l ? a.createElement(e) : {};
		};
	}, function (e, t, n) {
		e.exports = !n(27) && !n(33)(function () {
			return 7 != Object.defineProperty(n(99)("div"), "a", { get: function get() {
					return 7;
				} }).a;
		});
	}, function (e, t, n) {
		var o = n(61);e.exports = Object("z").propertyIsEnumerable(0) ? Object : function (e) {
			return "String" == o(e) ? e.split("") : Object(e);
		};
	}, function (e, t, n) {
		"use strict";
		var o = n(65),
		    a = n(19),
		    l = n(107),
		    r = n(28),
		    u = n(22),
		    i = n(35),
		    s = n(209),
		    d = n(68),
		    f = n(216),
		    c = n(18)("iterator"),
		    p = !([].keys && "next" in [].keys()),
		    h = "@@iterator",
		    m = "keys",
		    v = "values",
		    y = function y() {
			return this;
		};e.exports = function (e, t, n, b, g, _, C) {
			s(n, t, b);var E,
			    x,
			    O,
			    S = function S(e) {
				if (!p && e in w) return w[e];switch (e) {case m:
						return function () {
							return new n(this, e);
						};case v:
						return function () {
							return new n(this, e);
						};}return function () {
					return new n(this, e);
				};
			},
			    N = t + " Iterator",
			    M = g == v,
			    T = !1,
			    w = e.prototype,
			    P = w[c] || w[h] || g && w[g],
			    k = P || S(g),
			    A = g ? M ? S("entries") : k : void 0,
			    R = "Array" == t ? w.entries || P : P;if (R && (O = f(R.call(new e())), O !== Object.prototype && O.next && (d(O, N, !0), o || u(O, c) || r(O, c, y))), M && P && P.name !== v && (T = !0, k = function k() {
				return P.call(this);
			}), o && !C || !p && !T && w[c] || r(w, c, k), i[t] = k, i[N] = y, g) if (E = { values: M ? k : S(v), keys: _ ? k : S(m), entries: A }, C) for (x in E) {
				x in w || l(w, x, E[x]);
			} else a(a.P + a.F * (p || T), t, E);return E;
		};
	}, function (e, t, n) {
		var o = n(37),
		    a = n(38),
		    l = n(24),
		    r = n(73),
		    u = n(22),
		    i = n(100),
		    s = Object.getOwnPropertyDescriptor;t.f = n(27) ? s : function (e, t) {
			if (e = l(e), t = r(t, !0), i) try {
				return s(e, t);
			} catch (e) {}if (u(e, t)) return a(!o.f.call(e, t), e[t]);
		};
	}, function (e, t, n) {
		var o = n(105),
		    a = n(64).concat("length", "prototype");t.f = Object.getOwnPropertyNames || function (e) {
			return o(e, a);
		};
	}, function (e, t, n) {
		var o = n(22),
		    a = n(24),
		    l = n(201)(!1),
		    r = n(69)("IE_PROTO");e.exports = function (e, t) {
			var n,
			    u = a(e),
			    i = 0,
			    s = [];for (n in u) {
				n != r && o(u, n) && s.push(n);
			}for (; t.length > i;) {
				o(u, n = t[i++]) && (~l(s, n) || s.push(n));
			}return s;
		};
	}, function (e, t, n) {
		var o = n(36),
		    a = n(24),
		    l = n(37).f;e.exports = function (e) {
			return function (t) {
				for (var n, r = a(t), u = o(r), i = u.length, s = 0, d = []; i > s;) {
					l.call(r, n = u[s++]) && d.push(e ? [n, r[n]] : r[n]);
				}return d;
			};
		};
	}, function (e, t, n) {
		e.exports = n(28);
	}, function (e, t, n) {
		var o = n(71),
		    a = Math.min;e.exports = function (e) {
			return e > 0 ? a(o(e), 9007199254740991) : 0;
		};
	}, function (e, t, n) {
		"use strict";
		var o = n(218)(!0);n(102)(String, "String", function (e) {
			this._t = String(e), this._i = 0;
		}, function () {
			var e,
			    t = this._t,
			    n = this._i;return n >= t.length ? { value: void 0, done: !0 } : (e = o(t, n), this._i += e.length, { value: e, done: !1 });
		});
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a() {
			var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : (0, r.default)();try {
				return e.activeElement;
			} catch (e) {}
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;var l = n(29),
		    r = o(l);e.exports = t.default;
	}, function (e, t) {
		"use strict";
		function n(e, t) {
			return e.classList ? !!t && e.classList.contains(t) : (" " + e.className + " ").indexOf(" " + t + " ") !== -1;
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = n, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e) {
			var t = (0, d.default)(e),
			    n = (0, i.default)(t),
			    o = t && t.documentElement,
			    a = { top: 0, left: 0, height: 0, width: 0 };if (t) return (0, r.default)(o, e) ? (void 0 !== e.getBoundingClientRect && (a = e.getBoundingClientRect()), a = { top: a.top + (n.pageYOffset || o.scrollTop) - (o.clientTop || 0), left: a.left + (n.pageXOffset || o.scrollLeft) - (o.clientLeft || 0), width: (null == a.width ? e.offsetWidth : a.width) || 0, height: (null == a.height ? e.offsetHeight : a.height) || 0 }) : a;
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;var l = n(30),
		    r = o(l),
		    u = n(46),
		    i = o(u),
		    s = n(29),
		    d = o(s);e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			var n = (0, r.default)(e);return void 0 === t ? n ? "pageYOffset" in n ? n.pageYOffset : n.document.documentElement.scrollTop : e.scrollTop : void (n ? n.scrollTo("pageXOffset" in n ? n.pageXOffset : n.document.documentElement.scrollLeft, t) : e.scrollTop = t);
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;var l = n(46),
		    r = o(l);e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a() {
			for (var e = document.createElement("div").style, t = { O: function O(e) {
					return "o" + e.toLowerCase();
				}, Moz: function Moz(e) {
					return e.toLowerCase();
				}, Webkit: function Webkit(e) {
					return "webkit" + e;
				}, ms: function ms(e) {
					return "MS" + e;
				} }, n = Object.keys(t), o = void 0, a = void 0, l = "", r = 0; r < n.length; r++) {
				var u = n[r];if (u + "TransitionProperty" in e) {
					l = "-" + u.toLowerCase(), o = t[u]("TransitionEnd"), a = t[u]("AnimationEnd");break;
				}
			}return !o && "transitionProperty" in e && (o = "transitionend"), !a && "animationName" in e && (a = "animationend"), e = null, { animationEnd: a, transitionEnd: o, prefix: l };
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.animationEnd = t.animationDelay = t.animationTiming = t.animationDuration = t.animationName = t.transitionEnd = t.transitionDuration = t.transitionDelay = t.transitionTiming = t.transitionProperty = t.transform = void 0;var l = n(21),
		    r = o(l),
		    u = "transform",
		    i = void 0,
		    s = void 0,
		    d = void 0,
		    f = void 0,
		    c = void 0,
		    p = void 0,
		    h = void 0,
		    m = void 0,
		    v = void 0,
		    y = void 0,
		    b = void 0;if (r.default) {
			var g = a();i = g.prefix, t.transitionEnd = s = g.transitionEnd, t.animationEnd = d = g.animationEnd, t.transform = u = i + "-" + u, t.transitionProperty = f = i + "-transition-property", t.transitionDuration = c = i + "-transition-duration", t.transitionDelay = h = i + "-transition-delay", t.transitionTiming = p = i + "-transition-timing-function", t.animationName = m = i + "-animation-name", t.animationDuration = v = i + "-animation-duration", t.animationTiming = y = i + "-animation-delay", t.animationDelay = b = i + "-animation-timing-function";
		}t.transform = u, t.transitionProperty = f, t.transitionTiming = p, t.transitionDelay = h, t.transitionDuration = c, t.transitionEnd = s, t.animationName = m, t.animationDuration = v, t.animationTiming = y, t.animationDelay = b, t.animationEnd = d, t.default = { transform: u, end: s, property: f, timing: p, delay: h, duration: c };
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e) {
			return (0, r.default)(e.replace(u, "ms-"));
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;var l = n(246),
		    r = o(l),
		    u = /^-ms-/;e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e) {
			if ((!r || e) && l.default) {
				var t = document.createElement("div");t.style.position = "absolute", t.style.top = "-9999px", t.style.width = "50px", t.style.height = "50px", t.style.overflow = "scroll", document.body.appendChild(t), r = t.offsetWidth - t.clientWidth, document.body.removeChild(t);
			}return r;
		};var a = n(21),
		    l = o(a),
		    r = void 0;e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
		}function l(e, t) {
			if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
		}function r(e, t) {
			if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
		}t.__esModule = !0;var u = n(8),
		    i = o(u),
		    s = n(50),
		    d = o(s),
		    f = n(1),
		    c = o(f),
		    p = n(14),
		    h = o(p),
		    m = n(53),
		    v = o(m),
		    y = n(31),
		    b = o(y),
		    g = n(254),
		    _ = o(g),
		    C = function (e) {
			function t() {
				var n, o, r;a(this, t);for (var u = arguments.length, i = Array(u), s = 0; s < u; s++) {
					i[s] = arguments[s];
				}return n = o = l(this, e.call.apply(e, [this].concat(i))), o.setContainer = function () {
					var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o.props;o._portalContainerNode = (0, v.default)(e.container, (0, b.default)(o).body);
				}, o.getMountNode = function () {
					return o._portalContainerNode;
				}, r = n, l(o, r);
			}return r(t, e), t.prototype.componentDidMount = function () {
				this.setContainer(), this.forceUpdate(this.props.onRendered);
			}, t.prototype.componentWillReceiveProps = function (e) {
				e.container !== this.props.container && this.setContainer(e);
			}, t.prototype.componentWillUnmount = function () {
				this._portalContainerNode = null;
			}, t.prototype.render = function () {
				return this.props.children && this._portalContainerNode ? h.default.createPortal(this.props.children, this._portalContainerNode) : null;
			}, t;
		}(c.default.Component);C.displayName = "Portal", C.propTypes = { container: i.default.oneOfType([d.default, i.default.func]), onRendered: i.default.func }, t.default = h.default.createPortal ? C : _.default, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
		}function l(e, t) {
			if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
		}function r(e, t) {
			if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
		}function u(e) {
			return 0 === e.button;
		}function i(e) {
			return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
		}t.__esModule = !0;var s = n(30),
		    d = o(s),
		    f = n(8),
		    c = o(f),
		    p = n(1),
		    h = o(p),
		    m = n(14),
		    v = o(m),
		    y = n(120),
		    b = o(y),
		    g = n(31),
		    _ = o(g),
		    C = 27,
		    E = function (e) {
			function t(n, o) {
				a(this, t);var r = l(this, e.call(this, n, o));return r.addEventListeners = function () {
					var e = r.props.event,
					    t = (0, _.default)(r);r.documentMouseCaptureListener = (0, b.default)(t, e, r.handleMouseCapture, !0), r.documentMouseListener = (0, b.default)(t, e, r.handleMouse), r.documentKeyupListener = (0, b.default)(t, "keyup", r.handleKeyUp);
				}, r.removeEventListeners = function () {
					r.documentMouseCaptureListener && r.documentMouseCaptureListener.remove(), r.documentMouseListener && r.documentMouseListener.remove(), r.documentKeyupListener && r.documentKeyupListener.remove();
				}, r.handleMouseCapture = function (e) {
					r.preventMouseRootClose = i(e) || !u(e) || (0, d.default)(v.default.findDOMNode(r), e.target);
				}, r.handleMouse = function (e) {
					!r.preventMouseRootClose && r.props.onRootClose && r.props.onRootClose(e);
				}, r.handleKeyUp = function (e) {
					e.keyCode === C && r.props.onRootClose && r.props.onRootClose(e);
				}, r.preventMouseRootClose = !1, r;
			}return r(t, e), t.prototype.componentDidMount = function () {
				this.props.disabled || this.addEventListeners();
			}, t.prototype.componentDidUpdate = function (e) {
				!this.props.disabled && e.disabled ? this.addEventListeners() : this.props.disabled && !e.disabled && this.removeEventListeners();
			}, t.prototype.componentWillUnmount = function () {
				this.props.disabled || this.removeEventListeners();
			}, t.prototype.render = function () {
				return this.props.children;
			}, t;
		}(h.default.Component);E.displayName = "RootCloseWrapper", E.propTypes = { onRootClose: c.default.func, children: c.default.element, disabled: c.default.bool, event: c.default.oneOf(["click", "mousedown"]) }, E.defaultProps = { event: "click" }, t.default = E, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			var n = {};for (var o in e) {
				t.indexOf(o) >= 0 || Object.prototype.hasOwnProperty.call(e, o) && (n[o] = e[o]);
			}return n;
		}function l(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
		}function r(e, t) {
			if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
		}function u(e, t) {
			if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
		}function i() {}t.__esModule = !0, t.EXITING = t.ENTERED = t.ENTERING = t.EXITED = t.UNMOUNTED = void 0;var s = Object.assign || function (e) {
			for (var t = 1; t < arguments.length; t++) {
				var n = arguments[t];for (var o in n) {
					Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
				}
			}return e;
		},
		    d = n(7),
		    f = o(d),
		    c = n(45),
		    p = o(c),
		    h = n(114),
		    m = o(h),
		    v = n(8),
		    y = o(v),
		    b = n(1),
		    g = o(b),
		    _ = n(14),
		    C = o(_),
		    E = m.default.end,
		    x = t.UNMOUNTED = 0,
		    O = t.EXITED = 1,
		    S = t.ENTERING = 2,
		    N = t.ENTERED = 3,
		    M = t.EXITING = 4,
		    T = function (e) {
			function t(n, o) {
				l(this, t);var a = r(this, e.call(this, n, o));a.updateStatus = function () {
					if (null !== a.nextStatus) {
						a.cancelNextCallback();var e = C.default.findDOMNode(a);a.nextStatus === S ? (a.props.onEnter(e), a.safeSetState({ status: S }, function () {
							a.props.onEntering(e), a.onTransitionEnd(e, function () {
								a.safeSetState({ status: N }, function () {
									a.props.onEntered(e);
								});
							});
						})) : (a.props.onExit(e), a.safeSetState({ status: M }, function () {
							a.props.onExiting(e), a.onTransitionEnd(e, function () {
								a.safeSetState({ status: O }, function () {
									a.props.onExited(e);
								});
							});
						})), a.nextStatus = null;
					} else a.props.unmountOnExit && a.state.status === O && a.setState({ status: x });
				}, a.cancelNextCallback = function () {
					null !== a.nextCallback && (a.nextCallback.cancel(), a.nextCallback = null);
				}, a.safeSetState = function (e, t) {
					a.setState(e, a.setNextCallback(t));
				}, a.setNextCallback = function (e) {
					var t = !0;return a.nextCallback = function (n) {
						t && (t = !1, a.nextCallback = null, e(n));
					}, a.nextCallback.cancel = function () {
						t = !1;
					}, a.nextCallback;
				}, a.onTransitionEnd = function (e, t) {
					a.setNextCallback(t), e ? ((0, p.default)(e, E, a.nextCallback), setTimeout(a.nextCallback, a.props.timeout)) : setTimeout(a.nextCallback, 0);
				};var u = void 0;return a.nextStatus = null, n.in ? n.transitionAppear ? (u = O, a.nextStatus = S) : u = N : u = n.unmountOnExit || n.mountOnEnter ? x : O, a.state = { status: u }, a.nextCallback = null, a;
			}return u(t, e), t.prototype.componentDidMount = function () {
				this.updateStatus();
			}, t.prototype.componentWillReceiveProps = function (e) {
				var t = this.state.status;e.in ? (t === x && this.setState({ status: O }), t !== S && t !== N && (this.nextStatus = S)) : t !== S && t !== N || (this.nextStatus = M);
			}, t.prototype.componentDidUpdate = function () {
				this.updateStatus();
			}, t.prototype.componentWillUnmount = function () {
				this.cancelNextCallback();
			}, t.prototype.render = function () {
				var e = this.state.status;if (e === x) return null;var n = this.props,
				    o = n.children,
				    l = n.className,
				    r = a(n, ["children", "className"]);Object.keys(t.propTypes).forEach(function (e) {
					return delete r[e];
				});var u = void 0;e === O ? u = this.props.exitedClassName : e === S ? u = this.props.enteringClassName : e === N ? u = this.props.enteredClassName : e === M && (u = this.props.exitingClassName);var i = g.default.Children.only(o);return g.default.cloneElement(i, s({}, r, { className: (0, f.default)(i.props.className, l, u) }));
			}, t;
		}(g.default.Component);T.propTypes = { in: y.default.bool, mountOnEnter: y.default.bool, unmountOnExit: y.default.bool, transitionAppear: y.default.bool, timeout: y.default.number, exitedClassName: y.default.string, exitingClassName: y.default.string, enteredClassName: y.default.string, enteringClassName: y.default.string, onEnter: y.default.func, onEntering: y.default.func, onEntered: y.default.func, onExit: y.default.func, onExiting: y.default.func, onExited: y.default.func }, T.displayName = "Transition", T.defaultProps = { in: !1, unmountOnExit: !1, transitionAppear: !1, timeout: 5e3, onEnter: i, onEntering: i, onEntered: i, onExit: i, onExiting: i, onExited: i }, t.default = T;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0, t.default = function (e, t, n, o) {
			return (0, l.default)(e, t, n, o), { remove: function remove() {
					(0, u.default)(e, t, n, o);
				} };
		};var a = n(45),
		    l = o(a),
		    r = n(76),
		    u = o(r);e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e) {
			return e && "body" === e.tagName.toLowerCase();
		}function l(e) {
			var t = (0, d.default)(e),
			    n = (0, i.default)(t),
			    o = n.innerWidth;if (!o) {
				var a = t.documentElement.getBoundingClientRect();o = a.right - Math.abs(a.left);
			}return t.body.clientWidth < o;
		}function r(e) {
			var t = (0, i.default)(e);return t || a(e) ? l(e) : e.scrollHeight > e.clientHeight;
		}t.__esModule = !0, t.default = r;var u = n(46),
		    i = o(u),
		    s = n(29),
		    d = o(s);e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(2),
		    u = o(r),
		    i = n(4),
		    s = o(i),
		    d = n(3),
		    f = o(d),
		    c = n(1),
		    p = o(c),
		    h = n(93),
		    m = o(h),
		    v = function (e) {
			function t() {
				return (0, u.default)(this, t), (0, s.default)(this, e.apply(this, arguments));
			}return (0, f.default)(t, e), t.prototype.render = function () {
				return p.default.createElement(m.default, (0, l.default)({}, this.props, { accordion: !0 }), this.props.children);
			}, t;
		}(p.default.Component);t.default = v, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(25),
		    l = o(a),
		    r = n(5),
		    u = o(r),
		    i = n(6),
		    s = o(i),
		    d = n(2),
		    f = o(d),
		    c = n(4),
		    p = o(c),
		    h = n(3),
		    m = o(h),
		    v = n(7),
		    y = o(v),
		    b = n(1),
		    g = o(b),
		    _ = n(8),
		    C = o(_),
		    E = n(9),
		    x = n(12),
		    O = n(55),
		    S = o(O),
		    N = { onDismiss: C.default.func, closeLabel: C.default.string },
		    M = { closeLabel: "Close alert" },
		    T = function (e) {
			function t() {
				return (0, f.default)(this, t), (0, p.default)(this, e.apply(this, arguments));
			}return (0, m.default)(t, e), t.prototype.render = function () {
				var e,
				    t = this.props,
				    n = t.onDismiss,
				    o = t.closeLabel,
				    a = t.className,
				    l = t.children,
				    r = (0, s.default)(t, ["onDismiss", "closeLabel", "className", "children"]),
				    i = (0, E.splitBsProps)(r),
				    d = i[0],
				    f = i[1],
				    c = !!n,
				    p = (0, u.default)({}, (0, E.getClassSet)(d), (e = {}, e[(0, E.prefix)(d, "dismissable")] = c, e));return g.default.createElement("div", (0, u.default)({}, f, { role: "alert", className: (0, y.default)(a, p) }), c && g.default.createElement(S.default, { onClick: n, label: o }), l);
			}, t;
		}(g.default.Component);T.propTypes = N, T.defaultProps = M, t.default = (0, E.bsStyles)((0, l.default)(x.State), x.State.INFO, (0, E.bsClass)("alert", T)), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(9),
		    C = { pullRight: g.default.bool },
		    E = { pullRight: !1 },
		    x = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.hasContent = function (e) {
				var t = !1;return y.default.Children.forEach(e, function (e) {
					t || (e || 0 === e) && (t = !0);
				}), t;
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.pullRight,
				    n = e.className,
				    o = e.children,
				    a = (0, u.default)(e, ["pullRight", "className", "children"]),
				    r = (0, _.splitBsProps)(a),
				    i = r[0],
				    s = r[1],
				    d = (0, l.default)({}, (0, _.getClassSet)(i), { "pull-right": t, hidden: !this.hasContent(o) });return y.default.createElement("span", (0, l.default)({}, s, { className: (0, m.default)(n, d) }), o);
			}, t;
		}(y.default.Component);x.propTypes = C, x.defaultProps = E, t.default = (0, _.bsClass)("badge", x), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(78),
		    g = o(b),
		    _ = n(9),
		    C = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.className,
				    n = (0, u.default)(e, ["className"]),
				    o = (0, _.splitBsProps)(n),
				    a = o[0],
				    r = o[1],
				    i = (0, _.getClassSet)(a);return y.default.createElement("ol", (0, l.default)({}, r, { role: "navigation", "aria-label": "breadcrumbs", className: (0, m.default)(t, i) }));
			}, t;
		}(y.default.Component);C.Item = g.default, t.default = (0, _.bsClass)("breadcrumb", C), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(9),
		    g = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.className,
				    n = (0, u.default)(e, ["className"]),
				    o = (0, b.splitBsProps)(n),
				    a = o[0],
				    r = o[1],
				    i = (0, b.getClassSet)(a);return y.default.createElement("div", (0, l.default)({}, r, { role: "toolbar", className: (0, m.default)(t, i) }));
			}, t;
		}(y.default.Component);t.default = (0, b.bsClass)("btn-toolbar", g), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(128),
		    C = o(_),
		    E = n(79),
		    x = o(E),
		    O = n(57),
		    S = o(O),
		    N = n(16),
		    M = o(N),
		    T = n(9),
		    w = n(13),
		    P = o(w),
		    k = { slide: g.default.bool, indicators: g.default.bool, interval: g.default.number, controls: g.default.bool, pauseOnHover: g.default.bool, wrap: g.default.bool, onSelect: g.default.func, onSlideEnd: g.default.func, activeIndex: g.default.number, defaultActiveIndex: g.default.number, direction: g.default.oneOf(["prev", "next"]), prevIcon: g.default.node, prevLabel: g.default.string, nextIcon: g.default.node, nextLabel: g.default.string },
		    A = { slide: !0, interval: 5e3, pauseOnHover: !0, wrap: !0, indicators: !0, controls: !0, prevIcon: y.default.createElement(S.default, { glyph: "chevron-left" }), prevLabel: "Previous", nextIcon: y.default.createElement(S.default, { glyph: "chevron-right" }), nextLabel: "Next" },
		    R = function (e) {
			function t(n, o) {
				(0, s.default)(this, t);var a = (0, f.default)(this, e.call(this, n, o));a.handleMouseOver = a.handleMouseOver.bind(a), a.handleMouseOut = a.handleMouseOut.bind(a), a.handlePrev = a.handlePrev.bind(a), a.handleNext = a.handleNext.bind(a), a.handleItemAnimateOutEnd = a.handleItemAnimateOutEnd.bind(a);var l = n.defaultActiveIndex;return a.state = { activeIndex: null != l ? l : 0, previousActiveIndex: null, direction: null }, a.isUnmounted = !1, a;
			}return (0, p.default)(t, e), t.prototype.componentDidMount = function () {
				this.waitForNext();
			}, t.prototype.componentWillReceiveProps = function (e) {
				var t = this.getActiveIndex();null != e.activeIndex && e.activeIndex !== t && (clearTimeout(this.timeout), this.setState({ previousActiveIndex: t, direction: null != e.direction ? e.direction : this.getDirection(t, e.activeIndex) })), null == e.activeIndex && this.state.activeIndex >= e.children.length && this.setState({ activeIndex: 0, previousActiveIndex: null, direction: null });
			}, t.prototype.componentWillUnmount = function () {
				clearTimeout(this.timeout), this.isUnmounted = !0;
			}, t.prototype.getActiveIndex = function () {
				var e = this.props.activeIndex;return null != e ? e : this.state.activeIndex;
			}, t.prototype.getDirection = function (e, t) {
				return e === t ? null : e > t ? "prev" : "next";
			}, t.prototype.handleItemAnimateOutEnd = function () {
				var e = this;this.setState({ previousActiveIndex: null, direction: null }, function () {
					e.waitForNext(), e.props.onSlideEnd && e.props.onSlideEnd();
				});
			}, t.prototype.handleMouseOut = function () {
				this.isPaused && this.play();
			}, t.prototype.handleMouseOver = function () {
				this.props.pauseOnHover && this.pause();
			}, t.prototype.handleNext = function (e) {
				var t = this.getActiveIndex() + 1,
				    n = P.default.count(this.props.children);if (t > n - 1) {
					if (!this.props.wrap) return;t = 0;
				}this.select(t, e, "next");
			}, t.prototype.handlePrev = function (e) {
				var t = this.getActiveIndex() - 1;if (t < 0) {
					if (!this.props.wrap) return;t = P.default.count(this.props.children) - 1;
				}this.select(t, e, "prev");
			}, t.prototype.pause = function () {
				this.isPaused = !0, clearTimeout(this.timeout);
			}, t.prototype.play = function () {
				this.isPaused = !1, this.waitForNext();
			}, t.prototype.select = function (e, t, n) {
				if (clearTimeout(this.timeout), !this.isUnmounted) {
					var o = this.props.slide ? this.getActiveIndex() : null;n = n || this.getDirection(o, e);var a = this.props.onSelect;if (a && (a.length > 1 ? (t ? (t.persist(), t.direction = n) : t = { direction: n }, a(e, t)) : a(e)), null == this.props.activeIndex && e !== o) {
						if (null != this.state.previousActiveIndex) return;this.setState({ activeIndex: e, previousActiveIndex: o, direction: n });
					}
				}
			}, t.prototype.waitForNext = function () {
				var e = this.props,
				    t = e.slide,
				    n = e.interval,
				    o = e.activeIndex;!this.isPaused && t && n && null == o && (this.timeout = setTimeout(this.handleNext, n));
			}, t.prototype.renderControls = function (e) {
				var t = e.wrap,
				    n = e.children,
				    o = e.activeIndex,
				    a = e.prevIcon,
				    l = e.nextIcon,
				    r = e.bsProps,
				    u = e.prevLabel,
				    i = e.nextLabel,
				    s = (0, T.prefix)(r, "control"),
				    d = P.default.count(n);return [(t || 0 !== o) && y.default.createElement(M.default, { key: "prev", className: (0, m.default)(s, "left"), onClick: this.handlePrev }, a, u && y.default.createElement("span", { className: "sr-only" }, u)), (t || o !== d - 1) && y.default.createElement(M.default, { key: "next", className: (0, m.default)(s, "right"), onClick: this.handleNext }, l, i && y.default.createElement("span", { className: "sr-only" }, i))];
			}, t.prototype.renderIndicators = function (e, t, n) {
				var o = this,
				    a = [];return P.default.forEach(e, function (e, n) {
					a.push(y.default.createElement("li", { key: n, className: n === t ? "active" : null, onClick: function onClick(e) {
							return o.select(n, e);
						} }), " ");
				}), y.default.createElement("ol", { className: (0, T.prefix)(n, "indicators") }, a);
			}, t.prototype.render = function () {
				var e = this,
				    t = this.props,
				    n = t.slide,
				    o = t.indicators,
				    a = t.controls,
				    r = t.wrap,
				    i = t.prevIcon,
				    s = t.prevLabel,
				    d = t.nextIcon,
				    f = t.nextLabel,
				    c = t.className,
				    p = t.children,
				    h = (0, u.default)(t, ["slide", "indicators", "controls", "wrap", "prevIcon", "prevLabel", "nextIcon", "nextLabel", "className", "children"]),
				    b = this.state,
				    g = b.previousActiveIndex,
				    _ = b.direction,
				    C = (0, T.splitBsPropsAndOmit)(h, ["interval", "pauseOnHover", "onSelect", "onSlideEnd", "activeIndex", "defaultActiveIndex", "direction"]),
				    E = C[0],
				    x = C[1],
				    O = this.getActiveIndex(),
				    S = (0, l.default)({}, (0, T.getClassSet)(E), { slide: n });return y.default.createElement("div", (0, l.default)({}, x, { className: (0, m.default)(c, S), onMouseOver: this.handleMouseOver, onMouseOut: this.handleMouseOut }), o && this.renderIndicators(p, O, E), y.default.createElement("div", { className: (0, T.prefix)(E, "inner") }, P.default.map(p, function (t, o) {
					var a = o === O,
					    l = n && o === g;return (0, v.cloneElement)(t, { active: a, index: o, animateOut: l, animateIn: a && null != g && n, direction: _, onAnimateOutEnd: l ? e.handleItemAnimateOutEnd : null });
				})), a && this.renderControls({ wrap: r, children: p, activeIndex: O, prevIcon: i, prevLabel: s, nextIcon: d, nextLabel: f, bsProps: E }));
			}, t;
		}(y.default.Component);R.propTypes = k, R.defaultProps = A, R.Caption = C.default, R.Item = x.default, t.default = (0, T.bsClass)("carousel", R), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(10),
		    g = o(b),
		    _ = n(9),
		    C = { componentClass: g.default },
		    E = { componentClass: "div" },
		    x = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.className,
				    o = (0, u.default)(e, ["componentClass", "className"]),
				    a = (0, _.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = (0, _.getClassSet)(r);return y.default.createElement(t, (0, l.default)({}, i, { className: (0, m.default)(n, s) }));
			}, t;
		}(y.default.Component);x.propTypes = C, x.defaultProps = E, t.default = (0, _.bsClass)("carousel-caption", x), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(15),
		    C = (o(_), n(9)),
		    E = { inline: g.default.bool, disabled: g.default.bool, title: g.default.string, validationState: g.default.oneOf(["success", "warning", "error", null]), inputRef: g.default.func },
		    x = { inline: !1, disabled: !1, title: "" },
		    O = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.inline,
				    n = e.disabled,
				    o = e.validationState,
				    a = e.inputRef,
				    r = e.className,
				    i = e.style,
				    s = e.title,
				    d = e.children,
				    f = (0, u.default)(e, ["inline", "disabled", "validationState", "inputRef", "className", "style", "title", "children"]),
				    c = (0, C.splitBsProps)(f),
				    p = c[0],
				    h = c[1],
				    v = y.default.createElement("input", (0, l.default)({}, h, { ref: a, type: "checkbox", disabled: n }));if (t) {
					var b,
					    g = (b = {}, b[(0, C.prefix)(p, "inline")] = !0, b.disabled = n, b);return y.default.createElement("label", { className: (0, m.default)(r, g), style: i, title: s }, v, d);
				}var _ = (0, l.default)({}, (0, C.getClassSet)(p), { disabled: n });return o && (_["has-" + o] = !0), y.default.createElement("div", { className: (0, m.default)(r, _), style: i }, y.default.createElement("label", { title: s }, v, d));
			}, t;
		}(y.default.Component);O.propTypes = E, O.defaultProps = x, t.default = (0, C.bsClass)("checkbox", O), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(10),
		    C = o(_),
		    E = n(9),
		    x = n(96),
		    O = o(x),
		    S = n(12),
		    N = { componentClass: C.default, visibleXsBlock: g.default.bool, visibleSmBlock: g.default.bool, visibleMdBlock: g.default.bool, visibleLgBlock: g.default.bool },
		    M = { componentClass: "div" },
		    T = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.className,
				    o = (0, u.default)(e, ["componentClass", "className"]),
				    a = (0, E.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = (0, E.getClassSet)(r);return S.DEVICE_SIZES.forEach(function (e) {
					var t = "visible" + (0, O.default)(e) + "Block";i[t] && (s["visible-" + e + "-block"] = !0), delete i[t];
				}), y.default.createElement(t, (0, l.default)({}, i, { className: (0, m.default)(n, s) }));
			}, t;
		}(y.default.Component);T.propTypes = N, T.defaultProps = M, t.default = (0, E.bsClass)("clearfix", T), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(10),
		    C = o(_),
		    E = n(9),
		    x = n(12),
		    O = { componentClass: C.default, xs: g.default.number, sm: g.default.number, md: g.default.number, lg: g.default.number, xsHidden: g.default.bool, smHidden: g.default.bool, mdHidden: g.default.bool, lgHidden: g.default.bool, xsOffset: g.default.number, smOffset: g.default.number, mdOffset: g.default.number, lgOffset: g.default.number, xsPush: g.default.number, smPush: g.default.number, mdPush: g.default.number, lgPush: g.default.number, xsPull: g.default.number, smPull: g.default.number, mdPull: g.default.number, lgPull: g.default.number },
		    S = { componentClass: "div" },
		    N = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.className,
				    o = (0, u.default)(e, ["componentClass", "className"]),
				    a = (0, E.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = [];return x.DEVICE_SIZES.forEach(function (e) {
					function t(t, n) {
						var o = "" + e + t,
						    a = i[o];null != a && s.push((0, E.prefix)(r, "" + e + n + "-" + a)), delete i[o];
					}t("", ""), t("Offset", "-offset"), t("Push", "-push"), t("Pull", "-pull");var n = e + "Hidden";i[n] && s.push("hidden-" + e), delete i[n];
				}), y.default.createElement(t, (0, l.default)({}, i, { className: (0, m.default)(n, s) }));
			}, t;
		}(y.default.Component);N.propTypes = O, N.defaultProps = S, t.default = (0, E.bsClass)("col", N), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(15),
		    C = (o(_), n(9)),
		    E = { htmlFor: g.default.string, srOnly: g.default.bool },
		    x = { srOnly: !1 },
		    O = { $bs_formGroup: g.default.object },
		    S = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.context.$bs_formGroup,
				    t = e && e.controlId,
				    n = this.props,
				    o = n.htmlFor,
				    a = void 0 === o ? t : o,
				    r = n.srOnly,
				    i = n.className,
				    s = (0, u.default)(n, ["htmlFor", "srOnly", "className"]),
				    d = (0, C.splitBsProps)(s),
				    f = d[0],
				    c = d[1],
				    p = (0, l.default)({}, (0, C.getClassSet)(f), { "sr-only": r });return y.default.createElement("label", (0, l.default)({}, c, { htmlFor: a, className: (0, m.default)(i, p) }));
			}, t;
		}(y.default.Component);S.propTypes = E, S.defaultProps = x, S.contextTypes = O, t.default = (0, C.bsClass)("control-label", S), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(6),
		    l = o(a),
		    r = n(2),
		    u = o(r),
		    i = n(4),
		    s = o(i),
		    d = n(3),
		    f = o(d),
		    c = n(5),
		    p = o(c),
		    h = n(1),
		    m = o(h),
		    v = n(8),
		    y = o(v),
		    b = n(40),
		    g = o(b),
		    _ = n(43),
		    C = o(_),
		    E = (0, p.default)({}, g.default.propTypes, { bsStyle: y.default.string, bsSize: y.default.string, title: y.default.node.isRequired, noCaret: y.default.bool, children: y.default.node }),
		    x = function (e) {
			function t() {
				return (0, u.default)(this, t), (0, s.default)(this, e.apply(this, arguments));
			}return (0, f.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.bsSize,
				    n = e.bsStyle,
				    o = e.title,
				    a = e.children,
				    r = (0, l.default)(e, ["bsSize", "bsStyle", "title", "children"]),
				    u = (0, C.default)(r, g.default.ControlledComponent),
				    i = u[0],
				    s = u[1];return m.default.createElement(g.default, (0, p.default)({}, i, { bsSize: t, bsStyle: n }), m.default.createElement(g.default.Toggle, (0, p.default)({}, s, { bsSize: t, bsStyle: n }), o), m.default.createElement(g.default.Menu, null, a));
			}, t;
		}(m.default.Component);x.propTypes = E, t.default = x, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(186),
		    s = o(i),
		    d = n(2),
		    f = o(d),
		    c = n(4),
		    p = o(c),
		    h = n(3),
		    m = o(h),
		    v = n(7),
		    y = o(v),
		    b = n(77),
		    g = o(b),
		    _ = n(1),
		    C = o(_),
		    E = n(8),
		    x = o(E),
		    O = n(14),
		    S = o(O),
		    N = n(118),
		    M = o(N),
		    T = n(9),
		    w = n(11),
		    P = o(w),
		    k = n(13),
		    A = o(k),
		    R = { open: x.default.bool, pullRight: x.default.bool, onClose: x.default.func, labelledBy: x.default.oneOfType([x.default.string, x.default.number]), onSelect: x.default.func, rootCloseEvent: x.default.oneOf(["click", "mousedown"]) },
		    I = { bsRole: "menu", pullRight: !1 },
		    L = function (e) {
			function t(n) {
				(0, f.default)(this, t);var o = (0, p.default)(this, e.call(this, n));return o.handleRootClose = o.handleRootClose.bind(o), o.handleKeyDown = o.handleKeyDown.bind(o), o;
			}return (0, m.default)(t, e), t.prototype.getFocusableMenuItems = function () {
				var e = S.default.findDOMNode(this);return e ? (0, s.default)(e.querySelectorAll('[tabIndex="-1"]')) : [];
			}, t.prototype.getItemsAndActiveIndex = function () {
				var e = this.getFocusableMenuItems(),
				    t = e.indexOf(document.activeElement);return { items: e, activeIndex: t };
			}, t.prototype.focusNext = function () {
				var e = this.getItemsAndActiveIndex(),
				    t = e.items,
				    n = e.activeIndex;if (0 !== t.length) {
					var o = n === t.length - 1 ? 0 : n + 1;t[o].focus();
				}
			}, t.prototype.focusPrevious = function () {
				var e = this.getItemsAndActiveIndex(),
				    t = e.items,
				    n = e.activeIndex;if (0 !== t.length) {
					var o = 0 === n ? t.length - 1 : n - 1;t[o].focus();
				}
			}, t.prototype.handleKeyDown = function (e) {
				switch (e.keyCode) {case g.default.codes.down:
						this.focusNext(), e.preventDefault();break;case g.default.codes.up:
						this.focusPrevious(), e.preventDefault();break;case g.default.codes.esc:case g.default.codes.tab:
						this.props.onClose(e, { source: "keydown" });}
			}, t.prototype.handleRootClose = function (e) {
				this.props.onClose(e, { source: "rootClose" });
			}, t.prototype.render = function () {
				var e,
				    t = this,
				    n = this.props,
				    o = n.open,
				    a = n.pullRight,
				    r = n.labelledBy,
				    i = n.onSelect,
				    s = n.className,
				    d = n.rootCloseEvent,
				    f = n.children,
				    c = (0, u.default)(n, ["open", "pullRight", "labelledBy", "onSelect", "className", "rootCloseEvent", "children"]),
				    p = (0, T.splitBsPropsAndOmit)(c, ["onClose"]),
				    h = p[0],
				    m = p[1],
				    v = (0, l.default)({}, (0, T.getClassSet)(h), (e = {}, e[(0, T.prefix)(h, "right")] = a, e));return C.default.createElement(M.default, { disabled: !o, onRootClose: this.handleRootClose, event: d }, C.default.createElement("ul", (0, l.default)({}, m, { role: "menu", className: (0, y.default)(s, v), "aria-labelledby": r }), A.default.map(f, function (e) {
					return C.default.cloneElement(e, { onKeyDown: (0, P.default)(e.props.onKeyDown, t.handleKeyDown), onSelect: (0, P.default)(e.props.onSelect, i) });
				})));
			}, t;
		}(C.default.Component);L.propTypes = R, L.defaultProps = I, t.default = (0, T.bsClass)("dropdown-menu", L), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(10),
		    C = o(_),
		    E = n(9),
		    x = { horizontal: g.default.bool, inline: g.default.bool, componentClass: C.default },
		    O = { horizontal: !1, inline: !1, componentClass: "form" },
		    S = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.horizontal,
				    n = e.inline,
				    o = e.componentClass,
				    a = e.className,
				    r = (0, u.default)(e, ["horizontal", "inline", "componentClass", "className"]),
				    i = (0, E.splitBsProps)(r),
				    s = i[0],
				    d = i[1],
				    f = [];return t && f.push((0, E.prefix)(s, "horizontal")), n && f.push((0, E.prefix)(s, "inline")), y.default.createElement(o, (0, l.default)({}, d, { className: (0, m.default)(a, f) }));
			}, t;
		}(y.default.Component);S.propTypes = x, S.defaultProps = O, t.default = (0, E.bsClass)("form", S), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(10),
		    C = o(_),
		    E = n(15),
		    x = (o(E), n(137)),
		    O = o(x),
		    S = n(138),
		    N = o(S),
		    M = n(9),
		    T = n(12),
		    w = { componentClass: C.default, type: g.default.string, id: g.default.string, inputRef: g.default.func },
		    P = { componentClass: "input" },
		    k = { $bs_formGroup: g.default.object },
		    A = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.context.$bs_formGroup,
				    t = e && e.controlId,
				    n = this.props,
				    o = n.componentClass,
				    a = n.type,
				    r = n.id,
				    i = void 0 === r ? t : r,
				    s = n.inputRef,
				    d = n.className,
				    f = n.bsSize,
				    c = (0, u.default)(n, ["componentClass", "type", "id", "inputRef", "className", "bsSize"]),
				    p = (0, M.splitBsProps)(c),
				    h = p[0],
				    v = p[1],
				    b = void 0;if ("file" !== a && (b = (0, M.getClassSet)(h)), f) {
					var g = T.SIZE_MAP[f] || f;b[(0, M.prefix)({ bsClass: "input" }, g)] = !0;
				}return y.default.createElement(o, (0, l.default)({}, v, { type: a, id: i, ref: s, className: (0, m.default)(d, b) }));
			}, t;
		}(y.default.Component);A.propTypes = w, A.defaultProps = P, A.contextTypes = k, A.Feedback = O.default, A.Static = N.default, t.default = (0, M.bsClass)("form-control", (0, M.bsSizes)([T.Size.SMALL, T.Size.LARGE], A)), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(6),
		    l = o(a),
		    r = n(5),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(57),
		    C = o(_),
		    E = n(9),
		    x = { bsRole: "feedback" },
		    O = { $bs_formGroup: g.default.object },
		    S = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.getGlyph = function (e) {
				switch (e) {case "success":
						return "ok";case "warning":
						return "warning-sign";case "error":
						return "remove";default:
						return null;}
			}, t.prototype.renderDefaultFeedback = function (e, t, n, o) {
				var a = this.getGlyph(e && e.validationState);return a ? y.default.createElement(C.default, (0, u.default)({}, o, { glyph: a, className: (0, m.default)(t, n) })) : null;
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.className,
				    n = e.children,
				    o = (0, l.default)(e, ["className", "children"]),
				    a = (0, E.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = (0, E.getClassSet)(r);if (!n) return this.renderDefaultFeedback(this.context.$bs_formGroup, t, s, i);var d = y.default.Children.only(n);return y.default.cloneElement(d, (0, u.default)({}, i, { className: (0, m.default)(d.props.className, t, s) }));
			}, t;
		}(y.default.Component);S.defaultProps = x, S.contextTypes = O, t.default = (0, E.bsClass)("form-control-feedback", S), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(10),
		    g = o(b),
		    _ = n(9),
		    C = { componentClass: g.default },
		    E = { componentClass: "p" },
		    x = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.className,
				    o = (0, u.default)(e, ["componentClass", "className"]),
				    a = (0, _.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = (0, _.getClassSet)(r);return y.default.createElement(t, (0, l.default)({}, i, { className: (0, m.default)(n, s) }));
			}, t;
		}(y.default.Component);x.propTypes = C, x.defaultProps = E, t.default = (0, _.bsClass)("form-control-static", x), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(9),
		    C = n(12),
		    E = n(13),
		    x = o(E),
		    O = { controlId: g.default.string, validationState: g.default.oneOf(["success", "warning", "error", null]) },
		    S = { $bs_formGroup: g.default.object.isRequired },
		    N = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.getChildContext = function () {
				var e = this.props,
				    t = e.controlId,
				    n = e.validationState;return { $bs_formGroup: { controlId: t, validationState: n } };
			}, t.prototype.hasFeedback = function (e) {
				var t = this;return x.default.some(e, function (e) {
					return "feedback" === e.props.bsRole || e.props.children && t.hasFeedback(e.props.children);
				});
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.validationState,
				    n = e.className,
				    o = e.children,
				    a = (0, u.default)(e, ["validationState", "className", "children"]),
				    r = (0, _.splitBsPropsAndOmit)(a, ["controlId"]),
				    i = r[0],
				    s = r[1],
				    d = (0, l.default)({}, (0, _.getClassSet)(i), { "has-feedback": this.hasFeedback(o) });return t && (d["has-" + t] = !0), y.default.createElement("div", (0, l.default)({}, s, { className: (0, m.default)(n, d) }), o);
			}, t;
		}(y.default.Component);N.propTypes = O, N.childContextTypes = S, t.default = (0, _.bsClass)("form-group", (0, _.bsSizes)([C.Size.LARGE, C.Size.SMALL], N)), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(9),
		    g = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.className,
				    n = (0, u.default)(e, ["className"]),
				    o = (0, b.splitBsProps)(n),
				    a = o[0],
				    r = o[1],
				    i = (0, b.getClassSet)(a);return y.default.createElement("span", (0, l.default)({}, r, { className: (0, m.default)(t, i) }));
			}, t;
		}(y.default.Component);t.default = (0, b.bsClass)("help-block", g), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(9),
		    C = { responsive: g.default.bool, rounded: g.default.bool, circle: g.default.bool, thumbnail: g.default.bool },
		    E = { responsive: !1, rounded: !1, circle: !1, thumbnail: !1 },
		    x = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e,
				    t = this.props,
				    n = t.responsive,
				    o = t.rounded,
				    a = t.circle,
				    r = t.thumbnail,
				    i = t.className,
				    s = (0, u.default)(t, ["responsive", "rounded", "circle", "thumbnail", "className"]),
				    d = (0, _.splitBsProps)(s),
				    f = d[0],
				    c = d[1],
				    p = (e = {}, e[(0, _.prefix)(f, "responsive")] = n, e[(0, _.prefix)(f, "rounded")] = o, e[(0, _.prefix)(f, "circle")] = a, e[(0, _.prefix)(f, "thumbnail")] = r, e);return y.default.createElement("img", (0, l.default)({}, c, { className: (0, m.default)(i, p) }));
			}, t;
		}(y.default.Component);x.propTypes = C, x.defaultProps = E, t.default = (0, _.bsClass)("img", x), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(143),
		    g = o(b),
		    _ = n(144),
		    C = o(_),
		    E = n(9),
		    x = n(12),
		    O = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.className,
				    n = (0, u.default)(e, ["className"]),
				    o = (0, E.splitBsProps)(n),
				    a = o[0],
				    r = o[1],
				    i = (0, E.getClassSet)(a);return y.default.createElement("span", (0, l.default)({}, r, { className: (0, m.default)(t, i) }));
			}, t;
		}(y.default.Component);O.Addon = g.default, O.Button = C.default, t.default = (0, E.bsClass)("input-group", (0, E.bsSizes)([x.Size.LARGE, x.Size.SMALL], O)), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(9),
		    g = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.className,
				    n = (0, u.default)(e, ["className"]),
				    o = (0, b.splitBsProps)(n),
				    a = o[0],
				    r = o[1],
				    i = (0, b.getClassSet)(a);return y.default.createElement("span", (0, l.default)({}, r, { className: (0, m.default)(t, i) }));
			}, t;
		}(y.default.Component);t.default = (0, b.bsClass)("input-group-addon", g), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(9),
		    g = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.className,
				    n = (0, u.default)(e, ["className"]),
				    o = (0, b.splitBsProps)(n),
				    a = o[0],
				    r = o[1],
				    i = (0, b.getClassSet)(a);return y.default.createElement("span", (0, l.default)({}, r, { className: (0, m.default)(t, i) }));
			}, t;
		}(y.default.Component);t.default = (0, b.bsClass)("input-group-btn", g), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(1),
		    m = o(h),
		    v = n(7),
		    y = o(v),
		    b = n(10),
		    g = o(b),
		    _ = n(9),
		    C = { componentClass: g.default },
		    E = { componentClass: "div" },
		    x = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.className,
				    o = (0, u.default)(e, ["componentClass", "className"]),
				    a = (0, _.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = (0, _.getClassSet)(r);return m.default.createElement(t, (0, l.default)({}, i, { className: (0, y.default)(n, s) }));
			}, t;
		}(m.default.Component);x.propTypes = C, x.defaultProps = E, t.default = (0, _.bsClass)("jumbotron", x), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(25),
		    l = o(a),
		    r = n(5),
		    u = o(r),
		    i = n(6),
		    s = o(i),
		    d = n(2),
		    f = o(d),
		    c = n(4),
		    p = o(c),
		    h = n(3),
		    m = o(h),
		    v = n(7),
		    y = o(v),
		    b = n(1),
		    g = o(b),
		    _ = n(9),
		    C = n(12),
		    E = function (e) {
			function t() {
				return (0, f.default)(this, t), (0, p.default)(this, e.apply(this, arguments));
			}return (0, m.default)(t, e), t.prototype.hasContent = function (e) {
				var t = !1;return g.default.Children.forEach(e, function (e) {
					t || (e || 0 === e) && (t = !0);
				}), t;
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.className,
				    n = e.children,
				    o = (0, s.default)(e, ["className", "children"]),
				    a = (0, _.splitBsProps)(o),
				    l = a[0],
				    r = a[1],
				    i = (0, u.default)({}, (0, _.getClassSet)(l), { hidden: !this.hasContent(n) });return g.default.createElement("span", (0, u.default)({}, r, { className: (0, y.default)(t, i) }), n);
			}, t;
		}(g.default.Component);t.default = (0, _.bsClass)("label", (0, _.bsStyles)([].concat((0, l.default)(C.State), [C.Style.DEFAULT, C.Style.PRIMARY]), C.Style.DEFAULT, E)), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e) {
			return e ? S.default.some(e, function (e) {
				return e.type !== E.default || e.props.href || e.props.onClick;
			}) ? "div" : "ul" : "div";
		}t.__esModule = !0;var l = n(5),
		    r = o(l),
		    u = n(6),
		    i = o(u),
		    s = n(2),
		    d = o(s),
		    f = n(4),
		    c = o(f),
		    p = n(3),
		    h = o(p),
		    m = n(7),
		    v = o(m),
		    y = n(1),
		    b = o(y),
		    g = n(10),
		    _ = o(g),
		    C = n(82),
		    E = o(C),
		    x = n(9),
		    O = n(13),
		    S = o(O),
		    N = { componentClass: _.default },
		    M = function (e) {
			function t() {
				return (0, d.default)(this, t), (0, c.default)(this, e.apply(this, arguments));
			}return (0, h.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.children,
				    n = e.componentClass,
				    o = void 0 === n ? a(t) : n,
				    l = e.className,
				    u = (0, i.default)(e, ["children", "componentClass", "className"]),
				    s = (0, x.splitBsProps)(u),
				    d = s[0],
				    f = s[1],
				    c = (0, x.getClassSet)(d),
				    p = "ul" === o && S.default.every(t, function (e) {
					return e.type === E.default;
				});return b.default.createElement(o, (0, r.default)({}, f, { className: (0, v.default)(l, c) }), p ? S.default.map(t, function (e) {
					return (0, y.cloneElement)(e, { listItem: !0 });
				}) : t);
			}, t;
		}(b.default.Component);M.propTypes = N, t.default = (0, x.bsClass)("list-group", M), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(10),
		    C = o(_),
		    E = n(42),
		    x = o(E),
		    O = n(9),
		    S = { align: g.default.oneOf(["top", "middle", "bottom"]), componentClass: C.default },
		    N = { componentClass: "div" },
		    M = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.align,
				    o = e.className,
				    a = (0, u.default)(e, ["componentClass", "align", "className"]),
				    r = (0, O.splitBsProps)(a),
				    i = r[0],
				    s = r[1],
				    d = (0, O.getClassSet)(i);return n && (d[(0, O.prefix)(x.default.defaultProps, n)] = !0), y.default.createElement(t, (0, l.default)({}, s, { className: (0, m.default)(o, d) }));
			}, t;
		}(y.default.Component);M.propTypes = S, M.defaultProps = N, t.default = (0, O.bsClass)("media-body", M), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(10),
		    g = o(b),
		    _ = n(9),
		    C = { componentClass: g.default },
		    E = { componentClass: "h4" },
		    x = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.className,
				    o = (0, u.default)(e, ["componentClass", "className"]),
				    a = (0, _.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = (0, _.getClassSet)(r);return y.default.createElement(t, (0, l.default)({}, i, { className: (0, m.default)(n, s) }));
			}, t;
		}(y.default.Component);x.propTypes = C, x.defaultProps = E, t.default = (0, _.bsClass)("media-heading", x), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(42),
		    C = o(_),
		    E = n(9),
		    x = { align: g.default.oneOf(["top", "middle", "bottom"]) },
		    O = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.align,
				    n = e.className,
				    o = (0, u.default)(e, ["align", "className"]),
				    a = (0, E.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = (0, E.getClassSet)(r);return t && (s[(0, E.prefix)(C.default.defaultProps, t)] = !0), y.default.createElement("div", (0, l.default)({}, i, { className: (0, m.default)(n, s) }));
			}, t;
		}(y.default.Component);O.propTypes = x, t.default = (0, E.bsClass)("media-left", O), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(9),
		    g = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.className,
				    n = (0, u.default)(e, ["className"]),
				    o = (0, b.splitBsProps)(n),
				    a = o[0],
				    r = o[1],
				    i = (0, b.getClassSet)(a);return y.default.createElement("ul", (0, l.default)({}, r, { className: (0, m.default)(t, i) }));
			}, t;
		}(y.default.Component);t.default = (0, b.bsClass)("media-list", g), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(9),
		    g = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.className,
				    n = (0, u.default)(e, ["className"]),
				    o = (0, b.splitBsProps)(n),
				    a = o[0],
				    r = o[1],
				    i = (0, b.getClassSet)(a);return y.default.createElement("li", (0, l.default)({}, r, { className: (0, m.default)(t, i) }));
			}, t;
		}(y.default.Component);t.default = (0, b.bsClass)("media", g), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(42),
		    C = o(_),
		    E = n(9),
		    x = { align: g.default.oneOf(["top", "middle", "bottom"]) },
		    O = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.align,
				    n = e.className,
				    o = (0, u.default)(e, ["align", "className"]),
				    a = (0, E.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = (0, E.getClassSet)(r);return t && (s[(0, E.prefix)(C.default.defaultProps, t)] = !0), y.default.createElement("div", (0, l.default)({}, i, { className: (0, m.default)(n, s) }));
			}, t;
		}(y.default.Component);O.propTypes = x, t.default = (0, E.bsClass)("media-right", O), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(49),
		    C = o(_),
		    E = n(16),
		    x = o(E),
		    O = n(9),
		    S = n(11),
		    N = o(S),
		    M = { active: g.default.bool, disabled: g.default.bool, divider: (0, C.default)(g.default.bool, function (e) {
				var t = e.divider,
				    n = e.children;return t && n ? new Error("Children will not be rendered for dividers") : null;
			}), eventKey: g.default.any, header: g.default.bool, href: g.default.string, onClick: g.default.func, onSelect: g.default.func },
		    T = { divider: !1, disabled: !1, header: !1 },
		    w = function (e) {
			function t(n, o) {
				(0, s.default)(this, t);var a = (0, f.default)(this, e.call(this, n, o));return a.handleClick = a.handleClick.bind(a), a;
			}return (0, p.default)(t, e), t.prototype.handleClick = function (e) {
				var t = this.props,
				    n = t.href,
				    o = t.disabled,
				    a = t.onSelect,
				    l = t.eventKey;n && !o || e.preventDefault(), o || a && a(l, e);
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.active,
				    n = e.disabled,
				    o = e.divider,
				    a = e.header,
				    r = e.onClick,
				    i = e.className,
				    s = e.style,
				    d = (0, u.default)(e, ["active", "disabled", "divider", "header", "onClick", "className", "style"]),
				    f = (0, O.splitBsPropsAndOmit)(d, ["eventKey", "onSelect"]),
				    c = f[0],
				    p = f[1];return o ? (p.children = void 0, y.default.createElement("li", (0, l.default)({}, p, { role: "separator", className: (0, m.default)(i, "divider"), style: s }))) : a ? y.default.createElement("li", (0, l.default)({}, p, { role: "heading", className: (0, m.default)(i, (0, O.prefix)(c, "header")), style: s })) : y.default.createElement("li", { role: "presentation", className: (0, m.default)(i, { active: t, disabled: n }), style: s }, y.default.createElement(x.default, (0, l.default)({}, p, { role: "menuitem", tabIndex: "-1", onClick: (0, N.default)(r, this.handleClick) })));
			}, t;
		}(y.default.Component);w.propTypes = M, w.defaultProps = T, t.default = (0, O.bsClass)("dropdown", w), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(6),
		    l = o(a),
		    r = n(2),
		    u = o(r),
		    i = n(4),
		    s = o(i),
		    d = n(3),
		    f = o(d),
		    c = n(5),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(237),
		    y = o(v),
		    b = n(29),
		    g = o(b),
		    _ = n(21),
		    C = o(_),
		    E = n(116),
		    x = o(E),
		    O = n(1),
		    S = o(O),
		    N = n(8),
		    M = o(N),
		    T = n(14),
		    w = o(T),
		    P = n(255),
		    k = o(P),
		    A = n(121),
		    R = o(A),
		    I = n(10),
		    L = o(I),
		    D = n(41),
		    j = o(D),
		    B = n(83),
		    K = o(B),
		    F = n(156),
		    H = o(F),
		    U = n(84),
		    z = o(U),
		    W = n(85),
		    $ = o(W),
		    G = n(86),
		    V = o(G),
		    q = n(9),
		    Y = n(11),
		    X = o(Y),
		    Z = n(43),
		    J = o(Z),
		    Q = n(12),
		    ee = (0, p.default)({}, k.default.propTypes, H.default.propTypes, { backdrop: M.default.oneOf(["static", !0, !1]), backdropClassName: M.default.string, keyboard: M.default.bool, animation: M.default.bool, dialogComponentClass: L.default, autoFocus: M.default.bool, enforceFocus: M.default.bool, restoreFocus: M.default.bool, show: M.default.bool, onHide: M.default.func, onEnter: M.default.func, onEntering: M.default.func, onEntered: M.default.func, onExit: M.default.func, onExiting: M.default.func, onExited: M.default.func, container: k.default.propTypes.container }),
		    te = (0, p.default)({}, k.default.defaultProps, { animation: !0, dialogComponentClass: H.default }),
		    ne = { $bs_modal: M.default.shape({ onHide: M.default.func }) },
		    oe = function (e) {
			function t(n, o) {
				(0, u.default)(this, t);var a = (0, s.default)(this, e.call(this, n, o));return a.handleEntering = a.handleEntering.bind(a), a.handleExited = a.handleExited.bind(a), a.handleWindowResize = a.handleWindowResize.bind(a), a.handleDialogClick = a.handleDialogClick.bind(a), a.setModalRef = a.setModalRef.bind(a), a.state = { style: {} }, a;
			}return (0, f.default)(t, e), t.prototype.getChildContext = function () {
				return { $bs_modal: { onHide: this.props.onHide } };
			}, t.prototype.componentWillUnmount = function () {
				this.handleExited();
			}, t.prototype.setModalRef = function (e) {
				this._modal = e;
			}, t.prototype.handleDialogClick = function (e) {
				e.target === e.currentTarget && this.props.onHide();
			}, t.prototype.handleEntering = function () {
				y.default.on(window, "resize", this.handleWindowResize), this.updateStyle();
			}, t.prototype.handleExited = function () {
				y.default.off(window, "resize", this.handleWindowResize);
			}, t.prototype.handleWindowResize = function () {
				this.updateStyle();
			}, t.prototype.updateStyle = function () {
				if (C.default) {
					var e = this._modal.getDialogElement(),
					    t = e.scrollHeight,
					    n = (0, g.default)(e),
					    o = (0, R.default)(w.default.findDOMNode(this.props.container || n.body)),
					    a = t > n.documentElement.clientHeight;this.setState({ style: { paddingRight: o && !a ? (0, x.default)() : void 0, paddingLeft: !o && a ? (0, x.default)() : void 0 } });
				}
			}, t.prototype.render = function () {
				var e = this.props,
				    n = e.backdrop,
				    o = e.backdropClassName,
				    a = e.animation,
				    r = e.show,
				    u = e.dialogComponentClass,
				    i = e.className,
				    s = e.style,
				    d = e.children,
				    f = e.onEntering,
				    c = e.onExited,
				    h = (0, l.default)(e, ["backdrop", "backdropClassName", "animation", "show", "dialogComponentClass", "className", "style", "children", "onEntering", "onExited"]),
				    v = (0, J.default)(h, k.default),
				    y = v[0],
				    b = v[1],
				    g = r && !a && "in";return S.default.createElement(k.default, (0, p.default)({}, y, { ref: this.setModalRef, show: r, onEntering: (0, X.default)(f, this.handleEntering), onExited: (0, X.default)(c, this.handleExited), backdrop: n, backdropClassName: (0, m.default)((0, q.prefix)(h, "backdrop"), o, g), containerClassName: (0, q.prefix)(h, "open"), transition: a ? j.default : void 0, dialogTransitionTimeout: t.TRANSITION_DURATION, backdropTransitionTimeout: t.BACKDROP_TRANSITION_DURATION }), S.default.createElement(u, (0, p.default)({}, b, { style: (0, p.default)({}, this.state.style, s), className: (0, m.default)(i, g), onClick: n === !0 ? this.handleDialogClick : null }), d));
			}, t;
		}(S.default.Component);oe.propTypes = ee, oe.defaultProps = te, oe.childContextTypes = ne, oe.Body = K.default, oe.Header = $.default, oe.Title = V.default, oe.Footer = z.default, oe.Dialog = H.default, oe.TRANSITION_DURATION = 300, oe.BACKDROP_TRANSITION_DURATION = 150, t.default = (0, q.bsClass)("modal", (0, q.bsSizes)([Q.Size.LARGE, Q.Size.SMALL], oe)), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(9),
		    C = n(12),
		    E = { dialogClassName: g.default.string },
		    x = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e,
				    t = this.props,
				    n = t.dialogClassName,
				    o = t.className,
				    a = t.style,
				    r = t.children,
				    i = (0, u.default)(t, ["dialogClassName", "className", "style", "children"]),
				    s = (0, _.splitBsProps)(i),
				    d = s[0],
				    f = s[1],
				    c = (0, _.prefix)(d),
				    p = (0, l.default)({ display: "block" }, a),
				    h = (0, l.default)({}, (0, _.getClassSet)(d), (e = {}, e[c] = !1, e[(0, _.prefix)(d, "dialog")] = !0, e));return y.default.createElement("div", (0, l.default)({}, f, { tabIndex: "-1", role: "dialog", style: p, className: (0, m.default)(o, c) }), y.default.createElement("div", { className: (0, m.default)(n, h) }, y.default.createElement("div", { className: (0, _.prefix)(d, "content"), role: "document" }, r)));
			}, t;
		}(y.default.Component);x.propTypes = E, t.default = (0, _.bsClass)("modal", (0, _.bsSizes)([C.Size.LARGE, C.Size.SMALL], x)), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(6),
		    l = o(a),
		    r = n(2),
		    u = o(r),
		    i = n(4),
		    s = o(i),
		    d = n(3),
		    f = o(d),
		    c = n(5),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(40),
		    C = o(_),
		    E = n(43),
		    x = o(E),
		    O = n(13),
		    S = o(O),
		    N = (0, p.default)({}, C.default.propTypes, { title: g.default.node.isRequired, noCaret: g.default.bool, active: g.default.bool, children: g.default.node }),
		    M = function (e) {
			function t() {
				return (0, u.default)(this, t), (0, s.default)(this, e.apply(this, arguments));
			}return (0, f.default)(t, e), t.prototype.isActive = function (e, t, n) {
				var o = e.props,
				    a = this;return !!(o.active || null != t && o.eventKey === t || n && o.href === n) || !!S.default.some(o.children, function (e) {
					return a.isActive(e, t, n);
				}) || o.active;
			}, t.prototype.render = function () {
				var e = this,
				    t = this.props,
				    n = t.title,
				    o = t.activeKey,
				    a = t.activeHref,
				    r = t.className,
				    u = t.style,
				    i = t.children,
				    s = (0, l.default)(t, ["title", "activeKey", "activeHref", "className", "style", "children"]),
				    d = this.isActive(this, o, a);delete s.active, delete s.eventKey;var f = (0, x.default)(s, C.default.ControlledComponent),
				    c = f[0],
				    h = f[1];return y.default.createElement(C.default, (0, p.default)({}, c, { componentClass: "li", className: (0, m.default)(r, { active: d }), style: u }), y.default.createElement(C.default.Toggle, (0, p.default)({}, h, { useAnchor: !0 }), n), y.default.createElement(C.default.Menu, null, S.default.map(i, function (t) {
					return y.default.cloneElement(t, { active: e.isActive(t, o, a) });
				})));
			}, t;
		}(y.default.Component);M.propTypes = N, t.default = M, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t, n) {
			var o = function o(e, n) {
				var o = n.$bs_navbar,
				    a = void 0 === o ? { bsClass: "navbar" } : o,
				    l = e.componentClass,
				    u = e.className,
				    s = e.pullRight,
				    d = e.pullLeft,
				    f = (0, i.default)(e, ["componentClass", "className", "pullRight", "pullLeft"]);return b.default.createElement(l, (0, r.default)({}, f, { className: (0, v.default)(u, (0, L.prefix)(a, t), s && (0, L.prefix)(a, "right"), d && (0, L.prefix)(a, "left")) }));
			};return o.displayName = n, o.propTypes = { componentClass: E.default, pullRight: _.default.bool, pullLeft: _.default.bool }, o.defaultProps = { componentClass: e, pullRight: !1, pullLeft: !1 }, o.contextTypes = { $bs_navbar: _.default.shape({ bsClass: _.default.string }) }, o;
		}t.__esModule = !0;var l = n(5),
		    r = o(l),
		    u = n(6),
		    i = o(u),
		    s = n(2),
		    d = o(s),
		    f = n(4),
		    c = o(f),
		    p = n(3),
		    h = o(p),
		    m = n(7),
		    v = o(m),
		    y = n(1),
		    b = o(y),
		    g = n(8),
		    _ = o(g),
		    C = n(10),
		    E = o(C),
		    x = n(39),
		    O = o(x),
		    S = n(81),
		    N = o(S),
		    M = n(89),
		    T = o(M),
		    w = n(159),
		    P = o(w),
		    k = n(160),
		    A = o(k),
		    R = n(161),
		    I = o(R),
		    L = n(9),
		    D = n(12),
		    j = n(11),
		    B = o(j),
		    K = { fixedTop: _.default.bool, fixedBottom: _.default.bool, staticTop: _.default.bool, inverse: _.default.bool, fluid: _.default.bool, componentClass: E.default, onToggle: _.default.func, onSelect: _.default.func, collapseOnSelect: _.default.bool, expanded: _.default.bool, role: _.default.string },
		    F = { componentClass: "nav", fixedTop: !1, fixedBottom: !1, staticTop: !1, inverse: !1, fluid: !1, collapseOnSelect: !1 },
		    H = { $bs_navbar: _.default.shape({ bsClass: _.default.string, expanded: _.default.bool, onToggle: _.default.func.isRequired, onSelect: _.default.func }) },
		    U = function (e) {
			function t(n, o) {
				(0, d.default)(this, t);var a = (0, c.default)(this, e.call(this, n, o));return a.handleToggle = a.handleToggle.bind(a), a.handleCollapse = a.handleCollapse.bind(a), a;
			}return (0, h.default)(t, e), t.prototype.getChildContext = function () {
				var e = this.props,
				    t = e.bsClass,
				    n = e.expanded,
				    o = e.onSelect,
				    a = e.collapseOnSelect;return { $bs_navbar: { bsClass: t, expanded: n, onToggle: this.handleToggle, onSelect: (0, B.default)(o, a ? this.handleCollapse : null) } };
			}, t.prototype.handleCollapse = function () {
				var e = this.props,
				    t = e.onToggle,
				    n = e.expanded;n && t(!1);
			}, t.prototype.handleToggle = function () {
				var e = this.props,
				    t = e.onToggle,
				    n = e.expanded;t(!n);
			}, t.prototype.render = function () {
				var e,
				    t = this.props,
				    n = t.componentClass,
				    o = t.fixedTop,
				    a = t.fixedBottom,
				    l = t.staticTop,
				    u = t.inverse,
				    s = t.fluid,
				    d = t.className,
				    f = t.children,
				    c = (0, i.default)(t, ["componentClass", "fixedTop", "fixedBottom", "staticTop", "inverse", "fluid", "className", "children"]),
				    p = (0, L.splitBsPropsAndOmit)(c, ["expanded", "onToggle", "onSelect", "collapseOnSelect"]),
				    h = p[0],
				    m = p[1];void 0 === m.role && "nav" !== n && (m.role = "navigation"), u && (h.bsStyle = D.Style.INVERSE);var y = (0, r.default)({}, (0, L.getClassSet)(h), (e = {}, e[(0, L.prefix)(h, "fixed-top")] = o, e[(0, L.prefix)(h, "fixed-bottom")] = a, e[(0, L.prefix)(h, "static-top")] = l, e));return b.default.createElement(n, (0, r.default)({}, m, { className: (0, v.default)(d, y) }), b.default.createElement(N.default, { fluid: s }, f));
			}, t;
		}(b.default.Component);U.propTypes = K, U.defaultProps = F, U.childContextTypes = H, (0, L.bsClass)("navbar", U);var z = (0, O.default)(U, { expanded: "onToggle" });z.Brand = T.default, z.Header = A.default, z.Toggle = I.default, z.Collapse = P.default, z.Form = a("div", "form", "NavbarForm"), z.Text = a("p", "text", "NavbarText"), z.Link = a("a", "link", "NavbarLink"), t.default = (0, L.bsStyles)([D.Style.DEFAULT, D.Style.INVERSE], D.Style.DEFAULT, z), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(1),
		    m = o(h),
		    v = n(8),
		    y = o(v),
		    b = n(56),
		    g = o(b),
		    _ = n(9),
		    C = { $bs_navbar: y.default.shape({ bsClass: y.default.string, expanded: y.default.bool }) },
		    E = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.children,
				    n = (0, u.default)(e, ["children"]),
				    o = this.context.$bs_navbar || { bsClass: "navbar" },
				    a = (0, _.prefix)(o, "collapse");return m.default.createElement(g.default, (0, l.default)({ in: o.expanded }, n), m.default.createElement("div", { className: a }, t));
			}, t;
		}(m.default.Component);E.contextTypes = C, t.default = E, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(9),
		    C = { $bs_navbar: g.default.shape({ bsClass: g.default.string }) },
		    E = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.className,
				    n = (0, u.default)(e, ["className"]),
				    o = this.context.$bs_navbar || { bsClass: "navbar" },
				    a = (0, _.prefix)(o, "header");return y.default.createElement("div", (0, l.default)({}, n, { className: (0, m.default)(t, a) }));
			}, t;
		}(y.default.Component);E.contextTypes = C, t.default = E, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(9),
		    C = n(11),
		    E = o(C),
		    x = { onClick: g.default.func, children: g.default.node },
		    O = { $bs_navbar: g.default.shape({ bsClass: g.default.string, expanded: g.default.bool, onToggle: g.default.func.isRequired }) },
		    S = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.onClick,
				    n = e.className,
				    o = e.children,
				    a = (0, u.default)(e, ["onClick", "className", "children"]),
				    r = this.context.$bs_navbar || { bsClass: "navbar" },
				    i = (0, l.default)({ type: "button" }, a, { onClick: (0, E.default)(t, r.onToggle), className: (0, m.default)(n, (0, _.prefix)(r, "toggle"), !r.expanded && "collapsed") });return o ? y.default.createElement("button", i, o) : y.default.createElement("button", i, y.default.createElement("span", { className: "sr-only" }, "Toggle navigation"), y.default.createElement("span", { className: "icon-bar" }), y.default.createElement("span", { className: "icon-bar" }), y.default.createElement("span", { className: "icon-bar" }));
			}, t;
		}(y.default.Component);S.propTypes = x, S.contextTypes = O, t.default = S, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			return Array.isArray(t) ? t.indexOf(e) >= 0 : e === t;
		}t.__esModule = !0;var l = n(6),
		    r = o(l),
		    u = n(2),
		    i = o(u),
		    s = n(4),
		    d = o(s),
		    f = n(3),
		    c = o(f),
		    p = n(5),
		    h = o(p),
		    m = n(30),
		    v = o(m),
		    y = n(1),
		    b = o(y),
		    g = n(8),
		    _ = o(g),
		    C = n(14),
		    E = o(C),
		    x = n(15),
		    O = (o(x), n(90)),
		    S = o(O),
		    N = n(11),
		    M = o(N),
		    T = _.default.oneOf(["click", "hover", "focus"]),
		    w = (0, h.default)({}, S.default.propTypes, { trigger: _.default.oneOfType([T, _.default.arrayOf(T)]), delay: _.default.number, delayShow: _.default.number, delayHide: _.default.number, defaultOverlayShown: _.default.bool, overlay: _.default.node.isRequired, onBlur: _.default.func, onClick: _.default.func, onFocus: _.default.func, onMouseOut: _.default.func, onMouseOver: _.default.func, target: _.default.oneOf([null]), onHide: _.default.oneOf([null]), show: _.default.oneOf([null]) }),
		    P = { defaultOverlayShown: !1, trigger: ["hover", "focus"] },
		    k = function (e) {
			function t(n, o) {
				(0, i.default)(this, t);var a = (0, d.default)(this, e.call(this, n, o));return a.handleToggle = a.handleToggle.bind(a), a.handleDelayedShow = a.handleDelayedShow.bind(a), a.handleDelayedHide = a.handleDelayedHide.bind(a), a.handleHide = a.handleHide.bind(a), a.handleMouseOver = function (e) {
					return a.handleMouseOverOut(a.handleDelayedShow, e);
				}, a.handleMouseOut = function (e) {
					return a.handleMouseOverOut(a.handleDelayedHide, e);
				}, a._mountNode = null, a.state = { show: n.defaultOverlayShown }, a;
			}return (0, c.default)(t, e), t.prototype.componentDidMount = function () {
				this._mountNode = document.createElement("div"), this.renderOverlay();
			}, t.prototype.componentDidUpdate = function () {
				this.renderOverlay();
			}, t.prototype.componentWillUnmount = function () {
				E.default.unmountComponentAtNode(this._mountNode), this._mountNode = null, clearTimeout(this._hoverShowDelay), clearTimeout(this._hoverHideDelay);
			}, t.prototype.handleDelayedHide = function () {
				var e = this;if (null != this._hoverShowDelay) return clearTimeout(this._hoverShowDelay), void (this._hoverShowDelay = null);if (this.state.show && null == this._hoverHideDelay) {
					var t = null != this.props.delayHide ? this.props.delayHide : this.props.delay;return t ? void (this._hoverHideDelay = setTimeout(function () {
						e._hoverHideDelay = null, e.hide();
					}, t)) : void this.hide();
				}
			}, t.prototype.handleDelayedShow = function () {
				var e = this;if (null != this._hoverHideDelay) return clearTimeout(this._hoverHideDelay), void (this._hoverHideDelay = null);if (!this.state.show && null == this._hoverShowDelay) {
					var t = null != this.props.delayShow ? this.props.delayShow : this.props.delay;return t ? void (this._hoverShowDelay = setTimeout(function () {
						e._hoverShowDelay = null, e.show();
					}, t)) : void this.show();
				}
			}, t.prototype.handleHide = function () {
				this.hide();
			}, t.prototype.handleMouseOverOut = function (e, t) {
				var n = t.currentTarget,
				    o = t.relatedTarget || t.nativeEvent.toElement;o && o === n || (0, v.default)(n, o) || e(t);
			}, t.prototype.handleToggle = function () {
				this.state.show ? this.hide() : this.show();
			}, t.prototype.hide = function () {
				this.setState({ show: !1 });
			}, t.prototype.makeOverlay = function (e, t) {
				return b.default.createElement(S.default, (0, h.default)({}, t, { show: this.state.show, onHide: this.handleHide, target: this }), e);
			}, t.prototype.show = function () {
				this.setState({ show: !0 });
			}, t.prototype.renderOverlay = function () {
				E.default.unstable_renderSubtreeIntoContainer(this, this._overlay, this._mountNode);
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.trigger,
				    n = e.overlay,
				    o = e.children,
				    l = e.onBlur,
				    u = e.onClick,
				    i = e.onFocus,
				    s = e.onMouseOut,
				    d = e.onMouseOver,
				    f = (0, r.default)(e, ["trigger", "overlay", "children", "onBlur", "onClick", "onFocus", "onMouseOut", "onMouseOver"]);
				delete f.delay, delete f.delayShow, delete f.delayHide, delete f.defaultOverlayShown;var c = b.default.Children.only(o),
				    p = c.props,
				    h = {};return this.state.show && (h["aria-describedby"] = n.props.id), h.onClick = (0, M.default)(p.onClick, u), a("click", t) && (h.onClick = (0, M.default)(h.onClick, this.handleToggle)), a("hover", t) && (h.onMouseOver = (0, M.default)(p.onMouseOver, d, this.handleMouseOver), h.onMouseOut = (0, M.default)(p.onMouseOut, s, this.handleMouseOut)), a("focus", t) && (h.onFocus = (0, M.default)(p.onFocus, i, this.handleDelayedShow), h.onBlur = (0, M.default)(p.onBlur, l, this.handleDelayedHide)), this._overlay = this.makeOverlay(n, f), (0, y.cloneElement)(c, h);
			}, t;
		}(b.default.Component);k.propTypes = w, k.defaultProps = P, t.default = k, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(9),
		    g = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.className,
				    n = e.children,
				    o = (0, u.default)(e, ["className", "children"]),
				    a = (0, b.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = (0, b.getClassSet)(r);return y.default.createElement("div", (0, l.default)({}, i, { className: (0, m.default)(t, s) }), y.default.createElement("h1", null, n));
			}, t;
		}(y.default.Component);t.default = (0, b.bsClass)("page-header", g), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(91),
		    l = o(a),
		    r = n(184),
		    u = o(r);t.default = u.default.wrapper(l.default, "`<PageItem>`", "`<Pager.Item>`"), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(91),
		    C = o(_),
		    E = n(9),
		    x = n(11),
		    O = o(x),
		    S = n(13),
		    N = o(S),
		    M = { onSelect: g.default.func },
		    T = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.onSelect,
				    n = e.className,
				    o = e.children,
				    a = (0, u.default)(e, ["onSelect", "className", "children"]),
				    r = (0, E.splitBsProps)(a),
				    i = r[0],
				    s = r[1],
				    d = (0, E.getClassSet)(i);return y.default.createElement("ul", (0, l.default)({}, s, { className: (0, m.default)(n, d) }), N.default.map(o, function (e) {
					return (0, v.cloneElement)(e, { onSelect: (0, O.default)(e.props.onSelect, t) });
				}));
			}, t;
		}(y.default.Component);T.propTypes = M, T.Item = C.default, t.default = (0, E.bsClass)("pager", T), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(6),
		    l = o(a),
		    r = n(5),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(10),
		    C = o(_),
		    E = n(92),
		    x = o(E),
		    O = n(9),
		    S = { activePage: g.default.number, items: g.default.number, maxButtons: g.default.number, boundaryLinks: g.default.bool, ellipsis: g.default.oneOfType([g.default.bool, g.default.node]), first: g.default.oneOfType([g.default.bool, g.default.node]), last: g.default.oneOfType([g.default.bool, g.default.node]), prev: g.default.oneOfType([g.default.bool, g.default.node]), next: g.default.oneOfType([g.default.bool, g.default.node]), onSelect: g.default.func, buttonComponentClass: C.default },
		    N = { activePage: 1, items: 1, maxButtons: 0, first: !1, last: !1, prev: !1, next: !1, ellipsis: !0, boundaryLinks: !1 },
		    M = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.renderPageButtons = function (e, t, n, o, a, l) {
				var r = [],
				    i = void 0,
				    s = void 0;n && n < t ? (i = Math.max(Math.min(e - Math.floor(n / 2, 10), t - n + 1), 1), s = i + n - 1) : (i = 1, s = t);for (var d = i; d <= s; ++d) {
					r.push(y.default.createElement(x.default, (0, u.default)({}, l, { key: d, eventKey: d, active: d === e }), d));
				}return a && o && i > 1 && (i > 2 && r.unshift(y.default.createElement(x.default, { key: "ellipsisFirst", disabled: !0, componentClass: l.componentClass }, y.default.createElement("span", { "aria-label": "More" }, a === !0 ? "…" : a))), r.unshift(y.default.createElement(x.default, (0, u.default)({}, l, { key: 1, eventKey: 1, active: !1 }), "1"))), a && s < t && ((!o || s < t - 1) && r.push(y.default.createElement(x.default, { key: "ellipsis", disabled: !0, componentClass: l.componentClass }, y.default.createElement("span", { "aria-label": "More" }, a === !0 ? "…" : a))), o && r.push(y.default.createElement(x.default, (0, u.default)({}, l, { key: t, eventKey: t, active: !1 }), t))), r;
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.activePage,
				    n = e.items,
				    o = e.maxButtons,
				    a = e.boundaryLinks,
				    r = e.ellipsis,
				    i = e.first,
				    s = e.last,
				    d = e.prev,
				    f = e.next,
				    c = e.onSelect,
				    p = e.buttonComponentClass,
				    h = e.className,
				    v = (0, l.default)(e, ["activePage", "items", "maxButtons", "boundaryLinks", "ellipsis", "first", "last", "prev", "next", "onSelect", "buttonComponentClass", "className"]),
				    b = (0, O.splitBsProps)(v),
				    g = b[0],
				    _ = b[1],
				    C = (0, O.getClassSet)(g),
				    E = { onSelect: c, componentClass: p };return y.default.createElement("ul", (0, u.default)({}, _, { className: (0, m.default)(h, C) }), i && y.default.createElement(x.default, (0, u.default)({}, E, { eventKey: 1, disabled: 1 === t }), y.default.createElement("span", { "aria-label": "First" }, i === !0 ? "«" : i)), d && y.default.createElement(x.default, (0, u.default)({}, E, { eventKey: t - 1, disabled: 1 === t }), y.default.createElement("span", { "aria-label": "Previous" }, d === !0 ? "‹" : d)), this.renderPageButtons(t, n, o, a, r, E), f && y.default.createElement(x.default, (0, u.default)({}, E, { eventKey: t + 1, disabled: t >= n }), y.default.createElement("span", { "aria-label": "Next" }, f === !0 ? "›" : f)), s && y.default.createElement(x.default, (0, u.default)({}, E, { eventKey: n, disabled: t >= n }), y.default.createElement("span", { "aria-label": "Last" }, s === !0 ? "»" : s)));
			}, t;
		}(y.default.Component);M.propTypes = S, M.defaultProps = N, t.default = (0, O.bsClass)("pagination", M), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(25),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(5),
		    s = o(i),
		    d = n(2),
		    f = o(d),
		    c = n(4),
		    p = o(c),
		    h = n(3),
		    m = o(h),
		    v = n(7),
		    y = o(v),
		    b = n(1),
		    g = o(b),
		    _ = n(8),
		    C = o(_),
		    E = n(56),
		    x = o(E),
		    O = n(9),
		    S = n(12),
		    N = { collapsible: C.default.bool, onSelect: C.default.func, header: C.default.node, id: C.default.oneOfType([C.default.string, C.default.number]), footer: C.default.node, defaultExpanded: C.default.bool, expanded: C.default.bool, eventKey: C.default.any, headerRole: C.default.string, panelRole: C.default.string, onEnter: C.default.func, onEntering: C.default.func, onEntered: C.default.func, onExit: C.default.func, onExiting: C.default.func, onExited: C.default.func },
		    M = { defaultExpanded: !1 },
		    T = function (e) {
			function t(n, o) {
				(0, f.default)(this, t);var a = (0, p.default)(this, e.call(this, n, o));return a.handleClickTitle = a.handleClickTitle.bind(a), a.state = { expanded: a.props.defaultExpanded }, a;
			}return (0, m.default)(t, e), t.prototype.handleClickTitle = function (e) {
				e.persist(), e.selected = !0, this.props.onSelect ? this.props.onSelect(this.props.eventKey, e) : e.preventDefault(), e.selected && this.setState({ expanded: !this.state.expanded });
			}, t.prototype.renderAnchor = function (e, t, n, o) {
				return g.default.createElement("a", { role: n, href: t && "#" + t, onClick: this.handleClickTitle, "aria-controls": t, "aria-expanded": o, "aria-selected": o, className: o ? null : "collapsed" }, e);
			}, t.prototype.renderBody = function (e, t) {
				function n() {
					a.length && (o.push(g.default.createElement("div", { key: o.length, className: l }, a)), a = []);
				}var o = [],
				    a = [],
				    l = (0, O.prefix)(t, "body");return g.default.Children.toArray(e).forEach(function (e) {
					return g.default.isValidElement(e) && e.props.fill ? (n(), void o.push((0, b.cloneElement)(e, { fill: void 0 }))) : void a.push(e);
				}), n(), o;
			}, t.prototype.renderCollapsibleBody = function (e, t, n, o, a, l) {
				return g.default.createElement(x.default, (0, s.default)({ in: t }, l), g.default.createElement("div", { id: e, role: n, className: (0, O.prefix)(a, "collapse"), "aria-hidden": !t }, this.renderBody(o, a)));
			}, t.prototype.renderHeader = function (e, t, n, o, a, l) {
				var r = (0, O.prefix)(l, "title");return e ? g.default.isValidElement(t) ? (0, b.cloneElement)(t, { className: (0, y.default)(t.props.className, r), children: this.renderAnchor(t.props.children, n, o, a) }) : g.default.createElement("h4", { role: "presentation", className: r }, this.renderAnchor(t, n, o, a)) : g.default.isValidElement(t) ? (0, b.cloneElement)(t, { className: (0, y.default)(t.props.className, r) }) : t;
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.collapsible,
				    n = e.header,
				    o = e.id,
				    a = e.footer,
				    l = e.expanded,
				    r = e.headerRole,
				    i = e.panelRole,
				    d = e.className,
				    f = e.children,
				    c = e.onEnter,
				    p = e.onEntering,
				    h = e.onEntered,
				    m = e.onExit,
				    v = e.onExiting,
				    b = e.onExited,
				    _ = (0, u.default)(e, ["collapsible", "header", "id", "footer", "expanded", "headerRole", "panelRole", "className", "children", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited"]),
				    C = (0, O.splitBsPropsAndOmit)(_, ["defaultExpanded", "eventKey", "onSelect"]),
				    E = C[0],
				    x = C[1],
				    S = null != l ? l : this.state.expanded,
				    N = (0, O.getClassSet)(E);return g.default.createElement("div", (0, s.default)({}, x, { className: (0, y.default)(d, N), id: t ? null : o }), n && g.default.createElement("div", { className: (0, O.prefix)(E, "heading") }, this.renderHeader(t, n, o, r, S, E)), t ? this.renderCollapsibleBody(o, S, i, f, E, { onEnter: c, onEntering: p, onEntered: h, onExit: m, onExiting: v, onExited: b }) : this.renderBody(f, E), a && g.default.createElement("div", { className: (0, O.prefix)(E, "footer") }, a));
			}, t;
		}(g.default.Component);T.propTypes = N, T.defaultProps = M, t.default = (0, O.bsClass)("panel", (0, O.bsStyles)([].concat((0, l.default)(S.State), [S.Style.DEFAULT, S.Style.PRIMARY]), S.Style.DEFAULT, T)), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(51),
		    C = o(_),
		    E = n(9),
		    x = { id: (0, C.default)(g.default.oneOfType([g.default.string, g.default.number])), placement: g.default.oneOf(["top", "right", "bottom", "left"]), positionTop: g.default.oneOfType([g.default.number, g.default.string]), positionLeft: g.default.oneOfType([g.default.number, g.default.string]), arrowOffsetTop: g.default.oneOfType([g.default.number, g.default.string]), arrowOffsetLeft: g.default.oneOfType([g.default.number, g.default.string]), title: g.default.node },
		    O = { placement: "right" },
		    S = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e,
				    t = this.props,
				    n = t.placement,
				    o = t.positionTop,
				    a = t.positionLeft,
				    r = t.arrowOffsetTop,
				    i = t.arrowOffsetLeft,
				    s = t.title,
				    d = t.className,
				    f = t.style,
				    c = t.children,
				    p = (0, u.default)(t, ["placement", "positionTop", "positionLeft", "arrowOffsetTop", "arrowOffsetLeft", "title", "className", "style", "children"]),
				    h = (0, E.splitBsProps)(p),
				    v = h[0],
				    b = h[1],
				    g = (0, l.default)({}, (0, E.getClassSet)(v), (e = {}, e[n] = !0, e)),
				    _ = (0, l.default)({ display: "block", top: o, left: a }, f),
				    C = { top: r, left: i };return y.default.createElement("div", (0, l.default)({}, b, { role: "tooltip", className: (0, m.default)(d, g), style: _ }), y.default.createElement("div", { className: "arrow", style: C }), s && y.default.createElement("h3", { className: (0, E.prefix)(v, "title") }, s), y.default.createElement("div", { className: (0, E.prefix)(v, "content") }, c));
			}, t;
		}(y.default.Component);S.propTypes = x, S.defaultProps = O, t.default = (0, E.bsClass)("popover", S), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t, n) {
			var o = e[t];if (!o) return null;var a = null;return C.default.Children.forEach(o, function (e) {
				if (!a && e.type !== k) {
					var t = C.default.isValidElement(e) ? e.type.displayName || e.type.name || e.type : e;a = new Error("Children of " + n + " can contain only ProgressBar " + ("components. Found " + t + "."));
				}
			}), a;
		}function l(e, t, n) {
			var o = (e - t) / (n - t) * 100;return Math.round(o * T) / T;
		}t.__esModule = !0;var r = n(25),
		    u = o(r),
		    i = n(5),
		    s = o(i),
		    d = n(6),
		    f = o(d),
		    c = n(2),
		    p = o(c),
		    h = n(4),
		    m = o(h),
		    v = n(3),
		    y = o(v),
		    b = n(7),
		    g = o(b),
		    _ = n(1),
		    C = o(_),
		    E = n(8),
		    x = o(E),
		    O = n(9),
		    S = n(12),
		    N = n(13),
		    M = o(N),
		    T = 1e3,
		    w = { min: x.default.number, now: x.default.number, max: x.default.number, label: x.default.node, srOnly: x.default.bool, striped: x.default.bool, active: x.default.bool, children: a, isChild: x.default.bool },
		    P = { min: 0, max: 100, active: !1, isChild: !1, srOnly: !1, striped: !1 },
		    k = function (e) {
			function t() {
				return (0, p.default)(this, t), (0, m.default)(this, e.apply(this, arguments));
			}return (0, y.default)(t, e), t.prototype.renderProgressBar = function (e) {
				var t,
				    n = e.min,
				    o = e.now,
				    a = e.max,
				    r = e.label,
				    u = e.srOnly,
				    i = e.striped,
				    d = e.active,
				    c = e.className,
				    p = e.style,
				    h = (0, f.default)(e, ["min", "now", "max", "label", "srOnly", "striped", "active", "className", "style"]),
				    m = (0, O.splitBsProps)(h),
				    v = m[0],
				    y = m[1],
				    b = (0, s.default)({}, (0, O.getClassSet)(v), (t = { active: d }, t[(0, O.prefix)(v, "striped")] = d || i, t));return C.default.createElement("div", (0, s.default)({}, y, { role: "progressbar", className: (0, g.default)(c, b), style: (0, s.default)({ width: l(o, n, a) + "%" }, p), "aria-valuenow": o, "aria-valuemin": n, "aria-valuemax": a }), u ? C.default.createElement("span", { className: "sr-only" }, r) : r);
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.isChild,
				    n = (0, f.default)(e, ["isChild"]);if (t) return this.renderProgressBar(n);var o = n.min,
				    a = n.now,
				    l = n.max,
				    r = n.label,
				    u = n.srOnly,
				    i = n.striped,
				    d = n.active,
				    c = n.bsClass,
				    p = n.bsStyle,
				    h = n.className,
				    m = n.children,
				    v = (0, f.default)(n, ["min", "now", "max", "label", "srOnly", "striped", "active", "bsClass", "bsStyle", "className", "children"]);return C.default.createElement("div", (0, s.default)({}, v, { className: (0, g.default)(h, "progress") }), m ? M.default.map(m, function (e) {
					return (0, _.cloneElement)(e, { isChild: !0 });
				}) : this.renderProgressBar({ min: o, now: a, max: l, label: r, srOnly: u, striped: i, active: d, bsClass: c, bsStyle: p }));
			}, t;
		}(C.default.Component);k.propTypes = w, k.defaultProps = P, t.default = (0, O.bsClass)("progress-bar", (0, O.bsStyles)((0, u.default)(S.State), k)), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(15),
		    C = (o(_), n(9)),
		    E = { inline: g.default.bool, disabled: g.default.bool, title: g.default.string, validationState: g.default.oneOf(["success", "warning", "error", null]), inputRef: g.default.func },
		    x = { inline: !1, disabled: !1, title: "" },
		    O = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.inline,
				    n = e.disabled,
				    o = e.validationState,
				    a = e.inputRef,
				    r = e.className,
				    i = e.style,
				    s = e.title,
				    d = e.children,
				    f = (0, u.default)(e, ["inline", "disabled", "validationState", "inputRef", "className", "style", "title", "children"]),
				    c = (0, C.splitBsProps)(f),
				    p = c[0],
				    h = c[1],
				    v = y.default.createElement("input", (0, l.default)({}, h, { ref: a, type: "radio", disabled: n }));if (t) {
					var b,
					    g = (b = {}, b[(0, C.prefix)(p, "inline")] = !0, b.disabled = n, b);return y.default.createElement("label", { className: (0, m.default)(r, g), style: i, title: s }, v, d);
				}var _ = (0, l.default)({}, (0, C.getClassSet)(p), { disabled: n });return o && (_["has-" + o] = !0), y.default.createElement("div", { className: (0, m.default)(r, _), style: i }, y.default.createElement("label", { title: s }, v, d));
			}, t;
		}(y.default.Component);O.propTypes = E, O.defaultProps = x, t.default = (0, C.bsClass)("radio", O), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(15),
		    C = (o(_), n(9)),
		    E = { children: g.default.element.isRequired, a16by9: g.default.bool, a4by3: g.default.bool },
		    x = { a16by9: !1, a4by3: !1 },
		    O = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e,
				    t = this.props,
				    n = t.a16by9,
				    o = t.a4by3,
				    a = t.className,
				    r = t.children,
				    i = (0, u.default)(t, ["a16by9", "a4by3", "className", "children"]),
				    s = (0, C.splitBsProps)(i),
				    d = s[0],
				    f = s[1],
				    c = (0, l.default)({}, (0, C.getClassSet)(d), (e = {}, e[(0, C.prefix)(d, "16by9")] = n, e[(0, C.prefix)(d, "4by3")] = o, e));return y.default.createElement("div", { className: (0, m.default)(c) }, (0, v.cloneElement)(r, (0, l.default)({}, f, { className: (0, m.default)(a, (0, C.prefix)(d, "item")) })));
			}, t;
		}(y.default.Component);O.propTypes = E, O.defaultProps = x, t.default = (0, C.bsClass)("embed-responsive", O), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(10),
		    g = o(b),
		    _ = n(9),
		    C = { componentClass: g.default },
		    E = { componentClass: "div" },
		    x = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.componentClass,
				    n = e.className,
				    o = (0, u.default)(e, ["componentClass", "className"]),
				    a = (0, _.splitBsProps)(o),
				    r = a[0],
				    i = a[1],
				    s = (0, _.getClassSet)(r);return y.default.createElement(t, (0, l.default)({}, i, { className: (0, m.default)(n, s) }));
			}, t;
		}(y.default.Component);x.propTypes = C, x.defaultProps = E, t.default = (0, _.bsClass)("row", x), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(6),
		    l = o(a),
		    r = n(2),
		    u = o(r),
		    i = n(4),
		    s = o(i),
		    d = n(3),
		    f = o(d),
		    c = n(5),
		    p = o(c),
		    h = n(1),
		    m = o(h),
		    v = n(8),
		    y = o(v),
		    b = n(32),
		    g = o(b),
		    _ = n(40),
		    C = o(_),
		    E = n(174),
		    x = o(E),
		    O = n(43),
		    S = o(O),
		    N = (0, p.default)({}, C.default.propTypes, { bsStyle: y.default.string, bsSize: y.default.string, href: y.default.string, onClick: y.default.func, title: y.default.node.isRequired, toggleLabel: y.default.string, children: y.default.node }),
		    M = function (e) {
			function t() {
				return (0, u.default)(this, t), (0, s.default)(this, e.apply(this, arguments));
			}return (0, f.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.bsSize,
				    n = e.bsStyle,
				    o = e.title,
				    a = e.toggleLabel,
				    r = e.children,
				    u = (0, l.default)(e, ["bsSize", "bsStyle", "title", "toggleLabel", "children"]),
				    i = (0, S.default)(u, C.default.ControlledComponent),
				    s = i[0],
				    d = i[1];return m.default.createElement(C.default, (0, p.default)({}, s, { bsSize: t, bsStyle: n }), m.default.createElement(g.default, (0, p.default)({}, d, { disabled: u.disabled, bsSize: t, bsStyle: n }), o), m.default.createElement(x.default, { "aria-label": a || o, bsSize: t, bsStyle: n }), m.default.createElement(C.default.Menu, null, r));
			}, t;
		}(m.default.Component);M.propTypes = N, M.Toggle = x.default, t.default = M, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(2),
		    u = o(r),
		    i = n(4),
		    s = o(i),
		    d = n(3),
		    f = o(d),
		    c = n(1),
		    p = o(c),
		    h = n(80),
		    m = o(h),
		    v = function (e) {
			function t() {
				return (0, u.default)(this, t), (0, s.default)(this, e.apply(this, arguments));
			}return (0, f.default)(t, e), t.prototype.render = function () {
				return p.default.createElement(m.default, (0, l.default)({}, this.props, { useAnchor: !1, noCaret: !1 }));
			}, t;
		}(p.default.Component);v.defaultProps = m.default.defaultProps, t.default = v, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(2),
		    l = o(a),
		    r = n(4),
		    u = o(r),
		    i = n(3),
		    s = o(i),
		    d = n(5),
		    f = o(d),
		    c = n(1),
		    p = o(c),
		    h = n(8),
		    m = o(h),
		    v = n(58),
		    y = o(v),
		    b = n(59),
		    g = o(b),
		    _ = n(94),
		    C = o(_),
		    E = (0, f.default)({}, C.default.propTypes, { disabled: m.default.bool, title: m.default.node, tabClassName: m.default.string }),
		    x = function (e) {
			function t() {
				return (0, l.default)(this, t), (0, u.default)(this, e.apply(this, arguments));
			}return (0, s.default)(t, e), t.prototype.render = function () {
				var e = (0, f.default)({}, this.props);return delete e.title, delete e.disabled, delete e.tabClassName, p.default.createElement(C.default, e);
			}, t;
		}(p.default.Component);x.propTypes = E, x.Container = y.default, x.Content = g.default, x.Pane = C.default, t.default = x, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(9),
		    C = { striped: g.default.bool, bordered: g.default.bool, condensed: g.default.bool, hover: g.default.bool, responsive: g.default.bool },
		    E = { bordered: !1, condensed: !1, hover: !1, responsive: !1, striped: !1 },
		    x = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e,
				    t = this.props,
				    n = t.striped,
				    o = t.bordered,
				    a = t.condensed,
				    r = t.hover,
				    i = t.responsive,
				    s = t.className,
				    d = (0, u.default)(t, ["striped", "bordered", "condensed", "hover", "responsive", "className"]),
				    f = (0, _.splitBsProps)(d),
				    c = f[0],
				    p = f[1],
				    h = (0, l.default)({}, (0, _.getClassSet)(c), (e = {}, e[(0, _.prefix)(c, "striped")] = n, e[(0, _.prefix)(c, "bordered")] = o, e[(0, _.prefix)(c, "condensed")] = a, e[(0, _.prefix)(c, "hover")] = r, e)),
				    v = y.default.createElement("table", (0, l.default)({}, p, { className: (0, m.default)(s, h) }));return i ? y.default.createElement("div", { className: (0, _.prefix)(c, "responsive") }, v) : v;
			}, t;
		}(y.default.Component);x.propTypes = C, x.defaultProps = E, t.default = (0, _.bsClass)("table", x), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e) {
			var t = void 0;return R.default.forEach(e, function (e) {
				null == t && (t = e.props.eventKey);
			}), t;
		}t.__esModule = !0;var l = n(5),
		    r = o(l),
		    u = n(6),
		    i = o(u),
		    s = n(2),
		    d = o(s),
		    f = n(4),
		    c = o(f),
		    p = n(3),
		    h = o(p),
		    m = n(1),
		    v = o(m),
		    y = n(8),
		    b = o(y),
		    g = n(51),
		    _ = o(g),
		    C = n(39),
		    E = o(C),
		    x = n(87),
		    O = o(x),
		    S = n(88),
		    N = o(S),
		    M = n(58),
		    T = o(M),
		    w = n(59),
		    P = o(w),
		    k = n(9),
		    A = n(13),
		    R = o(A),
		    I = T.default.ControlledComponent,
		    L = { activeKey: b.default.any, bsStyle: b.default.oneOf(["tabs", "pills"]), animation: b.default.bool, id: (0, _.default)(b.default.oneOfType([b.default.string, b.default.number])), onSelect: b.default.func, mountOnEnter: b.default.bool, unmountOnExit: b.default.bool },
		    D = { bsStyle: "tabs", animation: !0, mountOnEnter: !1, unmountOnExit: !1 },
		    j = function (e) {
			function t() {
				return (0, d.default)(this, t), (0, c.default)(this, e.apply(this, arguments));
			}return (0, h.default)(t, e), t.prototype.renderTab = function (e) {
				var t = e.props,
				    n = t.title,
				    o = t.eventKey,
				    a = t.disabled,
				    l = t.tabClassName;return null == n ? null : v.default.createElement(N.default, { eventKey: o, disabled: a, className: l }, n);
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.id,
				    n = e.onSelect,
				    o = e.animation,
				    l = e.mountOnEnter,
				    u = e.unmountOnExit,
				    s = e.bsClass,
				    d = e.className,
				    f = e.style,
				    c = e.children,
				    p = e.activeKey,
				    h = void 0 === p ? a(c) : p,
				    m = (0, i.default)(e, ["id", "onSelect", "animation", "mountOnEnter", "unmountOnExit", "bsClass", "className", "style", "children", "activeKey"]);return v.default.createElement(I, { id: t, activeKey: h, onSelect: n, className: d, style: f }, v.default.createElement("div", null, v.default.createElement(O.default, (0, r.default)({}, m, { role: "tablist" }), R.default.map(c, this.renderTab)), v.default.createElement(P.default, { bsClass: s, animation: o, mountOnEnter: l, unmountOnExit: u }, c)));
			}, t;
		}(v.default.Component);j.propTypes = L, j.defaultProps = D, (0, k.bsClass)("tab", j), t.default = (0, E.default)(j, { activeKey: "onSelect" }), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(16),
		    C = o(_),
		    E = n(9),
		    x = { src: g.default.string, alt: g.default.string, href: g.default.string, onError: g.default.func, onLoad: g.default.func },
		    O = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.src,
				    n = e.alt,
				    o = e.onError,
				    a = e.onLoad,
				    r = e.className,
				    i = e.children,
				    s = (0, u.default)(e, ["src", "alt", "onError", "onLoad", "className", "children"]),
				    d = (0, E.splitBsProps)(s),
				    f = d[0],
				    c = d[1],
				    p = c.href ? C.default : "div",
				    h = (0, E.getClassSet)(f);return y.default.createElement(p, (0, l.default)({}, c, { className: (0, m.default)(r, h) }), y.default.createElement("img", { src: t, alt: n, onError: o, onLoad: a }), i && y.default.createElement("div", { className: "caption" }, i));
			}, t;
		}(y.default.Component);O.propTypes = x, t.default = (0, E.bsClass)("thumbnail", O), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(8),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(48),
		    g = o(b),
		    _ = n(39),
		    C = o(_),
		    E = n(11),
		    x = o(E),
		    O = n(13),
		    S = o(O),
		    N = n(54),
		    M = o(N),
		    T = n(95),
		    w = o(T),
		    P = { name: m.default.string, value: m.default.any, onChange: m.default.func, type: m.default.oneOf(["checkbox", "radio"]).isRequired },
		    k = { type: "radio" },
		    A = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.getValues = function () {
				var e = this.props.value;return null == e ? [] : [].concat(e);
			}, t.prototype.handleToggle = function (e) {
				var t = this.props,
				    n = t.type,
				    o = t.onChange,
				    a = this.getValues(),
				    l = a.indexOf(e) !== -1;return "radio" === n ? void (l || o(e)) : void o(l ? a.filter(function (t) {
					return t !== e;
				}) : [].concat(a, [e]));
			}, t.prototype.render = function () {
				var e = this,
				    t = this.props,
				    n = t.children,
				    o = t.type,
				    a = t.name,
				    r = (0, u.default)(t, ["children", "type", "name"]),
				    i = this.getValues();return "radio" !== o || a ? void 0 : (0, g.default)(!1), delete r.onChange, delete r.value, y.default.createElement(M.default, (0, l.default)({}, r, { "data-toggle": "buttons" }), S.default.map(n, function (t) {
					var n = t.props,
					    l = n.value,
					    r = n.onChange,
					    u = function u() {
						return e.handleToggle(l);
					};return y.default.cloneElement(t, { type: o, name: t.name || a, checked: i.indexOf(l) !== -1, onChange: (0, x.default)(r, u) });
				}));
			}, t;
		}(y.default.Component);A.propTypes = P, A.defaultProps = k;var R = (0, C.default)(A, { value: "onChange" });R.Button = w.default, t.default = R, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(8),
		    g = o(b),
		    _ = n(51),
		    C = o(_),
		    E = n(9),
		    x = { id: (0, C.default)(g.default.oneOfType([g.default.string, g.default.number])), placement: g.default.oneOf(["top", "right", "bottom", "left"]), positionTop: g.default.oneOfType([g.default.number, g.default.string]), positionLeft: g.default.oneOfType([g.default.number, g.default.string]), arrowOffsetTop: g.default.oneOfType([g.default.number, g.default.string]), arrowOffsetLeft: g.default.oneOfType([g.default.number, g.default.string]) },
		    O = { placement: "right" },
		    S = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e,
				    t = this.props,
				    n = t.placement,
				    o = t.positionTop,
				    a = t.positionLeft,
				    r = t.arrowOffsetTop,
				    i = t.arrowOffsetLeft,
				    s = t.className,
				    d = t.style,
				    f = t.children,
				    c = (0, u.default)(t, ["placement", "positionTop", "positionLeft", "arrowOffsetTop", "arrowOffsetLeft", "className", "style", "children"]),
				    p = (0, E.splitBsProps)(c),
				    h = p[0],
				    v = p[1],
				    b = (0, l.default)({}, (0, E.getClassSet)(h), (e = {}, e[n] = !0, e)),
				    g = (0, l.default)({ top: o, left: a }, d),
				    _ = { top: r, left: i };return y.default.createElement("div", (0, l.default)({}, v, { role: "tooltip", className: (0, m.default)(s, b), style: g }), y.default.createElement("div", { className: (0, E.prefix)(h, "arrow"), style: _ }), y.default.createElement("div", { className: (0, E.prefix)(h, "inner") }, f));
			}, t;
		}(y.default.Component);S.propTypes = x, S.defaultProps = O, t.default = (0, E.bsClass)("tooltip", S), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}t.__esModule = !0;var a = n(5),
		    l = o(a),
		    r = n(6),
		    u = o(r),
		    i = n(2),
		    s = o(i),
		    d = n(4),
		    f = o(d),
		    c = n(3),
		    p = o(c),
		    h = n(7),
		    m = o(h),
		    v = n(1),
		    y = o(v),
		    b = n(9),
		    g = n(12),
		    _ = function (e) {
			function t() {
				return (0, s.default)(this, t), (0, f.default)(this, e.apply(this, arguments));
			}return (0, p.default)(t, e), t.prototype.render = function () {
				var e = this.props,
				    t = e.className,
				    n = (0, u.default)(e, ["className"]),
				    o = (0, b.splitBsProps)(n),
				    a = o[0],
				    r = o[1],
				    i = (0, b.getClassSet)(a);return y.default.createElement("div", (0, l.default)({}, r, { className: (0, m.default)(t, i) }));
			}, t;
		}(y.default.Component);t.default = (0, b.bsClass)("well", (0, b.bsSizes)([g.Size.LARGE, g.Size.SMALL], _)), e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a() {
			for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) {
				t[n] = arguments[n];
			}return (0, u.default)(function (e, n, o) {
				var a = void 0;return t.every(function (t) {
					return !!s.default.some(e.children, function (e) {
						return e.props.bsRole === t;
					}) || (a = t, !1);
				}), a ? new Error("(children) " + o + " - Missing a required child with bsRole: " + (a + ". " + o + " must have at least one child of each of ") + ("the following bsRoles: " + t.join(", "))) : null;
			});
		}function l() {
			for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) {
				t[n] = arguments[n];
			}return (0, u.default)(function (e, n, o) {
				var a = void 0;return t.every(function (t) {
					var n = s.default.filter(e.children, function (e) {
						return e.props.bsRole === t;
					});return !(n.length > 1) || (a = t, !1);
				}), a ? new Error("(children) " + o + " - Duplicate children detected of bsRole: " + (a + ". Only one child each allowed with the following ") + ("bsRoles: " + t.join(", "))) : null;
			});
		}t.__esModule = !0, t.requiredRoles = a, t.exclusiveRoles = l;var r = n(52),
		    u = o(r),
		    i = n(13),
		    s = o(i);
	}, function (e, t) {
		"use strict";
		function n() {
			var e = document.createElement("div"),
			    t = e.style;"AnimationEvent" in window || delete r.animationend.animation, "TransitionEvent" in window || delete r.transitionend.transition;for (var n in r) {
				var o = r[n];for (var a in o) {
					if (a in t) {
						u.push(o[a]);break;
					}
				}
			}
		}function o(e, t, n) {
			e.addEventListener(t, n, !1);
		}function a(e, t, n) {
			e.removeEventListener(t, n, !1);
		}t.__esModule = !0;var l = !("undefined" == typeof window || !window.document || !window.document.createElement),
		    r = { transitionend: { transition: "transitionend", WebkitTransition: "webkitTransitionEnd", MozTransition: "mozTransitionEnd", OTransition: "oTransitionEnd", msTransition: "MSTransitionEnd" }, animationend: { animation: "animationend", WebkitAnimation: "webkitAnimationEnd", MozAnimation: "mozAnimationEnd", OAnimation: "oAnimationEnd", msAnimation: "MSAnimationEnd" } },
		    u = [];l && n();var i = { addEndEventListener: function addEndEventListener(e, t) {
				return 0 === u.length ? void window.setTimeout(t, 0) : void u.forEach(function (n) {
					o(e, n, t);
				});
			}, removeEndEventListener: function removeEndEventListener(e, t) {
				0 !== u.length && u.forEach(function (n) {
					a(e, n, t);
				});
			} };t.default = i, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t, n) {
			var o = void 0;"object" === ("undefined" == typeof e ? "undefined" : (0, p.default)(e)) ? o = e.message : (o = e + " is deprecated. Use " + t + " instead.", n && (o += "\nYou can read more about it at " + n)), m[o] || (m[o] = !0);
		}function l() {
			m = {};
		}t.__esModule = !0;var r = n(2),
		    u = o(r),
		    i = n(4),
		    s = o(i),
		    d = n(3),
		    f = o(d),
		    c = n(60),
		    p = o(c);t._resetWarned = l;var h = n(15),
		    m = (o(h), {});a.wrapper = function (e) {
			for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++) {
				n[o - 1] = arguments[o];
			}return function (e) {
				function t() {
					return (0, u.default)(this, t), (0, s.default)(this, e.apply(this, arguments));
				}return (0, f.default)(t, e), t.prototype.componentWillMount = function () {
					if (a.apply(void 0, n), e.prototype.componentWillMount) {
						for (var t, o = arguments.length, l = Array(o), r = 0; r < o; r++) {
							l[r] = arguments[r];
						}(t = e.prototype.componentWillMount).call.apply(t, [this].concat(l));
					}
				}, t;
			}(e);
		}, t.default = a;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e) {
			if (e && e.__esModule) return e;var t = {};if (null != e) for (var n in e) {
				Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
			}return t.default = e, t;
		}t.__esModule = !0, t.ValidComponentChildren = t.createChainedFunction = t.bootstrapUtils = void 0;var l = n(9),
		    r = a(l),
		    u = n(11),
		    i = o(u),
		    s = n(13),
		    d = o(s);t.bootstrapUtils = r, t.createChainedFunction = i.default, t.ValidComponentChildren = d.default;
	}, function (e, t, n) {
		e.exports = { default: n(191), __esModule: !0 };
	}, function (e, t, n) {
		e.exports = { default: n(193), __esModule: !0 };
	}, function (e, t, n) {
		e.exports = { default: n(195), __esModule: !0 };
	}, function (e, t, n) {
		e.exports = { default: n(197), __esModule: !0 };
	}, function (e, t, n) {
		e.exports = { default: n(198), __esModule: !0 };
	}, function (e, t, n) {
		n(109), n(221), e.exports = n(17).Array.from;
	}, function (e, t, n) {
		n(223), e.exports = n(17).Object.assign;
	}, function (e, t, n) {
		n(224);var o = n(17).Object;e.exports = function (e, t) {
			return o.create(e, t);
		};
	}, function (e, t, n) {
		n(228), e.exports = n(17).Object.entries;
	}, function (e, t, n) {
		n(225), e.exports = n(17).Object.setPrototypeOf;
	}, function (e, t, n) {
		n(229), e.exports = n(17).Object.values;
	}, function (e, t, n) {
		n(227), n(226), n(230), n(231), e.exports = n(17).Symbol;
	}, function (e, t, n) {
		n(109), n(232), e.exports = n(75).f("iterator");
	}, function (e, t) {
		e.exports = function (e) {
			if ("function" != typeof e) throw TypeError(e + " is not a function!");return e;
		};
	}, function (e, t) {
		e.exports = function () {};
	}, function (e, t, n) {
		var o = n(24),
		    a = n(108),
		    l = n(219);e.exports = function (e) {
			return function (t, n, r) {
				var u,
				    i = o(t),
				    s = a(i.length),
				    d = l(r, s);if (e && n != n) {
					for (; s > d;) {
						if (u = i[d++], u != u) return !0;
					}
				} else for (; s > d; d++) {
					if ((e || d in i) && i[d] === n) return e || d || 0;
				}return !e && -1;
			};
		};
	}, function (e, t, n) {
		var o = n(61),
		    a = n(18)("toStringTag"),
		    l = "Arguments" == o(function () {
			return arguments;
		}()),
		    r = function r(e, t) {
			try {
				return e[t];
			} catch (e) {}
		};e.exports = function (e) {
			var t, n, u;return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = r(t = Object(e), a)) ? n : l ? o(t) : "Object" == (u = o(t)) && "function" == typeof t.callee ? "Arguments" : u;
		};
	}, function (e, t, n) {
		"use strict";
		var o = n(23),
		    a = n(38);e.exports = function (e, t, n) {
			t in e ? o.f(e, t, a(0, n)) : e[t] = n;
		};
	}, function (e, t, n) {
		var o = n(36),
		    a = n(67),
		    l = n(37);e.exports = function (e) {
			var t = o(e),
			    n = a.f;if (n) for (var r, u = n(e), i = l.f, s = 0; u.length > s;) {
				i.call(e, r = u[s++]) && t.push(r);
			}return t;
		};
	}, function (e, t, n) {
		var o = n(20).document;e.exports = o && o.documentElement;
	}, function (e, t, n) {
		var o = n(35),
		    a = n(18)("iterator"),
		    l = Array.prototype;e.exports = function (e) {
			return void 0 !== e && (o.Array === e || l[a] === e);
		};
	}, function (e, t, n) {
		var o = n(61);e.exports = Array.isArray || function (e) {
			return "Array" == o(e);
		};
	}, function (e, t, n) {
		var o = n(26);e.exports = function (e, t, n, a) {
			try {
				return a ? t(o(n)[0], n[1]) : t(n);
			} catch (t) {
				var l = e.return;throw void 0 !== l && o(l.call(e)), t;
			}
		};
	}, function (e, t, n) {
		"use strict";
		var o = n(66),
		    a = n(38),
		    l = n(68),
		    r = {};n(28)(r, n(18)("iterator"), function () {
			return this;
		}), e.exports = function (e, t, n) {
			e.prototype = o(r, { next: a(1, n) }), l(e, t + " Iterator");
		};
	}, function (e, t, n) {
		var o = n(18)("iterator"),
		    a = !1;try {
			var l = [7][o]();l.return = function () {
				a = !0;
			}, Array.from(l, function () {
				throw 2;
			});
		} catch (e) {}e.exports = function (e, t) {
			if (!t && !a) return !1;var n = !1;try {
				var l = [7],
				    r = l[o]();r.next = function () {
					return { done: n = !0 };
				}, l[o] = function () {
					return r;
				}, e(l);
			} catch (e) {}return n;
		};
	}, function (e, t) {
		e.exports = function (e, t) {
			return { value: t, done: !!e };
		};
	}, function (e, t, n) {
		var o = n(44)("meta"),
		    a = n(34),
		    l = n(22),
		    r = n(23).f,
		    u = 0,
		    i = Object.isExtensible || function () {
			return !0;
		},
		    s = !n(33)(function () {
			return i(Object.preventExtensions({}));
		}),
		    d = function d(e) {
			r(e, o, { value: { i: "O" + ++u, w: {} } });
		},
		    f = function f(e, t) {
			if (!a(e)) return "symbol" == (typeof e === "undefined" ? "undefined" : _typeof(e)) ? e : ("string" == typeof e ? "S" : "P") + e;if (!l(e, o)) {
				if (!i(e)) return "F";if (!t) return "E";d(e);
			}return e[o].i;
		},
		    c = function c(e, t) {
			if (!l(e, o)) {
				if (!i(e)) return !0;if (!t) return !1;d(e);
			}return e[o].w;
		},
		    p = function p(e) {
			return s && h.NEED && i(e) && !l(e, o) && d(e), e;
		},
		    h = e.exports = { KEY: o, NEED: !1, fastKey: f, getWeak: c, onFreeze: p };
	}, function (e, t, n) {
		"use strict";
		var o = n(36),
		    a = n(67),
		    l = n(37),
		    r = n(72),
		    u = n(101),
		    i = Object.assign;e.exports = !i || n(33)(function () {
			var e = {},
			    t = {},
			    n = Symbol(),
			    o = "abcdefghijklmnopqrst";return e[n] = 7, o.split("").forEach(function (e) {
				t[e] = e;
			}), 7 != i({}, e)[n] || Object.keys(i({}, t)).join("") != o;
		}) ? function (e, t) {
			for (var n = r(e), i = arguments.length, s = 1, d = a.f, f = l.f; i > s;) {
				for (var c, p = u(arguments[s++]), h = d ? o(p).concat(d(p)) : o(p), m = h.length, v = 0; m > v;) {
					f.call(p, c = h[v++]) && (n[c] = p[c]);
				}
			}return n;
		} : i;
	}, function (e, t, n) {
		var o = n(23),
		    a = n(26),
		    l = n(36);e.exports = n(27) ? Object.defineProperties : function (e, t) {
			a(e);for (var n, r = l(t), u = r.length, i = 0; u > i;) {
				o.f(e, n = r[i++], t[n]);
			}return e;
		};
	}, function (e, t, n) {
		var o = n(24),
		    a = n(104).f,
		    l = {}.toString,
		    r = "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
		    u = function u(e) {
			try {
				return a(e);
			} catch (e) {
				return r.slice();
			}
		};e.exports.f = function (e) {
			return r && "[object Window]" == l.call(e) ? u(e) : a(o(e));
		};
	}, function (e, t, n) {
		var o = n(22),
		    a = n(72),
		    l = n(69)("IE_PROTO"),
		    r = Object.prototype;e.exports = Object.getPrototypeOf || function (e) {
			return e = a(e), o(e, l) ? e[l] : "function" == typeof e.constructor && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? r : null;
		};
	}, function (e, t, n) {
		var o = n(34),
		    a = n(26),
		    l = function l(e, t) {
			if (a(e), !o(t) && null !== t) throw TypeError(t + ": can't set as prototype!");
		};e.exports = { set: Object.setPrototypeOf || ("__proto__" in {} ? function (e, t, o) {
				try {
					o = n(62)(Function.call, n(103).f(Object.prototype, "__proto__").set, 2), o(e, []), t = !(e instanceof Array);
				} catch (e) {
					t = !0;
				}return function (e, n) {
					return l(e, n), t ? e.__proto__ = n : o(e, n), e;
				};
			}({}, !1) : void 0), check: l };
	}, function (e, t, n) {
		var o = n(71),
		    a = n(63);e.exports = function (e) {
			return function (t, n) {
				var l,
				    r,
				    u = String(a(t)),
				    i = o(n),
				    s = u.length;return i < 0 || i >= s ? e ? "" : void 0 : (l = u.charCodeAt(i), l < 55296 || l > 56319 || i + 1 === s || (r = u.charCodeAt(i + 1)) < 56320 || r > 57343 ? e ? u.charAt(i) : l : e ? u.slice(i, i + 2) : (l - 55296 << 10) + (r - 56320) + 65536);
			};
		};
	}, function (e, t, n) {
		var o = n(71),
		    a = Math.max,
		    l = Math.min;e.exports = function (e, t) {
			return e = o(e), e < 0 ? a(e + t, 0) : l(e, t);
		};
	}, function (e, t, n) {
		var o = n(202),
		    a = n(18)("iterator"),
		    l = n(35);e.exports = n(17).getIteratorMethod = function (e) {
			if (void 0 != e) return e[a] || e["@@iterator"] || l[o(e)];
		};
	}, function (e, t, n) {
		"use strict";
		var o = n(62),
		    a = n(19),
		    l = n(72),
		    r = n(208),
		    u = n(206),
		    i = n(108),
		    s = n(203),
		    d = n(220);a(a.S + a.F * !n(210)(function (e) {
			Array.from(e);
		}), "Array", { from: function from(e) {
				var t,
				    n,
				    a,
				    f,
				    c = l(e),
				    p = "function" == typeof this ? this : Array,
				    h = arguments.length,
				    m = h > 1 ? arguments[1] : void 0,
				    v = void 0 !== m,
				    y = 0,
				    b = d(c);if (v && (m = o(m, h > 2 ? arguments[2] : void 0, 2)), void 0 == b || p == Array && u(b)) for (t = i(c.length), n = new p(t); t > y; y++) {
					s(n, y, v ? m(c[y], y) : c[y]);
				} else for (f = b.call(c), n = new p(); !(a = f.next()).done; y++) {
					s(n, y, v ? r(f, m, [a.value, y], !0) : a.value);
				}return n.length = y, n;
			} });
	}, function (e, t, n) {
		"use strict";
		var o = n(200),
		    a = n(211),
		    l = n(35),
		    r = n(24);e.exports = n(102)(Array, "Array", function (e, t) {
			this._t = r(e), this._i = 0, this._k = t;
		}, function () {
			var e = this._t,
			    t = this._k,
			    n = this._i++;return !e || n >= e.length ? (this._t = void 0, a(1)) : "keys" == t ? a(0, n) : "values" == t ? a(0, e[n]) : a(0, [n, e[n]]);
		}, "values"), l.Arguments = l.Array, o("keys"), o("values"), o("entries");
	}, function (e, t, n) {
		var o = n(19);o(o.S + o.F, "Object", { assign: n(213) });
	}, function (e, t, n) {
		var o = n(19);o(o.S, "Object", { create: n(66) });
	}, function (e, t, n) {
		var o = n(19);o(o.S, "Object", { setPrototypeOf: n(217).set });
	}, function (e, t) {}, function (e, t, n) {
		"use strict";
		var o = n(20),
		    a = n(22),
		    l = n(27),
		    r = n(19),
		    u = n(107),
		    i = n(212).KEY,
		    s = n(33),
		    d = n(70),
		    f = n(68),
		    c = n(44),
		    p = n(18),
		    h = n(75),
		    m = n(74),
		    v = n(204),
		    y = n(207),
		    b = n(26),
		    g = n(24),
		    _ = n(73),
		    C = n(38),
		    E = n(66),
		    x = n(215),
		    O = n(103),
		    S = n(23),
		    N = n(36),
		    M = O.f,
		    T = S.f,
		    w = x.f,
		    _P = o.Symbol,
		    k = o.JSON,
		    A = k && k.stringify,
		    R = "prototype",
		    I = p("_hidden"),
		    L = p("toPrimitive"),
		    D = {}.propertyIsEnumerable,
		    j = d("symbol-registry"),
		    B = d("symbols"),
		    K = d("op-symbols"),
		    F = Object[R],
		    H = "function" == typeof _P,
		    U = o.QObject,
		    z = !U || !U[R] || !U[R].findChild,
		    W = l && s(function () {
			return 7 != E(T({}, "a", { get: function get() {
					return T(this, "a", { value: 7 }).a;
				} })).a;
		}) ? function (e, t, n) {
			var o = M(F, t);o && delete F[t], T(e, t, n), o && e !== F && T(F, t, o);
		} : T,
		    $ = function $(e) {
			var t = B[e] = E(_P[R]);return t._k = e, t;
		},
		    G = H && "symbol" == _typeof(_P.iterator) ? function (e) {
			return "symbol" == (typeof e === "undefined" ? "undefined" : _typeof(e));
		} : function (e) {
			return e instanceof _P;
		},
		    V = function V(e, t, n) {
			return e === F && V(K, t, n), b(e), t = _(t, !0), b(n), a(B, t) ? (n.enumerable ? (a(e, I) && e[I][t] && (e[I][t] = !1), n = E(n, { enumerable: C(0, !1) })) : (a(e, I) || T(e, I, C(1, {})), e[I][t] = !0), W(e, t, n)) : T(e, t, n);
		},
		    q = function q(e, t) {
			b(e);for (var n, o = v(t = g(t)), a = 0, l = o.length; l > a;) {
				V(e, n = o[a++], t[n]);
			}return e;
		},
		    Y = function Y(e, t) {
			return void 0 === t ? E(e) : q(E(e), t);
		},
		    X = function X(e) {
			var t = D.call(this, e = _(e, !0));return !(this === F && a(B, e) && !a(K, e)) && (!(t || !a(this, e) || !a(B, e) || a(this, I) && this[I][e]) || t);
		},
		    Z = function Z(e, t) {
			if (e = g(e), t = _(t, !0), e !== F || !a(B, t) || a(K, t)) {
				var n = M(e, t);return !n || !a(B, t) || a(e, I) && e[I][t] || (n.enumerable = !0), n;
			}
		},
		    J = function J(e) {
			for (var t, n = w(g(e)), o = [], l = 0; n.length > l;) {
				a(B, t = n[l++]) || t == I || t == i || o.push(t);
			}return o;
		},
		    Q = function Q(e) {
			for (var t, n = e === F, o = w(n ? K : g(e)), l = [], r = 0; o.length > r;) {
				!a(B, t = o[r++]) || n && !a(F, t) || l.push(B[t]);
			}return l;
		};H || (_P = function P() {
			if (this instanceof _P) throw TypeError("Symbol is not a constructor!");var e = c(arguments.length > 0 ? arguments[0] : void 0),
			    t = function t(n) {
				this === F && t.call(K, n), a(this, I) && a(this[I], e) && (this[I][e] = !1), W(this, e, C(1, n));
			};return l && z && W(F, e, { configurable: !0, set: t }), $(e);
		}, u(_P[R], "toString", function () {
			return this._k;
		}), O.f = Z, S.f = V, n(104).f = x.f = J, n(37).f = X, n(67).f = Q, l && !n(65) && u(F, "propertyIsEnumerable", X, !0), h.f = function (e) {
			return $(p(e));
		}), r(r.G + r.W + r.F * !H, { Symbol: _P });for (var ee = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), te = 0; ee.length > te;) {
			p(ee[te++]);
		}for (var ne = N(p.store), oe = 0; ne.length > oe;) {
			m(ne[oe++]);
		}r(r.S + r.F * !H, "Symbol", { for: function _for(e) {
				return a(j, e += "") ? j[e] : j[e] = _P(e);
			}, keyFor: function keyFor(e) {
				if (!G(e)) throw TypeError(e + " is not a symbol!");for (var t in j) {
					if (j[t] === e) return t;
				}
			}, useSetter: function useSetter() {
				z = !0;
			}, useSimple: function useSimple() {
				z = !1;
			} }), r(r.S + r.F * !H, "Object", { create: Y, defineProperty: V, defineProperties: q, getOwnPropertyDescriptor: Z, getOwnPropertyNames: J, getOwnPropertySymbols: Q }), k && r(r.S + r.F * (!H || s(function () {
			var e = _P();return "[null]" != A([e]) || "{}" != A({ a: e }) || "{}" != A(Object(e));
		})), "JSON", { stringify: function stringify(e) {
				if (void 0 !== e && !G(e)) {
					for (var t, n, o = [e], a = 1; arguments.length > a;) {
						o.push(arguments[a++]);
					}return t = o[1], "function" == typeof t && (n = t), !n && y(t) || (t = function t(e, _t3) {
						if (n && (_t3 = n.call(this, e, _t3)), !G(_t3)) return _t3;
					}), o[1] = t, A.apply(k, o);
				}
			} }), _P[R][L] || n(28)(_P[R], L, _P[R].valueOf), f(_P, "Symbol"), f(Math, "Math", !0), f(o.JSON, "JSON", !0);
	}, function (e, t, n) {
		var o = n(19),
		    a = n(106)(!0);o(o.S, "Object", { entries: function entries(e) {
				return a(e);
			} });
	}, function (e, t, n) {
		var o = n(19),
		    a = n(106)(!1);o(o.S, "Object", { values: function values(e) {
				return a(e);
			} });
	}, function (e, t, n) {
		n(74)("asyncIterator");
	}, function (e, t, n) {
		n(74)("observable");
	}, function (e, t, n) {
		n(222);for (var o = n(20), a = n(28), l = n(35), r = n(18)("toStringTag"), u = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), i = 0; i < u.length; i++) {
			var s = u[i],
			    d = o[s],
			    f = d && d.prototype;f && !f[r] && a(f, r, s), l[s] = l.Array;
		}
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			e.classList ? e.classList.add(t) : (0, r.default)(e) || (e.className = e.className + " " + t);
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;var l = n(111),
		    r = o(l);e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.hasClass = t.removeClass = t.addClass = void 0;var a = n(233),
		    l = o(a),
		    r = n(235),
		    u = o(r),
		    i = n(111),
		    s = o(i);t.addClass = l.default, t.removeClass = u.default, t.hasClass = s.default, t.default = { addClass: l.default, removeClass: u.default, hasClass: s.default };
	}, function (e, t) {
		"use strict";
		e.exports = function (e, t) {
			e.classList ? e.classList.remove(t) : e.className = e.className.replace(new RegExp("(^|\\s)" + t + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
		};
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			return function (n) {
				var o = n.currentTarget,
				    a = n.target,
				    l = (0, i.default)(o, e);l.some(function (e) {
					return (0, r.default)(e, a);
				}) && t.call(this, n);
			};
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;var l = n(30),
		    r = o(l),
		    u = n(241),
		    i = o(u);e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.listen = t.filter = t.off = t.on = void 0;var a = n(45),
		    l = o(a),
		    r = n(76),
		    u = o(r),
		    i = n(236),
		    s = o(i),
		    d = n(238),
		    f = o(d);t.on = l.default, t.off = u.default, t.filter = s.default, t.listen = f.default, t.default = { on: l.default, off: u.default, filter: s.default, listen: f.default };
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}Object.defineProperty(t, "__esModule", { value: !0 });var a = n(21),
		    l = o(a),
		    r = n(45),
		    u = o(r),
		    i = n(76),
		    s = o(i),
		    d = function d() {};l.default && (d = function d(e, t, n, o) {
			return (0, u.default)(e, t, n, o), function () {
				(0, s.default)(e, t, n, o);
			};
		}), t.default = d, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e) {
			return e.nodeName && e.nodeName.toLowerCase();
		}function l(e) {
			for (var t = (0, u.default)(e), n = e && e.offsetParent; n && "html" !== a(e) && "static" === (0, s.default)(n, "position");) {
				n = n.offsetParent;
			}return n || t.documentElement;
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = l;var r = n(29),
		    u = o(r),
		    i = n(47),
		    s = o(i);e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e) {
			return e.nodeName && e.nodeName.toLowerCase();
		}function l(e, t) {
			var n,
			    o = { top: 0, left: 0 };return "fixed" === (0, v.default)(e, "position") ? n = e.getBoundingClientRect() : (t = t || (0, d.default)(e), n = (0, i.default)(e), "html" !== a(t) && (o = (0, i.default)(t)), o.top += parseInt((0, v.default)(t, "borderTopWidth"), 10) - (0, c.default)(t) || 0, o.left += parseInt((0, v.default)(t, "borderLeftWidth"), 10) - (0, h.default)(t) || 0), r({}, n, { top: n.top - o.top - (parseInt((0, v.default)(e, "marginTop"), 10) || 0), left: n.left - o.left - (parseInt((0, v.default)(e, "marginLeft"), 10) || 0) });
		}Object.defineProperty(t, "__esModule", { value: !0 });var r = Object.assign || function (e) {
			for (var t = 1; t < arguments.length; t++) {
				var n = arguments[t];for (var o in n) {
					Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
				}
			}return e;
		};t.default = l;var u = n(112),
		    i = o(u),
		    s = n(239),
		    d = o(s),
		    f = n(113),
		    c = o(f),
		    p = n(242),
		    h = o(p),
		    m = n(47),
		    v = o(m);e.exports = t.default;
	}, function (e, t) {
		"use strict";
		function n(e, t) {
			var n,
			    l = "#" === t[0],
			    r = "." === t[0],
			    u = l || r ? t.slice(1) : t,
			    i = o.test(u);return i ? l ? (e = e.getElementById ? e : document, (n = e.getElementById(u)) ? [n] : []) : a(e.getElementsByClassName && r ? e.getElementsByClassName(u) : e.getElementsByTagName(t)) : a(e.querySelectorAll(t));
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = n;var o = /^[\w-]*$/,
		    a = Function.prototype.bind.call(Function.prototype.call, [].slice);e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			var n = (0, r.default)(e);return void 0 === t ? n ? "pageXOffset" in n ? n.pageXOffset : n.document.documentElement.scrollLeft : e.scrollLeft : void (n ? n.scrollTo(t, "pageYOffset" in n ? n.pageYOffset : n.document.documentElement.scrollTop) : e.scrollLeft = t);
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;var l = n(46),
		    r = o(l);e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e) {
			if (!e) throw new TypeError("No Element passed to `getComputedStyle()`");var t = e.ownerDocument;return "defaultView" in t ? t.defaultView.opener ? e.ownerDocument.defaultView.getComputedStyle(e, null) : window.getComputedStyle(e, null) : { getPropertyValue: function getPropertyValue(t) {
					var n = e.style;t = (0, r.default)(t), "float" == t && (t = "styleFloat");var o = e.currentStyle[t] || null;if (null == o && n && n[t] && (o = n[t]), i.test(o) && !u.test(t)) {
						var a = n.left,
						    l = e.runtimeStyle,
						    s = l && l.left;s && (l.left = e.currentStyle.left), n.left = "fontSize" === t ? "1em" : o, o = n.pixelLeft + "px", n.left = a, s && (l.left = s);
					}return o;
				} };
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;var l = n(115),
		    r = o(l),
		    u = /^(top|right|bottom|left)$/,
		    i = /^([+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|))(?!px)[a-z%]+$/i;e.exports = t.default;
	}, function (e, t) {
		"use strict";
		function n(e, t) {
			return "removeProperty" in e.style ? e.style.removeProperty(t) : e.style.removeAttribute(t);
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = n, e.exports = t.default;
	}, function (e, t) {
		"use strict";
		function n(e) {
			return !(!e || !o.test(e));
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = n;var o = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i;e.exports = t.default;
	}, function (e, t) {
		"use strict";
		function n(e) {
			return e.replace(o, function (e, t) {
				return t.toUpperCase();
			});
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = n;var o = /-(.)/g;e.exports = t.default;
	}, function (e, t) {
		"use strict";
		function n(e) {
			return e.replace(o, "-$1").toLowerCase();
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = n;var o = /([A-Z])/g;e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e) {
			return (0, r.default)(e).replace(u, "-ms-");
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;var l = n(247),
		    r = o(l),
		    u = /^ms-/;e.exports = t.default;
	}, function (e, t) {
		"use strict";
		function n(e) {
			return function () {
				return e;
			};
		}var o = function o() {};o.thatReturns = n, o.thatReturnsFalse = n(!1), o.thatReturnsTrue = n(!0), o.thatReturnsNull = n(null), o.thatReturnsThis = function () {
			return this;
		}, o.thatReturnsArgument = function (e) {
			return e;
		}, e.exports = o;
	}, function (e, t, n) {
		"use strict";
		function o(e, t, n, o, l, r, u, i) {
			if (a(t), !e) {
				var s;if (void 0 === t) s = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else {
					var d = [n, o, l, r, u, i],
					    f = 0;s = new Error(t.replace(/%s/g, function () {
						return d[f++];
					})), s.name = "Invariant Violation";
				}throw s.framesToPop = 1, s;
			}
		}var a = function a(e) {};e.exports = o;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			return function (n, o, a, l, r) {
				var s = a || "<<anonymous>>",
				    d = r || o;if (null != n[o]) {
					var f = a + "." + o;(0, u.default)(i[f], "The " + l + " `" + d + "` of " + ("`" + s + "` is deprecated. " + t + ".")), i[f] = !0;
				}for (var c = arguments.length, p = Array(c > 5 ? c - 5 : 0), h = 5; h < c; h++) {
					p[h - 5] = arguments[h];
				}return e.apply(void 0, [n, o, a, l, r].concat(p));
			};
		}function l() {
			i = {};
		}Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;var r = n(15),
		    u = o(r),
		    i = {};a._resetWarned = l, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		var o = n(249),
		    a = n(250),
		    l = n(253);e.exports = function () {
			function e(e, t, n, o, r, u) {
				u !== l && a(!1, "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
			}function t() {
				return e;
			}e.isRequired = e;var n = { array: e, bool: e, func: e, number: e, object: e, string: e, symbol: e, any: e, arrayOf: t, element: e, instanceOf: t, node: e, objectOf: t, oneOf: t, oneOfType: t, shape: t, exact: t };return n.checkPropTypes = o, n.PropTypes = n, n;
		};
	}, function (e, t) {
		"use strict";
		var n = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";e.exports = n;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
		}function l(e, t) {
			if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
		}function r(e, t) {
			if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
		}t.__esModule = !0;var u = n(8),
		    i = o(u),
		    s = n(50),
		    d = o(s),
		    f = n(1),
		    c = o(f),
		    p = n(14),
		    h = o(p),
		    m = n(53),
		    v = o(m),
		    y = n(31),
		    b = o(y),
		    g = function (e) {
			function t() {
				var n, o, r;a(this, t);for (var u = arguments.length, i = Array(u), s = 0; s < u; s++) {
					i[s] = arguments[s];
				}return n = o = l(this, e.call.apply(e, [this].concat(i))), o._mountOverlayTarget = function () {
					o._overlayTarget || (o._overlayTarget = document.createElement("div"), o._portalContainerNode = (0, v.default)(o.props.container, (0, b.default)(o).body), o._portalContainerNode.appendChild(o._overlayTarget));
				}, o._unmountOverlayTarget = function () {
					o._overlayTarget && (o._portalContainerNode.removeChild(o._overlayTarget), o._overlayTarget = null), o._portalContainerNode = null;
				}, o._renderOverlay = function () {
					var e = o.props.children ? c.default.Children.only(o.props.children) : null;if (null !== e) {
						o._mountOverlayTarget();var t = !o._overlayInstance;o._overlayInstance = h.default.unstable_renderSubtreeIntoContainer(o, e, o._overlayTarget, function () {
							t && o.props.onRendered && o.props.onRendered();
						});
					} else o._unrenderOverlay(), o._unmountOverlayTarget();
				}, o._unrenderOverlay = function () {
					o._overlayTarget && (h.default.unmountComponentAtNode(o._overlayTarget), o._overlayInstance = null);
				}, o.getMountNode = function () {
					return o._overlayTarget;
				}, r = n, l(o, r);
			}return r(t, e), t.prototype.componentDidMount = function () {
				this._isMounted = !0, this._renderOverlay();
			}, t.prototype.componentDidUpdate = function () {
				this._renderOverlay();
			}, t.prototype.componentWillReceiveProps = function (e) {
				this._overlayTarget && e.container !== this.props.container && (this._portalContainerNode.removeChild(this._overlayTarget), this._portalContainerNode = (0, v.default)(e.container, (0, b.default)(this).body), this._portalContainerNode.appendChild(this._overlayTarget));
			}, t.prototype.componentWillUnmount = function () {
				this._isMounted = !1, this._unrenderOverlay(), this._unmountOverlayTarget();
			}, t.prototype.render = function () {
				return null;
			}, t;
		}(c.default.Component);g.displayName = "Portal", g.propTypes = { container: i.default.oneOfType([d.default, i.default.func]), onRendered: i.default.func }, t.default = g, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
		}function l(e, t) {
			if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
		}function r(e, t) {
			if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
		}t.__esModule = !0;var u = Object.assign || function (e) {
			for (var t = 1; t < arguments.length; t++) {
				var n = arguments[t];for (var o in n) {
					Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
				}
			}return e;
		},
		    i = n(110),
		    s = o(i),
		    d = n(30),
		    f = o(d),
		    c = n(21),
		    p = o(c),
		    h = n(8),
		    m = o(h),
		    v = n(50),
		    y = o(v),
		    b = n(251),
		    g = o(b),
		    _ = n(10),
		    C = o(_),
		    E = n(1),
		    x = o(E),
		    O = n(14),
		    S = o(O),
		    N = n(15),
		    M = o(N),
		    T = n(256),
		    w = o(T),
		    P = n(117),
		    k = o(P),
		    A = n(259),
		    R = o(A),
		    I = n(120),
		    L = o(I),
		    D = n(260),
		    j = o(D),
		    B = n(53),
		    K = o(B),
		    F = n(31),
		    H = o(F),
		    U = new w.default(),
		    z = function (e) {
			function t() {
				var n, o, r;a(this, t);for (var u = arguments.length, i = Array(u), s = 0; s < u; s++) {
					i[s] = arguments[s];
				}return n = o = l(this, e.call.apply(e, [this].concat(i))), W.call(o), r = n, l(o, r);
			}return r(t, e), t.prototype.omitProps = function (e, t) {
				var n = Object.keys(e),
				    o = {};return n.map(function (n) {
					Object.prototype.hasOwnProperty.call(t, n) || (o[n] = e[n]);
				}), o;
			}, t.prototype.render = function () {
				var e = this.props,
				    n = e.show,
				    o = e.container,
				    a = e.children,
				    l = e.transition,
				    r = e.backdrop,
				    i = e.dialogTransitionTimeout,
				    s = e.className,
				    d = e.style,
				    f = e.onExit,
				    c = e.onExiting,
				    p = e.onEnter,
				    h = e.onEntering,
				    m = e.onEntered,
				    v = x.default.Children.only(a),
				    y = this.omitProps(this.props, t.propTypes),
				    b = n || l && !this.state.exited;if (!b) return null;var g = v.props,
				    _ = g.role,
				    C = g.tabIndex;return void 0 !== _ && void 0 !== C || (v = (0, E.cloneElement)(v, { role: void 0 === _ ? "document" : _, tabIndex: null == C ? "-1" : C })), l && (v = x.default.createElement(l, { transitionAppear: !0, unmountOnExit: !0, in: n, timeout: i, onExit: f, onExiting: c, onExited: this.handleHidden, onEnter: p, onEntering: h, onEntered: m }, v)), x.default.createElement(k.default, { ref: this.setMountNode, container: o, onRendered: this.onPortalRendered }, x.default.createElement("div", u({ ref: this.setModalNodeRef, role: _ || "dialog" }, y, { style: d, className: s }), r && this.renderBackdrop(), x.default.createElement(R.default, { ref: this.setDialogRef }, v)));
			}, t.prototype.componentWillReceiveProps = function (e) {
				e.show ? this.setState({ exited: !1 }) : e.transition || this.setState({ exited: !0 });
			}, t.prototype.componentWillUpdate = function (e) {
				!this.props.show && e.show && this.checkForFocus();
			}, t.prototype.componentDidMount = function () {
				this._isMounted = !0, this.props.show && this.onShow();
			}, t.prototype.componentDidUpdate = function (e) {
				var t = this.props.transition;!e.show || this.props.show || t ? !e.show && this.props.show && this.onShow() : this.onHide();
			}, t.prototype.componentWillUnmount = function () {
				var e = this.props,
				    t = e.show,
				    n = e.transition;this._isMounted = !1, (t || n && !this.state.exited) && this.onHide();
			}, t.prototype.autoFocus = function () {
				if (this.props.autoFocus) {
					var e = this.getDialogElement(),
					    t = (0, s.default)((0, H.default)(this));e && !(0, f.default)(e, t) && (this.lastFocus = t, e.hasAttribute("tabIndex") || ((0, M.default)(!1, 'The modal content node does not accept focus. For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'), e.setAttribute("tabIndex", -1)), e.focus());
				}
			}, t.prototype.restoreLastFocus = function () {
				this.lastFocus && this.lastFocus.focus && (this.lastFocus.focus(), this.lastFocus = null);
			}, t.prototype.getDialogElement = function () {
				return S.default.findDOMNode(this.dialog);
			}, t.prototype.isTopModal = function () {
				return this.props.manager.isTopModal(this);
			}, t;
		}(x.default.Component);z.propTypes = u({}, k.default.propTypes, { show: m.default.bool, container: m.default.oneOfType([y.default, m.default.func]), onShow: m.default.func, onHide: m.default.func, backdrop: m.default.oneOfType([m.default.bool, m.default.oneOf(["static"])]), renderBackdrop: m.default.func, onEscapeKeyDown: m.default.func, onEscapeKeyUp: (0, g.default)(m.default.func, "Please use onEscapeKeyDown instead for consistency"), onBackdropClick: m.default.func, backdropStyle: m.default.object, backdropClassName: m.default.string, containerClassName: m.default.string, keyboard: m.default.bool, transition: C.default, dialogTransitionTimeout: m.default.number, backdropTransitionTimeout: m.default.number, autoFocus: m.default.bool, enforceFocus: m.default.bool, restoreFocus: m.default.bool, onEnter: m.default.func, onEntering: m.default.func, onEntered: m.default.func, onExit: m.default.func, onExiting: m.default.func, onExited: m.default.func, manager: m.default.object.isRequired }), z.defaultProps = { show: !1, backdrop: !0, keyboard: !0, autoFocus: !0, enforceFocus: !0, restoreFocus: !0, onHide: function onHide() {}, manager: U, renderBackdrop: function renderBackdrop(e) {
				return x.default.createElement("div", e);
			} };var W = function W() {
			var e = this;this.state = { exited: !this.props.show }, this.renderBackdrop = function () {
				var t = e.props,
				    n = t.backdropStyle,
				    o = t.backdropClassName,
				    a = t.renderBackdrop,
				    l = t.transition,
				    r = t.backdropTransitionTimeout,
				    u = function u(t) {
					return e.backdrop = t;
				},
				    i = a({ ref: u, style: n, className: o, onClick: e.handleBackdropClick });return l && (i = x.default.createElement(l, { transitionAppear: !0, in: e.props.show, timeout: r }, i)), i;
			}, this.onPortalRendered = function () {
				e.autoFocus(), e.props.onShow && e.props.onShow();
			}, this.onShow = function () {
				var t = (0, H.default)(e),
				    n = (0, K.default)(e.props.container, t.body);e.props.manager.add(e, n, e.props.containerClassName), e._onDocumentKeydownListener = (0, L.default)(t, "keydown", e.handleDocumentKeyDown), e._onDocumentKeyupListener = (0, L.default)(t, "keyup", e.handleDocumentKeyUp), e._onFocusinListener = (0, j.default)(e.enforceFocus);
			}, this.onHide = function () {
				e.props.manager.remove(e), e._onDocumentKeydownListener.remove(), e._onDocumentKeyupListener.remove(), e._onFocusinListener.remove(), e.props.restoreFocus && e.restoreLastFocus();
			}, this.setMountNode = function (t) {
				e.mountNode = t ? t.getMountNode() : t;
			}, this.setModalNodeRef = function (t) {
				e.modalNode = t;
			}, this.setDialogRef = function (t) {
				e.dialog = t;
			}, this.handleHidden = function () {
				if (e.setState({ exited: !0 }), e.onHide(), e.props.onExited) {
					var t;(t = e.props).onExited.apply(t, arguments);
				}
			}, this.handleBackdropClick = function (t) {
				t.target === t.currentTarget && (e.props.onBackdropClick && e.props.onBackdropClick(t), e.props.backdrop === !0 && e.props.onHide());
			}, this.handleDocumentKeyDown = function (t) {
				e.props.keyboard && 27 === t.keyCode && e.isTopModal() && (e.props.onEscapeKeyDown && e.props.onEscapeKeyDown(t), e.props.onHide());
			}, this.handleDocumentKeyUp = function (t) {
				e.props.keyboard && 27 === t.keyCode && e.isTopModal() && e.props.onEscapeKeyUp && e.props.onEscapeKeyUp(t);
			}, this.checkForFocus = function () {
				p.default && (e.lastFocus = (0, s.default)());
			}, this.enforceFocus = function () {
				if (e.props.enforceFocus && e._isMounted && e.isTopModal()) {
					var t = e.getDialogElement(),
					    n = (0, s.default)((0, H.default)(e));t && !(0, f.default)(t, n) && t.focus();
				}
			};
		};z.Manager = w.default, t.default = z, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
		}function l(e, t) {
			var n = -1;return e.some(function (e, o) {
				if (t(e, o)) return n = o, !0;
			}), n;
		}function r(e, t) {
			return l(e, function (e) {
				return e.modals.indexOf(t) !== -1;
			});
		}function u(e, t) {
			var n = { overflow: "hidden" };e.style = { overflow: t.style.overflow, paddingRight: t.style.paddingRight }, e.overflowing && (n.paddingRight = parseInt((0, c.default)(t, "paddingRight") || 0, 10) + (0, h.default)() + "px"), (0, c.default)(t, n);
		}function i(e, t) {
			var n = e.style;Object.keys(n).forEach(function (e) {
				return t.style[e] = n[e];
			});
		}t.__esModule = !0;var s = n(234),
		    d = o(s),
		    f = n(47),
		    c = o(f),
		    p = n(116),
		    h = o(p),
		    m = n(121),
		    v = o(m),
		    y = n(262),
		    b = function e() {
			var t = this,
			    n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
			    o = n.hideSiblingNodes,
			    l = void 0 === o || o,
			    s = n.handleContainerOverflow,
			    f = void 0 === s || s;a(this, e), this.add = function (e, n, o) {
				var a = t.modals.indexOf(e),
				    l = t.containers.indexOf(n);if (a !== -1) return a;if (a = t.modals.length, t.modals.push(e), t.hideSiblingNodes && (0, y.hideSiblings)(n, e.mountNode), l !== -1) return t.data[l].modals.push(e), a;var r = { modals: [e], classes: o ? o.split(/\s+/) : [], overflowing: (0, v.default)(n) };return t.handleContainerOverflow && u(r, n), r.classes.forEach(d.default.addClass.bind(null, n)), t.containers.push(n), t.data.push(r), a;
			}, this.remove = function (e) {
				var n = t.modals.indexOf(e);if (n !== -1) {
					var o = r(t.data, e),
					    a = t.data[o],
					    l = t.containers[o];a.modals.splice(a.modals.indexOf(e), 1), t.modals.splice(n, 1), 0 === a.modals.length ? (a.classes.forEach(d.default.removeClass.bind(null, l)), t.handleContainerOverflow && i(a, l), t.hideSiblingNodes && (0, y.showSiblings)(l, e.mountNode), t.containers.splice(o, 1), t.data.splice(o, 1)) : t.hideSiblingNodes && (0, y.ariaHidden)(!1, a.modals[a.modals.length - 1].mountNode);
				}
			}, this.isTopModal = function (e) {
				return !!t.modals.length && t.modals[t.modals.length - 1] === e;
			}, this.hideSiblingNodes = l, this.handleContainerOverflow = f, this.modals = [], this.containers = [], this.data = [];
		};t.default = b, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			var n = {};for (var o in e) {
				t.indexOf(o) >= 0 || Object.prototype.hasOwnProperty.call(e, o) && (n[o] = e[o]);
			}return n;
		}function l(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
		}function r(e, t) {
			if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
		}function u(e, t) {
			if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
		}t.__esModule = !0;var i = Object.assign || function (e) {
			for (var t = 1; t < arguments.length; t++) {
				var n = arguments[t];for (var o in n) {
					Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
				}
			}return e;
		},
		    s = n(8),
		    d = o(s),
		    f = n(10),
		    c = o(f),
		    p = n(1),
		    h = o(p),
		    m = n(117),
		    v = o(m),
		    y = n(258),
		    b = o(y),
		    g = n(118),
		    _ = o(g),
		    C = function (e) {
			function t(n, o) {
				l(this, t);var a = r(this, e.call(this, n, o));return a.handleHidden = function () {
					if (a.setState({ exited: !0 }), a.props.onExited) {
						var e;(e = a.props).onExited.apply(e, arguments);
					}
				}, a.state = { exited: !n.show }, a.onHiddenListener = a.handleHidden.bind(a), a;
			}return u(t, e), t.prototype.componentWillReceiveProps = function (e) {
				e.show ? this.setState({ exited: !1 }) : e.transition || this.setState({ exited: !0 });
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.container,
				    n = e.containerPadding,
				    o = e.target,
				    l = e.placement,
				    r = e.shouldUpdatePosition,
				    u = e.rootClose,
				    i = e.children,
				    s = e.transition,
				    d = a(e, ["container", "containerPadding", "target", "placement", "shouldUpdatePosition", "rootClose", "children", "transition"]),
				    f = d.show || s && !this.state.exited;if (!f) return null;var c = i;if (c = h.default.createElement(b.default, { container: t, containerPadding: n, target: o, placement: l, shouldUpdatePosition: r }, c), s) {
					var p = d.onExit,
					    m = d.onExiting,
					    y = d.onEnter,
					    g = d.onEntering,
					    C = d.onEntered;c = h.default.createElement(s, { in: d.show, transitionAppear: !0, onExit: p, onExiting: m, onExited: this.onHiddenListener, onEnter: y, onEntering: g, onEntered: C }, c);
				}return u && (c = h.default.createElement(_.default, { onRootClose: d.onHide }, c)), h.default.createElement(v.default, { container: t }, c);
			}, t;
		}(h.default.Component);C.propTypes = i({}, v.default.propTypes, b.default.propTypes, { show: d.default.bool, rootClose: d.default.bool, onHide: function onHide(e) {
				var t = d.default.func;e.rootClose && (t = t.isRequired);for (var n = arguments.length, o = Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++) {
					o[a - 1] = arguments[a];
				}return t.apply(void 0, [e].concat(o));
			}, transition: c.default, onEnter: d.default.func, onEntering: d.default.func, onEntered: d.default.func, onExit: d.default.func, onExiting: d.default.func, onExited: d.default.func }), t.default = C, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			var n = {};for (var o in e) {
				t.indexOf(o) >= 0 || Object.prototype.hasOwnProperty.call(e, o) && (n[o] = e[o]);
			}return n;
		}function l(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
		}function r(e, t) {
			if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
			return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
		}function u(e, t) {
			if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
		}t.__esModule = !0;var i = Object.assign || function (e) {
			for (var t = 1; t < arguments.length; t++) {
				var n = arguments[t];for (var o in n) {
					Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
				}
			}return e;
		},
		    s = n(7),
		    d = o(s),
		    f = n(8),
		    c = o(f),
		    p = n(50),
		    h = o(p),
		    m = n(1),
		    v = o(m),
		    y = n(14),
		    b = o(y),
		    g = n(261),
		    _ = o(g),
		    C = n(53),
		    E = o(C),
		    x = n(31),
		    O = o(x),
		    S = function (e) {
			function t(n, o) {
				l(this, t);var a = r(this, e.call(this, n, o));return a.getTarget = function () {
					var e = a.props.target,
					    t = "function" == typeof e ? e() : e;return t && b.default.findDOMNode(t) || null;
				}, a.maybeUpdatePosition = function (e) {
					var t = a.getTarget();(a.props.shouldUpdatePosition || t !== a._lastTarget || e) && a.updatePosition(t);
				}, a.state = { positionLeft: 0, positionTop: 0, arrowOffsetLeft: null, arrowOffsetTop: null }, a._needsFlush = !1, a._lastTarget = null, a;
			}return u(t, e), t.prototype.componentDidMount = function () {
				this.updatePosition(this.getTarget());
			}, t.prototype.componentWillReceiveProps = function () {
				this._needsFlush = !0;
			}, t.prototype.componentDidUpdate = function (e) {
				this._needsFlush && (this._needsFlush = !1, this.maybeUpdatePosition(this.props.placement !== e.placement));
			}, t.prototype.render = function () {
				var e = this.props,
				    t = e.children,
				    n = e.className,
				    o = a(e, ["children", "className"]),
				    l = this.state,
				    r = l.positionLeft,
				    u = l.positionTop,
				    s = a(l, ["positionLeft", "positionTop"]);delete o.target, delete o.container, delete o.containerPadding, delete o.shouldUpdatePosition;var f = v.default.Children.only(t);return (0, m.cloneElement)(f, i({}, o, s, { positionLeft: r, positionTop: u, className: (0, d.default)(n, f.props.className), style: i({}, f.props.style, { left: r, top: u }) }));
			}, t.prototype.updatePosition = function (e) {
				if (this._lastTarget = e, !e) return void this.setState({ positionLeft: 0, positionTop: 0, arrowOffsetLeft: null, arrowOffsetTop: null });var t = b.default.findDOMNode(this),
				    n = (0, E.default)(this.props.container, (0, O.default)(this).body);this.setState((0, _.default)(this.props.placement, t, e, n, this.props.containerPadding));
			}, t;
		}(v.default.Component);S.propTypes = { target: c.default.oneOfType([h.default, c.default.func]), container: c.default.oneOfType([h.default, c.default.func]), containerPadding: c.default.number, placement: c.default.oneOf(["top", "right", "bottom", "left"]), shouldUpdatePosition: c.default.bool }, S.displayName = "Position", S.defaultProps = { containerPadding: 0, placement: "right", shouldUpdatePosition: !1 }, t.default = S, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
		}function l(e, t) {
			if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
		}function r(e, t) {
			if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
		}t.__esModule = !0;var u = n(8),
		    i = o(u),
		    s = n(1),
		    d = o(s),
		    f = { children: i.default.node },
		    c = function (e) {
			function t() {
				return a(this, t), l(this, e.apply(this, arguments));
			}return r(t, e), t.prototype.render = function () {
				return this.props.children;
			}, t;
		}(d.default.Component);c.propTypes = f, t.default = c, e.exports = t.default;
	}, function (e, t) {
		"use strict";
		function n(e) {
			var t = !document.addEventListener,
			    n = void 0;return t ? (document.attachEvent("onfocusin", e), n = function n() {
				return document.detachEvent("onfocusin", e);
			}) : (document.addEventListener("focus", e, !0), n = function n() {
				return document.removeEventListener("focus", e, !0);
			}), { remove: n };
		}t.__esModule = !0, t.default = n, e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e) {
			var t = void 0,
			    n = void 0,
			    o = void 0;if ("BODY" === e.tagName) t = window.innerWidth, n = window.innerHeight, o = (0, p.default)((0, m.default)(e).documentElement) || (0, p.default)(e);else {
				var a = (0, s.default)(e);t = a.width, n = a.height, o = (0, p.default)(e);
			}return { width: t, height: n, scroll: o };
		}function l(e, t, n, o) {
			var l = a(n),
			    r = l.scroll,
			    u = l.height,
			    i = e - o - r,
			    s = e + o - r + t;return i < 0 ? -i : s > u ? u - s : 0;
		}function r(e, t, n, o) {
			var l = a(n),
			    r = l.width,
			    u = e - o,
			    i = e + o + t;return u < 0 ? -u : i > r ? r - i : 0;
		}function u(e, t, n, o, a) {
			var u = "BODY" === o.tagName ? (0, s.default)(n) : (0, f.default)(n, o),
			    i = (0, s.default)(t),
			    d = i.height,
			    c = i.width,
			    p = void 0,
			    h = void 0,
			    m = void 0,
			    v = void 0;if ("left" === e || "right" === e) {
				h = u.top + (u.height - d) / 2, p = "left" === e ? u.left - c : u.left + u.width;var y = l(h, d, o, a);h += y, v = 50 * (1 - 2 * y / d) + "%", m = void 0;
			} else {
				if ("top" !== e && "bottom" !== e) throw new Error('calcOverlayPosition(): No such placement of "' + e + '" found.');p = u.left + (u.width - c) / 2, h = "top" === e ? u.top - d : u.top + u.height;var b = r(p, c, o, a);p += b, m = 50 * (1 - 2 * b / c) + "%", v = void 0;
			}return { positionLeft: p, positionTop: h, arrowOffsetLeft: m, arrowOffsetTop: v };
		}t.__esModule = !0, t.default = u;var i = n(112),
		    s = o(i),
		    d = n(240),
		    f = o(d),
		    c = n(113),
		    p = o(c),
		    h = n(31),
		    m = o(h);e.exports = t.default;
	}, function (e, t) {
		"use strict";
		function n(e, t) {
			t && (e ? t.setAttribute("aria-hidden", "true") : t.removeAttribute("aria-hidden"));
		}function o(e, t) {
			u(e, t, function (e) {
				return n(!0, e);
			});
		}function a(e, t) {
			u(e, t, function (e) {
				return n(!1, e);
			});
		}t.__esModule = !0, t.ariaHidden = n, t.hideSiblings = o, t.showSiblings = a;var l = ["template", "script", "style"],
		    r = function r(e) {
			var t = e.nodeType,
			    n = e.tagName;return 1 === t && l.indexOf(n.toLowerCase()) === -1;
		},
		    u = function u(e, t, n) {
			t = [].concat(t), [].forEach.call(e.children, function (e) {
				t.indexOf(e) === -1 && r(e) && n(e);
			});
		};
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			if (e && e.__esModule) return e;var t = {};if (null != e) for (var n in e) {
				Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
			}return t.default = e, t;
		}function a(e) {
			return e && e.__esModule ? e : { default: e };
		}function l(e, t) {
			if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
		}function r(e, t) {
			if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
		}function u(e, t) {
			if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
		}function i(e, t) {
			function n(o, a) {
				function i(e, n) {
					var o = m.getLinkName(e),
					    l = this.props[a[e]];o && d(this.props, o) && !l && (l = this.props[o].requestChange);for (var r = arguments.length, u = Array(r > 2 ? r - 2 : 0), i = 2; i < r; i++) {
						u[i - 2] = arguments[i];
					}t(this, e, l, n, u);
				}function d(e, t) {
					return void 0 !== e[t];
				}function c(e) {
					var t = {};return m.each(e, function (e, n) {
						x.indexOf(n) === -1 && (t[n] = e);
					}), t;
				}var h,
				    v,
				    y,
				    b = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [],
				    g = o.displayName || o.name || "Component",
				    _ = m.getType(o).propTypes,
				    C = m.isReactComponent(o),
				    E = Object.keys(a),
				    x = ["valueLink", "checkedLink"].concat(E.map(m.defaultKey));y = m.uncontrolledPropTypes(a, _, g), (0, p.default)(C || !b.length, "[uncontrollable] stateless function components cannot pass through methods because they have no associated instances. Check component: " + g + ", attempting to pass through methods: " + b.join(", ")), b = m.transform(b, function (e, t) {
					e[t] = function () {
						var e;return (e = this.refs.inner)[t].apply(e, arguments);
					};
				}, {});var O = (v = h = function (t) {
					function n() {
						return l(this, n), r(this, t.apply(this, arguments));
					}return u(n, t), n.prototype.shouldComponentUpdate = function () {
						for (var t = arguments.length, n = Array(t), o = 0; o < t; o++) {
							n[o] = arguments[o];
						}return !e.shouldComponentUpdate || e.shouldComponentUpdate.apply(this, n);
					}, n.prototype.componentWillMount = function () {
						var e = this,
						    t = this.props;this._values = {}, E.forEach(function (n) {
							e._values[n] = t[m.defaultKey(n)];
						});
					}, n.prototype.componentWillReceiveProps = function (t) {
						var n = this,
						    o = this.props;e.componentWillReceiveProps && e.componentWillReceiveProps.call(this, t), E.forEach(function (e) {
							void 0 === m.getValue(t, e) && void 0 !== m.getValue(o, e) && (n._values[e] = t[m.defaultKey(e)]);
						});
					}, n.prototype.componentWillUnmount = function () {
						this.unmounted = !0;
					}, n.prototype.getControlledInstance = function () {
						return this.refs.inner;
					}, n.prototype.render = function () {
						var e = this,
						    t = {},
						    n = c(this.props);return m.each(a, function (n, o) {
							var a = m.getLinkName(o),
							    l = e.props[o];a && !d(e.props, o) && d(e.props, a) && (l = e.props[a].value), t[o] = void 0 !== l ? l : e._values[o], t[n] = i.bind(e, o);
						}), t = s({}, n, t, { ref: C ? "inner" : null }), f.default.createElement(o, t);
					}, n;
				}(f.default.Component), h.displayName = "Uncontrolled(" + g + ")", h.propTypes = y, v);return s(O.prototype, b), O.ControlledComponent = o, O.deferControlTo = function (e) {
					var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
					    o = arguments[2];return n(e, s({}, a, t), o);
				}, O;
			}return n;
		}t.__esModule = !0;var s = Object.assign || function (e) {
			for (var t = 1; t < arguments.length; t++) {
				var n = arguments[t];for (var o in n) {
					Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
				}
			}return e;
		};t.default = i;var d = n(1),
		    f = a(d),
		    c = n(48),
		    p = a(c),
		    h = n(264),
		    m = o(h);e.exports = t.default;
	}, function (e, t, n) {
		"use strict";
		function o(e) {
			return e && e.__esModule ? e : { default: e };
		}function a(e, t, n) {
			var o = {};return o;
		}function l(e) {
			return b[0] >= 15 || 0 === b[0] && b[1] >= 13 ? e : e.type;
		}function r(e, t) {
			var n = i(t);return n && !u(e, t) && u(e, n) ? e[n].value : e[t];
		}function u(e, t) {
			return void 0 !== e[t];
		}function i(e) {
			return "value" === e ? "valueLink" : "checked" === e ? "checkedLink" : null;
		}function s(e) {
			return "default" + e.charAt(0).toUpperCase() + e.substr(1);
		}function d(e, t, n) {
			return function () {
				for (var o = arguments.length, a = Array(o), l = 0; l < o; l++) {
					a[l] = arguments[l];
				}t && t.call.apply(t, [e].concat(a)), n && n.call.apply(n, [e].concat(a));
			};
		}function f(e, t, n) {
			return c(e, t.bind(null, n = n || (Array.isArray(e) ? [] : {}))), n;
		}function c(e, t, n) {
			if (Array.isArray(e)) return e.forEach(t, n);for (var o in e) {
				p(e, o) && t.call(n, e[o], o, e);
			}
		}function p(e, t) {
			return !!e && Object.prototype.hasOwnProperty.call(e, t);
		}function h(e) {
			return !!(e && e.prototype && e.prototype.isReactComponent);
		}t.__esModule = !0, t.version = void 0, t.uncontrolledPropTypes = a, t.getType = l, t.getValue = r, t.getLinkName = i, t.defaultKey = s, t.chain = d, t.transform = f, t.each = c, t.has = p, t.isReactComponent = h;var m = n(1),
		    v = o(m),
		    y = n(48),
		    b = (o(y), t.version = v.default.version.split(".").map(parseFloat));
	}]);
});
//# sourceMappingURL=react-bootstrap.min.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(62)(module)))

/***/ }),

/***/ 61:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ 62:
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ 81:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.1.1
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(0);
var invariant = __webpack_require__(23);
var warning = __webpack_require__(27);
var ExecutionEnvironment = __webpack_require__(83);
var _assign = __webpack_require__(36);
var emptyFunction$1 = __webpack_require__(22);
var EventListener = __webpack_require__(84);
var getActiveElement = __webpack_require__(85);
var shallowEqual = __webpack_require__(49);
var containsNode = __webpack_require__(86);
var focusNode = __webpack_require__(89);
var emptyObject = __webpack_require__(48);
var checkPropTypes = __webpack_require__(37);
var hyphenateStyleName = __webpack_require__(90);
var camelizeStyleName = __webpack_require__(92);

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;

// These attributes should be all lowercase to allow for
// case insensitive checks
var RESERVED_PROPS = {
  children: true,
  dangerouslySetInnerHTML: true,
  defaultValue: true,
  defaultChecked: true,
  innerHTML: true,
  suppressContentEditableWarning: true,
  suppressHydrationWarning: true,
  style: true
};

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
  HAS_STRING_BOOLEAN_VALUE: 0x40,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    for (var propName in Properties) {
      !!properties.hasOwnProperty(propName) ? invariant(false, "injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.", propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),
        hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, "DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s", propName) : void 0;

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];

        propertyInfo.attributeName = attributeName;
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      // Downcase references to whitelist properties to check for membership
      // without case-sensitivity. This allows the whitelist to pick up
      // `allowfullscreen`, which should be written using the property configuration
      // for `allowFullscreen`
      properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
/* eslint-enable max-len */
var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";


var ROOT_ATTRIBUTE_NAME = 'data-reactroot';

/**
 * Map from property "standard name" to an object with info about how to set
 * the property in the DOM. Each object contains:
 *
 * attributeName:
 *   Used when rendering markup or with `*Attribute()`.
 * attributeNamespace
 * propertyName:
 *   Used on DOM node instances. (This includes properties that mutate due to
 *   external factors.)
 * mutationMethod:
 *   If non-null, used instead of the property or `setAttribute()` after
 *   initial render.
 * mustUseProperty:
 *   Whether the property must be accessed and mutated as an object property.
 * hasBooleanValue:
 *   Whether the property should be removed when set to a falsey value.
 * hasNumericValue:
 *   Whether the property must be numeric or parse as a numeric and should be
 *   removed when set to a falsey value.
 * hasPositiveNumericValue:
 *   Whether the property must be positive numeric or parse as a positive
 *   numeric and should be removed when set to a falsey value.
 * hasOverloadedBooleanValue:
 *   Whether the property can be used as a flag as well as with a value.
 *   Removed when strictly equal to false; present without a value when
 *   strictly equal to true; present with a value otherwise.
 */
var properties = {};

/**
 * Checks whether a property name is a writeable attribute.
 * @method
 */
function shouldSetAttribute(name, value) {
  if (isReservedProp(name)) {
    return false;
  }
  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return false;
  }
  if (value === null) {
    return true;
  }
  switch (typeof value) {
    case 'boolean':
      return shouldAttributeAcceptBooleanValue(name);
    case 'undefined':
    case 'number':
    case 'string':
    case 'object':
      return true;
    default:
      // function, symbol
      return false;
  }
}

function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function shouldAttributeAcceptBooleanValue(name) {
  if (isReservedProp(name)) {
    return true;
  }
  var propertyInfo = getPropertyInfo(name);
  if (propertyInfo) {
    return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;
  }
  var prefix = name.toLowerCase().slice(0, 5);
  return prefix === 'data-' || prefix === 'aria-';
}

/**
 * Checks to see if a property name is within the list of properties
 * reserved for internal React operations. These properties should
 * not be set on an HTML element.
 *
 * @private
 * @param {string} name
 * @return {boolean} If the name is within reserved props
 */
function isReservedProp(name) {
  return RESERVED_PROPS.hasOwnProperty(name);
}

var injection = DOMPropertyInjection;

var MUST_USE_PROPERTY = injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = injection.HAS_OVERLOADED_BOOLEAN_VALUE;
var HAS_STRING_BOOLEAN_VALUE = injection.HAS_STRING_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  // When adding attributes to this list, be sure to also add them to
  // the `possibleStandardNames` module to ensure casing and incorrect
  // name warnings.
  Properties: {
    allowFullScreen: HAS_BOOLEAN_VALUE,
    // specifies target context for links with `preload` type
    async: HAS_BOOLEAN_VALUE,
    // Note: there is a special case that prevents it from being written to the DOM
    // on the client side because the browsers are inconsistent. Instead we call focus().
    autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_OVERLOADED_BOOLEAN_VALUE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    contentEditable: HAS_STRING_BOOLEAN_VALUE,
    controls: HAS_BOOLEAN_VALUE,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: HAS_STRING_BOOLEAN_VALUE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    hidden: HAS_BOOLEAN_VALUE,
    loop: HAS_BOOLEAN_VALUE,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    playsInline: HAS_BOOLEAN_VALUE,
    readOnly: HAS_BOOLEAN_VALUE,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    scoped: HAS_BOOLEAN_VALUE,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    start: HAS_NUMERIC_VALUE,
    // support for projecting regular DOM Elements via V1 named slots ( shadow dom )
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: HAS_STRING_BOOLEAN_VALUE,
    // Style must be explicitly set in the attribute list. React components
    // expect a style object
    style: 0,
    // Keep it in the whitelist because it is case-sensitive for SVG.
    tabIndex: 0,
    // itemScope is for for Microdata support.
    // See http://schema.org/docs/gs.html
    itemScope: HAS_BOOLEAN_VALUE,
    // These attributes must stay in the white-list because they have
    // different attribute names (see DOMAttributeNames below)
    acceptCharset: 0,
    className: 0,
    htmlFor: 0,
    httpEquiv: 0,
    // Attributes with mutation methods must be specified in the whitelist
    // Set the string boolean flag to allow the behavior
    value: HAS_STRING_BOOLEAN_VALUE
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMMutationMethods: {
    value: function (node, value) {
      if (value == null) {
        return node.removeAttribute('value');
      }

      // Number inputs get special treatment due to some edge cases in
      // Chrome. Let everything else assign the value attribute as normal.
      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
      if (node.type !== 'number' || node.hasAttribute('value') === false) {
        node.setAttribute('value', '' + value);
      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
        // Don't assign an attribute if validation reports bad
        // input. Chrome will clear the value. Additionally, don't
        // operate on inputs that have focus, otherwise Chrome might
        // strip off trailing decimal places and cause the user's
        // cursor position to jump to the beginning of the input.
        //
        // In ReactDOMInput, we have an onBlur event that will trigger
        // this function again when focus is lost.
        node.setAttribute('value', '' + value);
      }
    }
  }
};

var HAS_STRING_BOOLEAN_VALUE$1 = injection.HAS_STRING_BOOLEAN_VALUE;


var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

/**
 * This is a list of all SVG attributes that need special casing,
 * namespacing, or boolean value assignment.
 *
 * When adding attributes to this list, be sure to also add them to
 * the `possibleStandardNames` module to ensure casing and incorrect
 * name warnings.
 *
 * SVG Attributes List:
 * https://www.w3.org/TR/SVG/attindex.html
 * SMIL Spec:
 * https://www.w3.org/TR/smil
 */
var ATTRS = ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'x-height', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xmlns:xlink', 'xml:lang', 'xml:space'];

var SVGDOMPropertyConfig = {
  Properties: {
    autoReverse: HAS_STRING_BOOLEAN_VALUE$1,
    externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,
    preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1
  },
  DOMAttributeNames: {
    autoReverse: 'autoReverse',
    externalResourcesRequired: 'externalResourcesRequired',
    preserveAlpha: 'preserveAlpha'
  },
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  }
};

var CAMELIZE = /[\-\:]([a-z])/g;
var capitalize = function (token) {
  return token[1].toUpperCase();
};

ATTRS.forEach(function (original) {
  var reactName = original.replace(CAMELIZE, capitalize);

  SVGDOMPropertyConfig.Properties[reactName] = 0;
  SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;
});

injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);

var ReactErrorUtils = {
  // Used by Fiber to simulate a try-catch.
  _caughtError: null,
  _hasCaughtError: false,

  // Used by event system to capture/rethrow the first error.
  _rethrowError: null,
  _hasRethrowError: false,

  injection: {
    injectErrorUtils: function (injectedErrorUtils) {
      !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;
      invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;
    }
  },

  /**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */
  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {
    invokeGuardedCallback.apply(ReactErrorUtils, arguments);
  },

  /**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if _caughtError and _rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */
  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {
    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);
    if (ReactErrorUtils.hasCaughtError()) {
      var error = ReactErrorUtils.clearCaughtError();
      if (!ReactErrorUtils._hasRethrowError) {
        ReactErrorUtils._hasRethrowError = true;
        ReactErrorUtils._rethrowError = error;
      }
    }
  },

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    return rethrowCaughtError.apply(ReactErrorUtils, arguments);
  },

  hasCaughtError: function () {
    return ReactErrorUtils._hasCaughtError;
  },

  clearCaughtError: function () {
    if (ReactErrorUtils._hasCaughtError) {
      var error = ReactErrorUtils._caughtError;
      ReactErrorUtils._caughtError = null;
      ReactErrorUtils._hasCaughtError = false;
      return error;
    } else {
      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');
    }
  }
};

var invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {
  ReactErrorUtils._hasCaughtError = false;
  ReactErrorUtils._caughtError = null;
  var funcArgs = Array.prototype.slice.call(arguments, 3);
  try {
    func.apply(context, funcArgs);
  } catch (error) {
    ReactErrorUtils._caughtError = error;
    ReactErrorUtils._hasCaughtError = true;
  }
};

{
  // In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // "Pause on exceptions" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // untintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
  //
  // To preserve the expected "Pause on exceptions" behavior, we don't use a
  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
  // DOM node, and call the user-provided callback from inside an event handler
  // for that fake event. If the callback throws, the error is "captured" using
  // a global event handler. But because the error happens in a different
  // event loop context, it does not interrupt the normal program flow.
  // Effectively, this gives us try-catch behavior without actually using
  // try-catch. Neat!

  // Check that the browser supports the APIs we need to implement our special
  // DEV version of invokeGuardedCallback
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');

    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {
      // Keeps track of whether the user-provided callback threw an error. We
      // set this to true at the beginning, then set it to false right after
      // calling the function. If the function errors, `didError` will never be
      // set to false. This strategy works even if the browser is flaky and
      // fails to call our global error handler, because it doesn't rely on
      // the error event at all.
      var didError = true;

      // Create an event handler for our fake event. We will synchronously
      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
      // call the user-provided callback.
      var funcArgs = Array.prototype.slice.call(arguments, 3);
      function callCallback() {
        // We immediately remove the callback from event listeners so that
        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
        // nested call would trigger the fake event handlers of any call higher
        // in the stack.
        fakeNode.removeEventListener(evtType, callCallback, false);
        func.apply(context, funcArgs);
        didError = false;
      }

      // Create a global error event handler. We use this to capture the value
      // that was thrown. It's possible that this error handler will fire more
      // than once; for example, if non-React code also calls `dispatchEvent`
      // and a handler for that event throws. We should be resilient to most of
      // those cases. Even if our error event handler fires more than once, the
      // last error event is always used. If the callback actually does error,
      // we know that the last error event is the correct one, because it's not
      // possible for anything else to have happened in between our callback
      // erroring and the code that follows the `dispatchEvent` call below. If
      // the callback doesn't error, but the error event was fired, we know to
      // ignore it because `didError` will be false, as described above.
      var error = void 0;
      // Use this to track whether the error event is ever called.
      var didSetError = false;
      var isCrossOriginError = false;

      function onError(event) {
        error = event.error;
        didSetError = true;
        if (error === null && event.colno === 0 && event.lineno === 0) {
          isCrossOriginError = true;
        }
      }

      // Create a fake event type.
      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');

      // Attach our event handlers
      window.addEventListener('error', onError);
      fakeNode.addEventListener(evtType, callCallback, false);

      // Synchronously dispatch our fake event. If the user-provided function
      // errors, it will trigger our global error handler.
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);

      if (didError) {
        if (!didSetError) {
          // The callback errored, but the error event never fired.
          error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
        } else if (isCrossOriginError) {
          error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');
        }
        ReactErrorUtils._hasCaughtError = true;
        ReactErrorUtils._caughtError = error;
      } else {
        ReactErrorUtils._hasCaughtError = false;
        ReactErrorUtils._caughtError = null;
      }

      // Remove our event listeners
      window.removeEventListener('error', onError);
    };

    invokeGuardedCallback = invokeGuardedCallbackDev;
  }
}

var rethrowCaughtError = function () {
  if (ReactErrorUtils._hasRethrowError) {
    var error = ReactErrorUtils._rethrowError;
    ReactErrorUtils._rethrowError = null;
    ReactErrorUtils._hasRethrowError = false;
    throw error;
  }
};

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;
    if (plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;
    plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;
  eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;
  registrationNameModules[registrationName] = pluginModule;
  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  {
    var lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */

/**
 * Ordered list of injected plugins.
 */
var plugins = [];

/**
 * Mapping from event name to dispatch config
 */
var eventNameDispatchConfigs = {};

/**
 * Mapping from registration name to plugin module
 */
var registrationNameModules = {};

/**
 * Mapping from registration name to event name
 */
var registrationNameDependencies = {};

/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */
var possibleRegistrationNames = {};
// Trust the developer to only use possibleRegistrationNames in true

/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */
function injectEventPluginOrder(injectedEventPluginOrder) {
  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;
  // Clone the ordering so it cannot be dynamically mutated.
  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
  recomputePluginOrdering();
}

/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */
function injectEventPluginsByName(injectedNamesToPlugins) {
  var isOrderingDirty = false;
  for (var pluginName in injectedNamesToPlugins) {
    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
      continue;
    }
    var pluginModule = injectedNamesToPlugins[pluginName];
    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;
      namesToPlugins[pluginName] = pluginModule;
      isOrderingDirty = true;
    }
  }
  if (isOrderingDirty) {
    recomputePluginOrdering();
  }
}

var EventPluginRegistry = Object.freeze({
	plugins: plugins,
	eventNameDispatchConfigs: eventNameDispatchConfigs,
	registrationNameModules: registrationNameModules,
	registrationNameDependencies: registrationNameDependencies,
	possibleRegistrationNames: possibleRegistrationNames,
	injectEventPluginOrder: injectEventPluginOrder,
	injectEventPluginsByName: injectEventPluginsByName
});

var getFiberCurrentPropsFromNode = null;
var getInstanceFromNode = null;
var getNodeFromInstance = null;

var injection$2 = {
  injectComponentTree: function (Injected) {
    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;
    getInstanceFromNode = Injected.getInstanceFromNode;
    getNodeFromInstance = Injected.getNodeFromInstance;

    {
      warning(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');
    }
  }
};






var validateEventDispatches;
{
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = getNodeFromInstance(inst);
  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */


/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */


/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */
function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */

/**
 * Methods for injecting dependencies.
 */
var injection$1 = {
  /**
   * @param {array} InjectedEventPluginOrder
   * @public
   */
  injectEventPluginOrder: injectEventPluginOrder,

  /**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */
  injectEventPluginsByName: injectEventPluginsByName
};

/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */
function getListener(inst, registrationName) {
  var listener;

  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
  // live here; needs to be moved to a better place soon
  var stateNode = inst.stateNode;
  if (!stateNode) {
    // Work in progress (ex: onload events in incremental mode).
    return null;
  }
  var props = getFiberCurrentPropsFromNode(stateNode);
  if (!props) {
    // Work in progress.
    return null;
  }
  listener = props[registrationName];
  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }
  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;
  return listener;
}

/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */
function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  for (var i = 0; i < plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
}

/**
 * Enqueues a synthetic event that should be dispatched when
 * `processEventQueue` is invoked.
 *
 * @param {*} events An accumulation of synthetic events.
 * @internal
 */
function enqueueEvents(events) {
  if (events) {
    eventQueue = accumulateInto(eventQueue, events);
  }
}

/**
 * Dispatches all synthetic events on the event queue.
 *
 * @internal
 */
function processEventQueue(simulated) {
  // Set `eventQueue` to null before processing it so that we can tell if more
  // events get enqueued while processing.
  var processingEventQueue = eventQueue;
  eventQueue = null;
  if (simulated) {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
  } else {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
  }
  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;
  // This would be a good time to rethrow if any of the event handlers threw.
  ReactErrorUtils.rethrowCaughtError();
}

var EventPluginHub = Object.freeze({
	injection: injection$1,
	getListener: getListener,
	extractEvents: extractEvents,
	enqueueEvents: enqueueEvents,
	processEventQueue: processEventQueue
});

var IndeterminateComponent = 0; // Before we know whether it is functional or class
var FunctionalComponent = 1;
var ClassComponent = 2;
var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
var HostComponent = 5;
var HostText = 6;
var CallComponent = 7;
var CallHandlerPhase = 8;
var ReturnComponent = 9;
var Fragment = 10;

var randomKey = Math.random().toString(36).slice(2);
var internalInstanceKey = '__reactInternalInstance$' + randomKey;
var internalEventHandlersKey = '__reactEventHandlers$' + randomKey;

function precacheFiberNode$1(hostInst, node) {
  node[internalInstanceKey] = hostInst;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest = void 0;
  var inst = node[internalInstanceKey];
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber, this will always be the deepest root.
    return inst;
  }
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode$1(node) {
  var inst = node[internalInstanceKey];
  if (inst) {
    if (inst.tag === HostComponent || inst.tag === HostText) {
      return inst;
    } else {
      return null;
    }
  }
  return null;
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance$1(inst) {
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber this, is just the state node right now. We assume it will be
    // a host component or host text.
    return inst.stateNode;
  }

  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  invariant(false, 'getNodeFromInstance: Invalid argument.');
}

function getFiberCurrentPropsFromNode$1(node) {
  return node[internalEventHandlersKey] || null;
}

function updateFiberProps$1(node, props) {
  node[internalEventHandlersKey] = props;
}

var ReactDOMComponentTree = Object.freeze({
	precacheFiberNode: precacheFiberNode$1,
	getClosestInstanceFromNode: getClosestInstanceFromNode,
	getInstanceFromNode: getInstanceFromNode$1,
	getNodeFromInstance: getNodeFromInstance$1,
	getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,
	updateFiberProps: updateFiberProps$1
});

function getParent(inst) {
  do {
    inst = inst['return'];
    // TODO: If this is a HostRoot we might want to bail out.
    // That is depending on if we want nested subtrees (layers) to bubble
    // events to their parent. We could also go through parentNode on the
    // host node but that wouldn't work for React Native and doesn't let us
    // do the portal feature.
  } while (inst && inst.tag !== HostComponent);
  if (inst) {
    return inst;
  }
  return null;
}

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  var depthA = 0;
  for (var tempA = instA; tempA; tempA = getParent(tempA)) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = getParent(tempB)) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = getParent(instA);
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = getParent(instB);
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB || instA === instB.alternate) {
      return instA;
    }
    instA = getParent(instA);
    instB = getParent(instB);
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */


/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  return getParent(inst);
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = getParent(inst);
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (true) {
    if (!from) {
      break;
    }
    if (from === common) {
      break;
    }
    var alternate = from.alternate;
    if (alternate !== null && alternate === common) {
      break;
    }
    pathFrom.push(from);
    from = getParent(from);
  }
  var pathTo = [];
  while (true) {
    if (!to) {
      break;
    }
    if (to === common) {
      break;
    }
    var _alternate = to.alternate;
    if (_alternate !== null && _alternate === common) {
      break;
    }
    pathTo.push(to);
    to = getParent(to);
  }
  for (var i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (var _i = pathTo.length; _i-- > 0;) {
    fn(pathTo[_i], 'captured', argTo);
  }
}

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 */

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  {
    warning(inst, 'Dispatching inst must not be null');
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? getParentInstance(targetInst) : null;
    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (inst && event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

var EventPropagators = Object.freeze({
	accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,
	accumulateDirectDispatches: accumulateDirectDispatches
});

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

/**
 * This helper object stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */
var compositionState = {
  _root: null,
  _startText: null,
  _fallbackText: null
};

function initialize(nativeEventTarget) {
  compositionState._root = nativeEventTarget;
  compositionState._startText = getText();
  return true;
}

function reset() {
  compositionState._root = null;
  compositionState._startText = null;
  compositionState._fallbackText = null;
}

function getData() {
  if (compositionState._fallbackText) {
    return compositionState._fallbackText;
  }

  var start;
  var startValue = compositionState._startText;
  var startLength = startValue.length;
  var end;
  var endValue = getText();
  var endLength = endValue.length;

  for (start = 0; start < startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;
  for (end = 1; end <= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end > 1 ? 1 - end : undefined;
  compositionState._fallbackText = endValue.slice(start, sliceTail);
  return compositionState._fallbackText;
}

function getText() {
  if ('value' in compositionState._root) {
    return compositionState._root.value;
  }
  return compositionState._root[getTextContentAccessor()];
}

/* eslint valid-typeof: 0 */

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';
var EVENT_POOL_SIZE = 10;

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction$1.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction$1.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction$1.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction$1.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {
  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction$1.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction$1.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction$1.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction$1.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction$1));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction$1));
    }
  }
});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;
  addEventPoolingTo(Class);
};

/** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 */
{
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}

addEventPoolingTo(SyntheticEvent);

/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);
  }
}

function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
  var EventConstructor = this;
  if (EventConstructor.eventPool.length) {
    var instance = EventConstructor.eventPool.pop();
    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
    return instance;
  }
  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
}

function releasePooledEvent(event) {
  var EventConstructor = this;
  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;
  event.destructor();
  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
    EventConstructor.eventPool.push(event);
  }
}

function addEventPoolingTo(EventConstructor) {
  EventConstructor.eventPool = [];
  EventConstructor.getPooled = getPooledEvent;
  EventConstructor.release = releasePooledEvent;
}

var SyntheticEvent$1 = SyntheticEvent;

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticInputEvent, InputEventInterface);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition status, if any.
var isComposing = false;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!isComposing) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!isComposing && eventType === eventTypes.compositionStart) {
      isComposing = initialize(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (isComposing) {
        fallbackData = getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (isComposing) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = getData();
      reset();
      isComposing = false;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (!isKeypressCommand(nativeEvent)) {
        // IE fires the `keypress` event when a user types an emoji via
        // Touch keyboard of Windows.  In such a case, the `char` property
        // holds an emoji character like `\uD83D\uDE0A`.  Because its length
        // is 2, the property `which` does not represent an emoji correctly.
        // In such a case, we directly return the `char` property instead of
        // using `which`.
        if (nativeEvent.char && nativeEvent.char.length > 1) {
          return nativeEvent.char;
        } else if (nativeEvent.which) {
          return String.fromCharCode(nativeEvent.which);
        }
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

// Use to restore controlled state after a change event has fired.

var fiberHostComponent = null;

var ReactControlledComponentInjection = {
  injectFiberControlledHostComponent: function (hostComponentImpl) {
    // The fiber implementation doesn't use dynamic dispatch so we need to
    // inject the implementation.
    fiberHostComponent = hostComponentImpl;
  }
};

var restoreTarget = null;
var restoreQueue = null;

function restoreStateOfTarget(target) {
  // We perform this translation at the end of the event loop so that we
  // always receive the correct fiber here
  var internalInstance = getInstanceFromNode(target);
  if (!internalInstance) {
    // Unmounted
    return;
  }
  !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
  fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);
}

var injection$3 = ReactControlledComponentInjection;

function enqueueStateRestore(target) {
  if (restoreTarget) {
    if (restoreQueue) {
      restoreQueue.push(target);
    } else {
      restoreQueue = [target];
    }
  } else {
    restoreTarget = target;
  }
}

function restoreStateIfNeeded() {
  if (!restoreTarget) {
    return;
  }
  var target = restoreTarget;
  var queuedTargets = restoreQueue;
  restoreTarget = null;
  restoreQueue = null;

  restoreStateOfTarget(target);
  if (queuedTargets) {
    for (var i = 0; i < queuedTargets.length; i++) {
      restoreStateOfTarget(queuedTargets[i]);
    }
  }
}

var ReactControlledComponent = Object.freeze({
	injection: injection$3,
	enqueueStateRestore: enqueueStateRestore,
	restoreStateIfNeeded: restoreStateIfNeeded
});

// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.

// Defaults
var fiberBatchedUpdates = function (fn, bookkeeping) {
  return fn(bookkeeping);
};

var isNestingBatched = false;
function batchedUpdates(fn, bookkeeping) {
  if (isNestingBatched) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state. Therefore, we add the target to
    // a queue of work.
    return fiberBatchedUpdates(fn, bookkeeping);
  }
  isNestingBatched = true;
  try {
    return fiberBatchedUpdates(fn, bookkeeping);
  } finally {
    // Here we wait until all updates have propagated, which is important
    // when using controlled components within layers:
    // https://github.com/facebook/react/issues/1698
    // Then we restore state of any controlled component.
    isNestingBatched = false;
    restoreStateIfNeeded();
  }
}

var ReactGenericBatchingInjection = {
  injectFiberBatchedUpdates: function (_batchedUpdates) {
    fiberBatchedUpdates = _batchedUpdates;
  }
};

var injection$4 = ReactGenericBatchingInjection;

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

/**
 * HTML nodeType values that represent the type of the node
 */

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === TEXT_NODE ? target.parentNode : target;
}

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(node) {
  return node._valueTracker;
}

function detachTracker(node) {
  node._valueTracker = null;
}

function getValueFromNode(node) {
  var value = '';
  if (!node) {
    return value;
  }

  if (isCheckable(node)) {
    value = node.checked ? 'true' : 'false';
  } else {
    value = node.value;
  }

  return value;
}

function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? 'checked' : 'value';
  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

  var currentValue = '' + node[valueField];

  // if someone has already defined a value or Safari, then bail
  // and don't track value will cause over reporting of changes,
  // but it's better then a hard failure
  // (needed for certain tests that spyOn input values and Safari)
  if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
    return;
  }

  Object.defineProperty(node, valueField, {
    enumerable: descriptor.enumerable,
    configurable: true,
    get: function () {
      return descriptor.get.call(this);
    },
    set: function (value) {
      currentValue = '' + value;
      descriptor.set.call(this, value);
    }
  });

  var tracker = {
    getValue: function () {
      return currentValue;
    },
    setValue: function (value) {
      currentValue = '' + value;
    },
    stopTracking: function () {
      detachTracker(node);
      delete node[valueField];
    }
  };
  return tracker;
}

function track(node) {
  if (getTracker(node)) {
    return;
  }

  // TODO: Once it's just Fiber we can move this to node._wrapperState
  node._valueTracker = trackValueOnNode(node);
}

function updateValueIfChanged(node) {
  if (!node) {
    return false;
  }

  var tracker = getTracker(node);
  // if there is no tracker at this point it's unlikely
  // that trying again will succeed
  if (!tracker) {
    return true;
  }

  var lastValue = tracker.getValue();
  var nextValue = getValueFromNode(node);
  if (nextValue !== lastValue) {
    tracker.setValue(nextValue);
    return true;
  }
  return false;
}

var eventTypes$1 = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
  var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);
  event.type = 'change';
  // Flag this event loop as needing state restore.
  enqueueStateRestore(target);
  accumulateTwoPhaseDispatches(event);
  return event;
}
/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  enqueueEvents(event);
  processEventQueue(false);
}

function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance$1(targetInst);
  if (updateValueIfChanged(targetNode)) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
}

/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onpropertychange', handlePropertyChange);
  activeElement = null;
  activeElementInst = null;
}

/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  if (getInstIfValueChanged(activeElementInst)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst);
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === 'topClick') {
    return getInstIfValueChanged(targetInst);
  }
}

function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topInput' || topLevelType === 'topChange') {
    return getInstIfValueChanged(targetInst);
  }
}

function handleControlledInputBlur(inst, node) {
  // TODO: In IE, inst is occasionally null. Why?
  if (inst == null) {
    return;
  }

  // Fiber and ReactDOM keep wrapper state in separate places
  var state = inst._wrapperState || node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  // If controlled, assign the value attribute to the current value on blur
  var value = '' + node.value;
  if (node.getAttribute('value') !== value) {
    node.setAttribute('value', value);
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {
  eventTypes: eventTypes$1,

  _isInputEventSupported: isInputEventSupported,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForChangeEvent;
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventPolyfill;
        handleEventFunc = handleEventsForInputEventPolyfill;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }

    // When blurring, set the value attribute for number inputs
    if (topLevelType === 'topBlur') {
      handleControlledInputBlur(targetInst, targetNode);
    }
  }
};

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: null,
  detail: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticUIEvent, UIEventInterface);

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  pageX: null,
  pageY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: null,
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

var eventTypes$2 = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {
  eventTypes: eventTypes$2,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : getNodeFromInstance$1(from);
    var toNode = to == null ? win : getNodeFromInstance$1(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }
};

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */

/**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */


function get(key) {
  return key._reactInternalFiber;
}

function has(key) {
  return key._reactInternalFiber !== undefined;
}

function set(key, value) {
  key._reactInternalFiber = value;
}

var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'string') {
    return type;
  }
  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  return null;
}

// Don't change these two values:
var NoEffect = 0; //           0b00000000
var PerformedWork = 1; //      0b00000001

// You can change the rest (and add more).
var Placement = 2; //          0b00000010
var Update = 4; //             0b00000100
var PlacementAndUpdate = 6; // 0b00000110
var Deletion = 8; //           0b00001000
var ContentReset = 16; //      0b00010000
var Callback = 32; //          0b00100000
var Err = 64; //               0b01000000
var Ref = 128; //              0b10000000

var MOUNTING = 1;
var MOUNTED = 2;
var UNMOUNTED = 3;

function isFiberMountedImpl(fiber) {
  var node = fiber;
  if (!fiber.alternate) {
    // If there is no alternate, this might be a new tree that isn't inserted
    // yet. If it is, then it will have a pending insertion effect on it.
    if ((node.effectTag & Placement) !== NoEffect) {
      return MOUNTING;
    }
    while (node['return']) {
      node = node['return'];
      if ((node.effectTag & Placement) !== NoEffect) {
        return MOUNTING;
      }
    }
  } else {
    while (node['return']) {
      node = node['return'];
    }
  }
  if (node.tag === HostRoot) {
    // TODO: Check if this was a nested HostRoot when used with
    // renderContainerIntoSubtree.
    return MOUNTED;
  }
  // If we didn't hit the root, that means that we're in an disconnected tree
  // that has been unmounted.
  return UNMOUNTED;
}

function isFiberMounted(fiber) {
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function isMounted(component) {
  {
    var owner = ReactCurrentOwner.current;
    if (owner !== null && owner.tag === ClassComponent) {
      var ownerFiber = owner;
      var instance = ownerFiber.stateNode;
      warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');
      instance._warnedAboutRefsInRender = true;
    }
  }

  var fiber = get(component);
  if (!fiber) {
    return false;
  }
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function assertIsMounted(fiber) {
  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
}

function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    // If there is no alternate, then we only need to check if it is mounted.
    var state = isFiberMountedImpl(fiber);
    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
    if (state === MOUNTING) {
      return null;
    }
    return fiber;
  }
  // If we have two possible branches, we'll walk backwards up to the root
  // to see what path the root points to. On the way we may hit one of the
  // special cases and we'll deal with them.
  var a = fiber;
  var b = alternate;
  while (true) {
    var parentA = a['return'];
    var parentB = parentA ? parentA.alternate : null;
    if (!parentA || !parentB) {
      // We're at the root.
      break;
    }

    // If both copies of the parent fiber point to the same child, we can
    // assume that the child is current. This happens when we bailout on low
    // priority: the bailed out fiber's child reuses the current child.
    if (parentA.child === parentB.child) {
      var child = parentA.child;
      while (child) {
        if (child === a) {
          // We've determined that A is the current branch.
          assertIsMounted(parentA);
          return fiber;
        }
        if (child === b) {
          // We've determined that B is the current branch.
          assertIsMounted(parentA);
          return alternate;
        }
        child = child.sibling;
      }
      // We should never have an alternate for any mounting node. So the only
      // way this could possibly happen is if this was unmounted, if at all.
      invariant(false, 'Unable to find node on an unmounted component.');
    }

    if (a['return'] !== b['return']) {
      // The return pointer of A and the return pointer of B point to different
      // fibers. We assume that return pointers never criss-cross, so A must
      // belong to the child set of A.return, and B must belong to the child
      // set of B.return.
      a = parentA;
      b = parentB;
    } else {
      // The return pointers point to the same fiber. We'll have to use the
      // default, slow path: scan the child sets of each parent alternate to see
      // which child belongs to which set.
      //
      // Search parent A's child set
      var didFindChild = false;
      var _child = parentA.child;
      while (_child) {
        if (_child === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }
        if (_child === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }
        _child = _child.sibling;
      }
      if (!didFindChild) {
        // Search parent B's child set
        _child = parentB.child;
        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }
          if (_child === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }
          _child = _child.sibling;
        }
        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;
      }
    }

    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  }
  // If the root is not a host container, we're in a disconnected tree. I.e.
  // unmounted.
  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
  if (a.stateNode.current === a) {
    // We've determined that A is the current branch.
    return fiber;
  }
  // Otherwise B has to be current branch.
  return alternate;
}

function findCurrentHostFiber(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child) {
      node.child['return'] = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node['return'] || node['return'] === currentParent) {
        return null;
      }
      node = node['return'];
    }
    node.sibling['return'] = node['return'];
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

function findCurrentHostFiberWithNoPortals(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child && node.tag !== HostPortal) {
      node.child['return'] = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node['return'] || node['return'] === currentParent) {
        return null;
      }
      node = node['return'];
    }
    node.sibling['return'] = node['return'];
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;
var callbackBookkeepingPool = [];

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findRootContainerNode(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst['return']) {
    inst = inst['return'];
  }
  if (inst.tag !== HostRoot) {
    // This can happen if we're in a detached tree.
    return null;
  }
  return inst.stateNode.containerInfo;
}

// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {
  if (callbackBookkeepingPool.length) {
    var instance = callbackBookkeepingPool.pop();
    instance.topLevelType = topLevelType;
    instance.nativeEvent = nativeEvent;
    instance.targetInst = targetInst;
    return instance;
  }
  return {
    topLevelType: topLevelType,
    nativeEvent: nativeEvent,
    targetInst: targetInst,
    ancestors: []
  };
}

function releaseTopLevelCallbackBookKeeping(instance) {
  instance.topLevelType = null;
  instance.nativeEvent = null;
  instance.targetInst = null;
  instance.ancestors.length = 0;
  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {
    callbackBookkeepingPool.push(instance);
  }
}

function handleTopLevelImpl(bookKeeping) {
  var targetInst = bookKeeping.targetInst;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    if (!ancestor) {
      bookKeeping.ancestors.push(ancestor);
      break;
    }
    var root = findRootContainerNode(ancestor);
    if (!root) {
      break;
    }
    bookKeeping.ancestors.push(ancestor);
    ancestor = getClosestInstanceFromNode(root);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    _handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

// TODO: can we stop exporting these?
var _enabled = true;
var _handleTopLevel = void 0;

function setHandleTopLevel(handleTopLevel) {
  _handleTopLevel = handleTopLevel;
}

function setEnabled(enabled) {
  _enabled = !!enabled;
}

function isEnabled() {
  return _enabled;
}

/**
 * Traps top-level events by using event bubbling.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapBubbledEvent(topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
}

/**
 * Traps a top-level event by using event capturing.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapCapturedEvent(topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.capture(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
}

function dispatchEvent(topLevelType, nativeEvent) {
  if (!_enabled) {
    return;
  }

  var nativeEventTarget = getEventTarget(nativeEvent);
  var targetInst = getClosestInstanceFromNode(nativeEventTarget);
  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {
    // If we get an event (ex: img onload) before committing that
    // component's mount, ignore it for now (that is, treat it as if it was an
    // event on a non-React tree). We might also consider queueing events and
    // dispatching them after the mount.
    targetInst = null;
  }

  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);

  try {
    // Event queue being processed in the same cycle allows
    // `preventDefault`.
    batchedUpdates(handleTopLevelImpl, bookKeeping);
  } finally {
    releaseTopLevelCallbackBookKeeping(bookKeeping);
  }
}

var ReactDOMEventListener = Object.freeze({
	get _enabled () { return _enabled; },
	get _handleTopLevel () { return _handleTopLevel; },
	setHandleTopLevel: setHandleTopLevel,
	setEnabled: setEnabled,
	isEnabled: isEnabled,
	trapBubbledEvent: trapBubbledEvent,
	trapCapturedEvent: trapCapturedEvent,
	dispatchEvent: dispatchEvent
});

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

/**
 * Types of raw signals from the browser caught at the top level.
 *
 * For events like 'submit' which don't consistently bubble (which we
 * trap at a lower node than `document`), binding at `document` would
 * cause duplicate events so we don't include them here.
 */
var topLevelTypes$1 = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCancel: 'cancel',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topClose: 'close',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoad: 'load',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topToggle: 'toggle',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

var BrowserEventConstants = {
  topLevelTypes: topLevelTypes$1
};

function runEventQueueInBatch(events) {
  enqueueEvents(events);
  processEventQueue(false);
}

/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
 */
function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventQueueInBatch(events);
}

var topLevelTypes = BrowserEventConstants.topLevelTypes;

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var reactTopListenersCounter = 0;

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} contentDocumentHandle Document which owns the container
 */
function listenTo(registrationName, contentDocumentHandle) {
  var mountAt = contentDocumentHandle;
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];

  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      if (dependency === 'topWheel') {
        if (isEventSupported('wheel')) {
          trapBubbledEvent('topWheel', 'wheel', mountAt);
        } else if (isEventSupported('mousewheel')) {
          trapBubbledEvent('topWheel', 'mousewheel', mountAt);
        } else {
          // Firefox needs to capture a different mouse scroll event.
          // @see http://www.quirksmode.org/dom/events/tests/scroll.html
          trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
        }
      } else if (dependency === 'topScroll') {
        trapCapturedEvent('topScroll', 'scroll', mountAt);
      } else if (dependency === 'topFocus' || dependency === 'topBlur') {
        trapCapturedEvent('topFocus', 'focus', mountAt);
        trapCapturedEvent('topBlur', 'blur', mountAt);

        // to make sure blur and focus event listeners are only attached once
        isListening.topBlur = true;
        isListening.topFocus = true;
      } else if (dependency === 'topCancel') {
        if (isEventSupported('cancel', true)) {
          trapCapturedEvent('topCancel', 'cancel', mountAt);
        }
        isListening.topCancel = true;
      } else if (dependency === 'topClose') {
        if (isEventSupported('close', true)) {
          trapCapturedEvent('topClose', 'close', mountAt);
        }
        isListening.topClose = true;
      } else if (topLevelTypes.hasOwnProperty(dependency)) {
        trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);
      }

      isListening[dependency] = true;
    }
  }
}

function isListeningToAllDependencies(registrationName, mountAt) {
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];
  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      return false;
    }
  }
  return true;
}

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === TEXT_NODE) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */
function getOffsets(outerNode) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode$$1 = selection.focusNode;
  var focusOffset = selection.focusOffset;

  // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
  // expose properties, triggering a "Permission denied error" if any of its
  // properties are accessed. The only seemingly possible way to avoid erroring
  // is to access a property that typically works for non-anonymous divs and
  // catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    anchorNode.nodeType;
    focusNode$$1.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset);
}

/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */
function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset) {
  var length = 0;
  var start = -1;
  var end = -1;
  var indexWithinAnchor = 0;
  var indexWithinFocus = 0;
  var node = outerNode;
  var parentNode = null;

  outer: while (true) {
    var next = null;

    while (true) {
      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
        start = length + anchorOffset;
      }
      if (node === focusNode$$1 && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
        end = length + focusOffset;
      }

      if (node.nodeType === TEXT_NODE) {
        length += node.nodeValue.length;
      }

      if ((next = node.firstChild) === null) {
        break;
      }
      // Moving from `node` to its first child `next`.
      parentNode = node;
      node = next;
    }

    while (true) {
      if (node === outerNode) {
        // If `outerNode` has children, this is always the second time visiting
        // it. If it has no children, this is still the first loop, and the only
        // valid selection is anchorNode and focusNode both equal to this node
        // and both offsets 0, in which case we will have handled above.
        break outer;
      }
      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
        start = length;
      }
      if (parentNode === focusNode$$1 && ++indexWithinFocus === focusOffset) {
        end = length;
      }
      if ((next = node.nextSibling) !== null) {
        break;
      }
      node = parentNode;
      parentNode = node.parentNode;
    }

    // Moving from `node` to its next sibling `next`.
    node = next;
  }

  if (start === -1 || end === -1) {
    // This should never happen. (Would happen if the anchor/focus nodes aren't
    // actually inside the passed-in node.)
    return null;
  }

  return {
    start: start,
    end: end
  };
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
      return;
    }
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */

function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
}

function getSelectionInformation() {
  var focusedElem = getActiveElement();
  return {
    focusedElem: focusedElem,
    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null
  };
}

/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */
function restoreSelection(priorSelectionInformation) {
  var curFocusedElem = getActiveElement();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
    if (hasSelectionCapabilities(priorFocusedElem)) {
      setSelection(priorFocusedElem, priorSelectionRange);
    }

    // Focusing a node can change the scroll position, which is undesirable
    var ancestors = [];
    var ancestor = priorFocusedElem;
    while (ancestor = ancestor.parentNode) {
      if (ancestor.nodeType === ELEMENT_NODE) {
        ancestors.push({
          element: ancestor,
          left: ancestor.scrollLeft,
          top: ancestor.scrollTop
        });
      }
    }

    focusNode(priorFocusedElem);

    for (var i = 0; i < ancestors.length; i++) {
      var info = ancestors[i];
      info.element.scrollLeft = info.left;
      info.element.scrollTop = info.top;
    }
  }
}

/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */
function getSelection$1(input) {
  var selection = void 0;

  if ('selectionStart' in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else {
    // Content editable or old IE textarea.
    selection = getOffsets(input);
  }

  return selection || { start: 0, end: 0 };
}

/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */
function setSelection(input, offsets) {
  var start = offsets.start,
      end = offsets.end;

  if (end === undefined) {
    end = start;
  }

  if ('selectionStart' in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else {
    setOffsets(input, offsets);
  }
}

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes$3 = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement$1 = null;
var activeElementInst$1 = null;
var lastSelection = null;
var mouseDown = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement$1);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement$1;

    accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {
  eventTypes: eventTypes$3,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;
    // Track whether all listeners exists for this plugin. If none exist, we do
    // not extract events. See #3639.
    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {
      return null;
    }

    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement$1 = targetNode;
          activeElementInst$1 = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement$1 = null;
        activeElementInst$1 = null;
        lastSelection = null;
        break;
      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);
      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  }
};

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  '8': 'Backspace',
  '9': 'Tab',
  '12': 'Clear',
  '13': 'Enter',
  '16': 'Shift',
  '17': 'Control',
  '18': 'Alt',
  '19': 'Pause',
  '20': 'CapsLock',
  '27': 'Escape',
  '32': ' ',
  '33': 'PageUp',
  '34': 'PageDown',
  '35': 'End',
  '36': 'Home',
  '37': 'ArrowLeft',
  '38': 'ArrowUp',
  '39': 'ArrowRight',
  '40': 'ArrowDown',
  '45': 'Insert',
  '46': 'Delete',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'NumLock',
  '145': 'ScrollLock',
  '224': 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes$4 = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'toggle', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes$4[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes = ['topAbort', 'topCancel', 'topCanPlay', 'topCanPlayThrough', 'topClose', 'topDurationChange', 'topEmptied', 'topEncrypted', 'topEnded', 'topError', 'topInput', 'topInvalid', 'topLoad', 'topLoadedData', 'topLoadedMetadata', 'topLoadStart', 'topPause', 'topPlay', 'topPlaying', 'topProgress', 'topRateChange', 'topReset', 'topSeeked', 'topSeeking', 'topStalled', 'topSubmit', 'topSuspend', 'topTimeUpdate', 'topToggle', 'topVolumeChange', 'topWaiting'];

var SimpleEventPlugin = {
  eventTypes: eventTypes$4,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
      default:
        {
          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {
            warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);
          }
        }
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent$1;
        break;
    }
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    accumulateTwoPhaseDispatches(event);
    return event;
  }
};

setHandleTopLevel(handleTopLevel);

/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */
injection$1.injectEventPluginOrder(DOMEventPluginOrder);
injection$2.injectComponentTree(ReactDOMComponentTree);

/**
 * Some important event plugins included by default (without having to require
 * them).
 */
injection$1.injectEventPluginsByName({
  SimpleEventPlugin: SimpleEventPlugin,
  EnterLeaveEventPlugin: EnterLeaveEventPlugin,
  ChangeEventPlugin: ChangeEventPlugin,
  SelectEventPlugin: SelectEventPlugin,
  BeforeInputEventPlugin: BeforeInputEventPlugin
});

var enableAsyncSubtreeAPI = true;
var enableAsyncSchedulingByDefaultInReactDOM = false;
// Exports React.Fragment
var enableReactFragment = false;
// Exports ReactDOM.createRoot
var enableCreateRoot = false;
var enableUserTimingAPI = true;

// Mutating mode (React DOM, React ART, React Native):
var enableMutatingReconciler = true;
// Experimental noop mode (currently unused):
var enableNoopReconciler = false;
// Experimental persistent mode (CS):
var enablePersistentReconciler = false;

// Only used in www builds.

var valueStack = [];

{
  var fiberStack = [];
}

var index = -1;

function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}



function pop(cursor, fiber) {
  if (index < 0) {
    {
      warning(false, 'Unexpected pop.');
    }
    return;
  }

  {
    if (fiber !== fiberStack[index]) {
      warning(false, 'Unexpected Fiber popped.');
    }
  }

  cursor.current = valueStack[index];

  valueStack[index] = null;

  {
    fiberStack[index] = null;
  }

  index--;
}

function push(cursor, value, fiber) {
  index++;

  valueStack[index] = cursor.current;

  {
    fiberStack[index] = fiber;
  }

  cursor.current = value;
}

function reset$1() {
  while (index > -1) {
    valueStack[index] = null;

    {
      fiberStack[index] = null;
    }

    index--;
  }
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function describeFiber(fiber) {
  switch (fiber.tag) {
    case IndeterminateComponent:
    case FunctionalComponent:
    case ClassComponent:
    case HostComponent:
      var owner = fiber._debugOwner;
      var source = fiber._debugSource;
      var name = getComponentName(fiber);
      var ownerName = null;
      if (owner) {
        ownerName = getComponentName(owner);
      }
      return describeComponentFrame(name, source, ownerName);
    default:
      return '';
  }
}

// This function can only be called with a work-in-progress fiber and
// only during begin or complete phase. Do not call it under any other
// circumstances.
function getStackAddendumByWorkInProgressFiber(workInProgress) {
  var info = '';
  var node = workInProgress;
  do {
    info += describeFiber(node);
    // Otherwise this return pointer might point to the wrong tree:
    node = node['return'];
  } while (node);
  return info;
}

function getCurrentFiberOwnerName() {
  {
    var fiber = ReactDebugCurrentFiber.current;
    if (fiber === null) {
      return null;
    }
    var owner = fiber._debugOwner;
    if (owner !== null && typeof owner !== 'undefined') {
      return getComponentName(owner);
    }
  }
  return null;
}

function getCurrentFiberStackAddendum() {
  {
    var fiber = ReactDebugCurrentFiber.current;
    if (fiber === null) {
      return null;
    }
    // Safe because if current fiber exists, we are reconciling,
    // and it is guaranteed to be the work-in-progress version.
    return getStackAddendumByWorkInProgressFiber(fiber);
  }
  return null;
}

function resetCurrentFiber() {
  ReactDebugCurrentFrame.getCurrentStack = null;
  ReactDebugCurrentFiber.current = null;
  ReactDebugCurrentFiber.phase = null;
}

function setCurrentFiber(fiber) {
  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;
  ReactDebugCurrentFiber.current = fiber;
  ReactDebugCurrentFiber.phase = null;
}

function setCurrentPhase(phase) {
  ReactDebugCurrentFiber.phase = phase;
}

var ReactDebugCurrentFiber = {
  current: null,
  phase: null,
  resetCurrentFiber: resetCurrentFiber,
  setCurrentFiber: setCurrentFiber,
  setCurrentPhase: setCurrentPhase,
  getCurrentFiberOwnerName: getCurrentFiberOwnerName,
  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum
};

// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji = '\u269B';
var warningEmoji = '\u26D4';
var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber = null;
// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase = null;
var currentPhaseFiber = null;
// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting = false;
var hasScheduledUpdateInCurrentCommit = false;
var hasScheduledUpdateInCurrentPhase = false;
var commitCountInCurrentWorkLoop = 0;
var effectCountInCurrentCommit = 0;
var isWaitingForCallback = false;
// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit = new Set();

var formatMarkName = function (markName) {
  return reactEmoji + ' ' + markName;
};

var formatLabel = function (label, warning$$1) {
  var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';
  var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';
  return '' + prefix + label + suffix;
};

var beginMark = function (markName) {
  performance.mark(formatMarkName(markName));
};

var clearMark = function (markName) {
  performance.clearMarks(formatMarkName(markName));
};

var endMark = function (label, markName, warning$$1) {
  var formattedMarkName = formatMarkName(markName);
  var formattedLabel = formatLabel(label, warning$$1);
  try {
    performance.measure(formattedLabel, formattedMarkName);
  } catch (err) {}
  // If previous mark was missing for some reason, this will throw.
  // This could only happen if React crashed in an unexpected place earlier.
  // Don't pile on with more errors.

  // Clear marks immediately to avoid growing buffer.
  performance.clearMarks(formattedMarkName);
  performance.clearMeasures(formattedLabel);
};

var getFiberMarkName = function (label, debugID) {
  return label + ' (#' + debugID + ')';
};

var getFiberLabel = function (componentName, isMounted, phase) {
  if (phase === null) {
    // These are composite component total time measurements.
    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';
  } else {
    // Composite component methods.
    return componentName + '.' + phase;
  }
};

var beginFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);

  if (isCommitting && labelsInCurrentCommit.has(label)) {
    // During the commit phase, we don't show duplicate labels because
    // there is a fixed overhead for every measurement, and we don't
    // want to stretch the commit phase beyond necessary.
    return false;
  }
  labelsInCurrentCommit.add(label);

  var markName = getFiberMarkName(label, debugID);
  beginMark(markName);
  return true;
};

var clearFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  clearMark(markName);
};

var endFiberMark = function (fiber, phase, warning$$1) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  endMark(label, markName, warning$$1);
};

var shouldIgnoreFiber = function (fiber) {
  // Host components should be skipped in the timeline.
  // We could check typeof fiber.type, but does this work with RN?
  switch (fiber.tag) {
    case HostRoot:
    case HostComponent:
    case HostText:
    case HostPortal:
    case ReturnComponent:
    case Fragment:
      return true;
    default:
      return false;
  }
};

var clearPendingPhaseMeasurement = function () {
  if (currentPhase !== null && currentPhaseFiber !== null) {
    clearFiberMark(currentPhaseFiber, currentPhase);
  }
  currentPhaseFiber = null;
  currentPhase = null;
  hasScheduledUpdateInCurrentPhase = false;
};

var pauseTimers = function () {
  // Stops all currently active measurements so that they can be resumed
  // if we continue in a later deferred loop from the same unit of work.
  var fiber = currentFiber;
  while (fiber) {
    if (fiber._debugIsCurrentlyTiming) {
      endFiberMark(fiber, null, null);
    }
    fiber = fiber['return'];
  }
};

var resumeTimersRecursively = function (fiber) {
  if (fiber['return'] !== null) {
    resumeTimersRecursively(fiber['return']);
  }
  if (fiber._debugIsCurrentlyTiming) {
    beginFiberMark(fiber, null);
  }
};

var resumeTimers = function () {
  // Resumes all measurements that were active during the last deferred loop.
  if (currentFiber !== null) {
    resumeTimersRecursively(currentFiber);
  }
};

function recordEffect() {
  if (enableUserTimingAPI) {
    effectCountInCurrentCommit++;
  }
}

function recordScheduleUpdate() {
  if (enableUserTimingAPI) {
    if (isCommitting) {
      hasScheduledUpdateInCurrentCommit = true;
    }
    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {
      hasScheduledUpdateInCurrentPhase = true;
    }
  }
}

function startRequestCallbackTimer() {
  if (enableUserTimingAPI) {
    if (supportsUserTiming && !isWaitingForCallback) {
      isWaitingForCallback = true;
      beginMark('(Waiting for async callback...)');
    }
  }
}

function stopRequestCallbackTimer(didExpire) {
  if (enableUserTimingAPI) {
    if (supportsUserTiming) {
      isWaitingForCallback = false;
      var warning$$1 = didExpire ? 'React was blocked by main thread' : null;
      endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);
    }
  }
}

function startWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, this is the fiber to unwind from.
    currentFiber = fiber;
    if (!beginFiberMark(fiber, null)) {
      return;
    }
    fiber._debugIsCurrentlyTiming = true;
  }
}

function cancelWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // Remember we shouldn't complete measurement for this fiber.
    // Otherwise flamechart will be deep even for small updates.
    fiber._debugIsCurrentlyTiming = false;
    clearFiberMark(fiber, null);
  }
}

function stopWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber['return'];
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    endFiberMark(fiber, null, null);
  }
}

function stopFailedWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber['return'];
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    var warning$$1 = 'An error was thrown inside this error boundary';
    endFiberMark(fiber, null, warning$$1);
  }
}

function startPhaseTimer(fiber, phase) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    clearPendingPhaseMeasurement();
    if (!beginFiberMark(fiber, phase)) {
      return;
    }
    currentPhaseFiber = fiber;
    currentPhase = phase;
  }
}

function stopPhaseTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    if (currentPhase !== null && currentPhaseFiber !== null) {
      var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;
      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);
    }
    currentPhase = null;
    currentPhaseFiber = null;
  }
}

function startWorkLoopTimer(nextUnitOfWork) {
  if (enableUserTimingAPI) {
    currentFiber = nextUnitOfWork;
    if (!supportsUserTiming) {
      return;
    }
    commitCountInCurrentWorkLoop = 0;
    // This is top level call.
    // Any other measurements are performed within.
    beginMark('(React Tree Reconciliation)');
    // Resume any measurements that were in progress during the last loop.
    resumeTimers();
  }
}

function stopWorkLoopTimer(interruptedBy) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var warning$$1 = null;
    if (interruptedBy !== null) {
      if (interruptedBy.tag === HostRoot) {
        warning$$1 = 'A top-level update interrupted the previous render';
      } else {
        var componentName = getComponentName(interruptedBy) || 'Unknown';
        warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';
      }
    } else if (commitCountInCurrentWorkLoop > 1) {
      warning$$1 = 'There were cascading updates';
    }
    commitCountInCurrentWorkLoop = 0;
    // Pause any measurements until the next loop.
    pauseTimers();
    endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);
  }
}

function startCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    isCommitting = true;
    hasScheduledUpdateInCurrentCommit = false;
    labelsInCurrentCommit.clear();
    beginMark('(Committing Changes)');
  }
}

function stopCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }

    var warning$$1 = null;
    if (hasScheduledUpdateInCurrentCommit) {
      warning$$1 = 'Lifecycle hook scheduled a cascading update';
    } else if (commitCountInCurrentWorkLoop > 0) {
      warning$$1 = 'Caused by a cascading update in earlier commit';
    }
    hasScheduledUpdateInCurrentCommit = false;
    commitCountInCurrentWorkLoop++;
    isCommitting = false;
    labelsInCurrentCommit.clear();

    endMark('(Committing Changes)', '(Committing Changes)', warning$$1);
  }
}

function startCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Committing Host Effects)');
  }
}

function stopCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);
  }
}

function startCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Calling Lifecycle Methods)');
  }
}

function stopCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);
  }
}

{
  var warnedAboutMissingGetChildContext = {};
}

// A cursor to the current merged context object on the stack.
var contextStackCursor = createCursor(emptyObject);
// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor = createCursor(false);
// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext = emptyObject;

function getUnmaskedContext(workInProgress) {
  var hasOwnContext = isContextProvider(workInProgress);
  if (hasOwnContext) {
    // If the fiber is a context provider itself, when we read its context
    // we have already pushed its own child context on the stack. A context
    // provider should not "see" its own child context. Therefore we read the
    // previous (parent) context instead for a context provider.
    return previousContext;
  }
  return contextStackCursor.current;
}

function cacheContext(workInProgress, unmaskedContext, maskedContext) {
  var instance = workInProgress.stateNode;
  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
}

function getMaskedContext(workInProgress, unmaskedContext) {
  var type = workInProgress.type;
  var contextTypes = type.contextTypes;
  if (!contextTypes) {
    return emptyObject;
  }

  // Avoid recreating masked context unless unmasked context has changed.
  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
  // This may trigger infinite loops if componentWillReceiveProps calls setState.
  var instance = workInProgress.stateNode;
  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
    return instance.__reactInternalMemoizedMaskedChildContext;
  }

  var context = {};
  for (var key in contextTypes) {
    context[key] = unmaskedContext[key];
  }

  {
    var name = getComponentName(workInProgress) || 'Unknown';
    checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
  }

  // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // Context is created before the class component is instantiated so check for instance.
  if (instance) {
    cacheContext(workInProgress, unmaskedContext, context);
  }

  return context;
}

function hasContextChanged() {
  return didPerformWorkStackCursor.current;
}

function isContextConsumer(fiber) {
  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;
}

function isContextProvider(fiber) {
  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;
}

function popContextProvider(fiber) {
  if (!isContextProvider(fiber)) {
    return;
  }

  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function popTopLevelContextObject(fiber) {
  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function pushTopLevelContextObject(fiber, context, didChange) {
  !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  push(contextStackCursor, context, fiber);
  push(didPerformWorkStackCursor, didChange, fiber);
}

function processChildContext(fiber, parentContext) {
  var instance = fiber.stateNode;
  var childContextTypes = fiber.type.childContextTypes;

  // TODO (bvaughn) Replace this behavior with an invariant() in the future.
  // It has only been added in Fiber to match the (unintentional) behavior in Stack.
  if (typeof instance.getChildContext !== 'function') {
    {
      var componentName = getComponentName(fiber) || 'Unknown';

      if (!warnedAboutMissingGetChildContext[componentName]) {
        warnedAboutMissingGetChildContext[componentName] = true;
        warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
      }
    }
    return parentContext;
  }

  var childContext = void 0;
  {
    ReactDebugCurrentFiber.setCurrentPhase('getChildContext');
  }
  startPhaseTimer(fiber, 'getChildContext');
  childContext = instance.getChildContext();
  stopPhaseTimer();
  {
    ReactDebugCurrentFiber.setCurrentPhase(null);
  }
  for (var contextKey in childContext) {
    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;
  }
  {
    var name = getComponentName(fiber) || 'Unknown';
    checkPropTypes(childContextTypes, childContext, 'child context', name,
    // In practice, there is one case in which we won't get a stack. It's when
    // somebody calls unstable_renderSubtreeIntoContainer() and we process
    // context from the parent component instance. The stack will be missing
    // because it's outside of the reconciliation, and so the pointer has not
    // been set. This is rare and doesn't matter. We'll also remove that API.
    ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
  }

  return _assign({}, parentContext, childContext);
}

function pushContextProvider(workInProgress) {
  if (!isContextProvider(workInProgress)) {
    return false;
  }

  var instance = workInProgress.stateNode;
  // We push the context as early as possible to ensure stack integrity.
  // If the instance does not exist yet, we will push null at first,
  // and replace it on the stack later when invalidating the context.
  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;

  // Remember the parent context so we can merge with it later.
  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
  previousContext = contextStackCursor.current;
  push(contextStackCursor, memoizedMergedChildContext, workInProgress);
  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);

  return true;
}

function invalidateContextProvider(workInProgress, didChange) {
  var instance = workInProgress.stateNode;
  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  if (didChange) {
    // Merge parent and own context.
    // Skip this if we're not updating due to sCU.
    // This avoids unnecessarily recomputing memoized values.
    var mergedContext = processChildContext(workInProgress, previousContext);
    instance.__reactInternalMemoizedMergedChildContext = mergedContext;

    // Replace the old (or empty) context with the new one.
    // It is important to unwind the context in the reverse order.
    pop(didPerformWorkStackCursor, workInProgress);
    pop(contextStackCursor, workInProgress);
    // Now push the new context and mark that it has changed.
    push(contextStackCursor, mergedContext, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  } else {
    pop(didPerformWorkStackCursor, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  }
}

function resetContext() {
  previousContext = emptyObject;
  contextStackCursor.current = emptyObject;
  didPerformWorkStackCursor.current = false;
}

function findCurrentUnmaskedContext(fiber) {
  // Currently this is only used with renderSubtreeIntoContainer; not sure if it
  // makes sense elsewhere
  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  var node = fiber;
  while (node.tag !== HostRoot) {
    if (isContextProvider(node)) {
      return node.stateNode.__reactInternalMemoizedMergedChildContext;
    }
    var parent = node['return'];
    !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    node = parent;
  }
  return node.stateNode.context;
}

var NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax

var Sync = 1;
var Never = 2147483647; // Max int32: Math.pow(2, 31) - 1

var UNIT_SIZE = 10;
var MAGIC_NUMBER_OFFSET = 2;

// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms) {
  // Always add an offset so that we don't clash with the magic number for NoWork.
  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;
}

function ceiling(num, precision) {
  return ((num / precision | 0) + 1) * precision;
}

function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
  return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
}

var NoContext = 0;
var AsyncUpdates = 1;

{
  var hasBadMapPolyfill = false;
  try {
    var nonExtensibleObject = Object.preventExtensions({});
    /* eslint-disable no-new */
    new Map([[nonExtensibleObject, null]]);
    new Set([nonExtensibleObject]);
    /* eslint-enable no-new */
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.


{
  var debugCounter = 1;
}

function FiberNode(tag, key, internalContextTag) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this['return'] = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this.pendingProps = null;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.internalContextTag = internalContextTag;

  // Effects
  this.effectTag = NoEffect;
  this.nextEffect = null;

  this.firstEffect = null;
  this.lastEffect = null;

  this.expirationTime = NoWork;

  this.alternate = null;

  {
    this._debugID = debugCounter++;
    this._debugSource = null;
    this._debugOwner = null;
    this._debugIsCurrentlyTiming = false;
    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
}

// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber = function (tag, key, internalContextTag) {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, key, internalContextTag);
};

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current, pendingProps, expirationTime) {
  var workInProgress = current.alternate;
  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(current.tag, current.key, current.internalContextTag);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    {
      // DEV-only fields
      workInProgress._debugID = current._debugID;
      workInProgress._debugSource = current._debugSource;
      workInProgress._debugOwner = current._debugOwner;
    }

    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // We already have an alternate.
    // Reset the effect tag.
    workInProgress.effectTag = NoEffect;

    // The effect list is no longer valid.
    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;
  }

  workInProgress.expirationTime = expirationTime;
  workInProgress.pendingProps = pendingProps;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  // These will be overridden during the parent's reconciliation
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  return workInProgress;
}

function createHostRootFiber() {
  var fiber = createFiber(HostRoot, null, NoContext);
  return fiber;
}

function createFiberFromElement(element, internalContextTag, expirationTime) {
  var owner = null;
  {
    owner = element._owner;
  }

  var fiber = void 0;
  var type = element.type,
      key = element.key;

  if (typeof type === 'function') {
    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);
    fiber.type = type;
    fiber.pendingProps = element.props;
  } else if (typeof type === 'string') {
    fiber = createFiber(HostComponent, key, internalContextTag);
    fiber.type = type;
    fiber.pendingProps = element.props;
  } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {
    // Currently assumed to be a continuation and therefore is a fiber already.
    // TODO: The yield system is currently broken for updates in some cases.
    // The reified yield stores a fiber, but we don't know which fiber that is;
    // the current or a workInProgress? When the continuation gets rendered here
    // we don't know if we can reuse that fiber or if we need to clone it.
    // There is probably a clever way to restructure this.
    fiber = type;
    fiber.pendingProps = element.props;
  } else {
    var info = '';
    {
      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }
      var ownerName = owner ? getComponentName(owner) : null;
      if (ownerName) {
        info += '\n\nCheck the render method of `' + ownerName + '`.';
      }
    }
    invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);
  }

  {
    fiber._debugSource = element._source;
    fiber._debugOwner = element._owner;
  }

  fiber.expirationTime = expirationTime;

  return fiber;
}

function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {
  var fiber = createFiber(Fragment, key, internalContextTag);
  fiber.pendingProps = elements;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromText(content, internalContextTag, expirationTime) {
  var fiber = createFiber(HostText, null, internalContextTag);
  fiber.pendingProps = content;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromHostInstanceForDeletion() {
  var fiber = createFiber(HostComponent, null, NoContext);
  fiber.type = 'DELETED';
  return fiber;
}

function createFiberFromCall(call, internalContextTag, expirationTime) {
  var fiber = createFiber(CallComponent, call.key, internalContextTag);
  fiber.type = call.handler;
  fiber.pendingProps = call;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {
  var fiber = createFiber(ReturnComponent, null, internalContextTag);
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromPortal(portal, internalContextTag, expirationTime) {
  var fiber = createFiber(HostPortal, portal.key, internalContextTag);
  fiber.pendingProps = portal.children || [];
  fiber.expirationTime = expirationTime;
  fiber.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null, // Used by persistent updates
    implementation: portal.implementation
  };
  return fiber;
}

function createFiberRoot(containerInfo, hydrate) {
  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  var uninitializedFiber = createHostRootFiber();
  var root = {
    current: uninitializedFiber,
    containerInfo: containerInfo,
    pendingChildren: null,
    remainingExpirationTime: NoWork,
    isReadyForCommit: false,
    finishedWork: null,
    context: null,
    pendingContext: null,
    hydrate: hydrate,
    nextScheduledRoot: null
  };
  uninitializedFiber.stateNode = root;
  return root;
}

var onCommitFiberRoot = null;
var onCommitFiberUnmount = null;
var hasLoggedError = false;

function catchErrors(fn) {
  return function (arg) {
    try {
      return fn(arg);
    } catch (err) {
      if (true && !hasLoggedError) {
        hasLoggedError = true;
        warning(false, 'React DevTools encountered an error: %s', err);
      }
    }
  };
}

function injectInternals(internals) {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
    // No DevTools
    return false;
  }
  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (hook.isDisabled) {
    // This isn't a real property on the hook, but it can be set to opt out
    // of DevTools integration and associated warnings and logs.
    // https://github.com/facebook/react/issues/3877
    return true;
  }
  if (!hook.supportsFiber) {
    {
      warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');
    }
    // DevTools exists, even though it doesn't support Fiber.
    return true;
  }
  try {
    var rendererID = hook.inject(internals);
    // We have successfully injected, so now it is safe to set up hooks.
    onCommitFiberRoot = catchErrors(function (root) {
      return hook.onCommitFiberRoot(rendererID, root);
    });
    onCommitFiberUnmount = catchErrors(function (fiber) {
      return hook.onCommitFiberUnmount(rendererID, fiber);
    });
  } catch (err) {
    // Catch all errors because it is unsafe to throw during initialization.
    {
      warning(false, 'React DevTools encountered an error: %s.', err);
    }
  }
  // DevTools exists
  return true;
}

function onCommitRoot(root) {
  if (typeof onCommitFiberRoot === 'function') {
    onCommitFiberRoot(root);
  }
}

function onCommitUnmount(fiber) {
  if (typeof onCommitFiberUnmount === 'function') {
    onCommitFiberUnmount(fiber);
  }
}

{
  var didWarnUpdateInsideUpdate = false;
}

// Callbacks are not validated until invocation


// Singly linked-list of updates. When an update is scheduled, it is added to
// the queue of the current fiber and the work-in-progress fiber. The two queues
// are separate but they share a persistent structure.
//
// During reconciliation, updates are removed from the work-in-progress fiber,
// but they remain on the current fiber. That ensures that if a work-in-progress
// is aborted, the aborted updates are recovered by cloning from current.
//
// The work-in-progress queue is always a subset of the current queue.
//
// When the tree is committed, the work-in-progress becomes the current.


function createUpdateQueue(baseState) {
  var queue = {
    baseState: baseState,
    expirationTime: NoWork,
    first: null,
    last: null,
    callbackList: null,
    hasForceUpdate: false,
    isInitialized: false
  };
  {
    queue.isProcessing = false;
  }
  return queue;
}

function insertUpdateIntoQueue(queue, update) {
  // Append the update to the end of the list.
  if (queue.last === null) {
    // Queue is empty
    queue.first = queue.last = update;
  } else {
    queue.last.next = update;
    queue.last = update;
  }
  if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {
    queue.expirationTime = update.expirationTime;
  }
}

function insertUpdateIntoFiber(fiber, update) {
  // We'll have at least one and at most two distinct update queues.
  var alternateFiber = fiber.alternate;
  var queue1 = fiber.updateQueue;
  if (queue1 === null) {
    // TODO: We don't know what the base state will be until we begin work.
    // It depends on which fiber is the next current. Initialize with an empty
    // base state, then set to the memoizedState when rendering. Not super
    // happy with this approach.
    queue1 = fiber.updateQueue = createUpdateQueue(null);
  }

  var queue2 = void 0;
  if (alternateFiber !== null) {
    queue2 = alternateFiber.updateQueue;
    if (queue2 === null) {
      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);
    }
  } else {
    queue2 = null;
  }
  queue2 = queue2 !== queue1 ? queue2 : null;

  // Warn if an update is scheduled from inside an updater function.
  {
    if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {
      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');
      didWarnUpdateInsideUpdate = true;
    }
  }

  // If there's only one queue, add the update to that queue and exit.
  if (queue2 === null) {
    insertUpdateIntoQueue(queue1, update);
    return;
  }

  // If either queue is empty, we need to add to both queues.
  if (queue1.last === null || queue2.last === null) {
    insertUpdateIntoQueue(queue1, update);
    insertUpdateIntoQueue(queue2, update);
    return;
  }

  // If both lists are not empty, the last update is the same for both lists
  // because of structural sharing. So, we should only append to one of
  // the lists.
  insertUpdateIntoQueue(queue1, update);
  // But we still need to update the `last` pointer of queue2.
  queue2.last = update;
}

function getUpdateExpirationTime(fiber) {
  if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {
    return NoWork;
  }
  var updateQueue = fiber.updateQueue;
  if (updateQueue === null) {
    return NoWork;
  }
  return updateQueue.expirationTime;
}

function getStateFromUpdate(update, instance, prevState, props) {
  var partialState = update.partialState;
  if (typeof partialState === 'function') {
    var updateFn = partialState;
    return updateFn.call(instance, prevState, props);
  } else {
    return partialState;
  }
}

function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {
  if (current !== null && current.updateQueue === queue) {
    // We need to create a work-in-progress queue, by cloning the current queue.
    var currentQueue = queue;
    queue = workInProgress.updateQueue = {
      baseState: currentQueue.baseState,
      expirationTime: currentQueue.expirationTime,
      first: currentQueue.first,
      last: currentQueue.last,
      isInitialized: currentQueue.isInitialized,
      // These fields are no longer valid because they were already committed.
      // Reset them.
      callbackList: null,
      hasForceUpdate: false
    };
  }

  {
    // Set this flag so we can warn if setState is called inside the update
    // function of another setState.
    queue.isProcessing = true;
  }

  // Reset the remaining expiration time. If we skip over any updates, we'll
  // increase this accordingly.
  queue.expirationTime = NoWork;

  // TODO: We don't know what the base state will be until we begin work.
  // It depends on which fiber is the next current. Initialize with an empty
  // base state, then set to the memoizedState when rendering. Not super
  // happy with this approach.
  var state = void 0;
  if (queue.isInitialized) {
    state = queue.baseState;
  } else {
    state = queue.baseState = workInProgress.memoizedState;
    queue.isInitialized = true;
  }
  var dontMutatePrevState = true;
  var update = queue.first;
  var didSkip = false;
  while (update !== null) {
    var updateExpirationTime = update.expirationTime;
    if (updateExpirationTime > renderExpirationTime) {
      // This update does not have sufficient priority. Skip it.
      var remainingExpirationTime = queue.expirationTime;
      if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {
        // Update the remaining expiration time.
        queue.expirationTime = updateExpirationTime;
      }
      if (!didSkip) {
        didSkip = true;
        queue.baseState = state;
      }
      // Continue to the next update.
      update = update.next;
      continue;
    }

    // This update does have sufficient priority.

    // If no previous updates were skipped, drop this update from the queue by
    // advancing the head of the list.
    if (!didSkip) {
      queue.first = update.next;
      if (queue.first === null) {
        queue.last = null;
      }
    }

    // Process the update
    var _partialState = void 0;
    if (update.isReplace) {
      state = getStateFromUpdate(update, instance, state, props);
      dontMutatePrevState = true;
    } else {
      _partialState = getStateFromUpdate(update, instance, state, props);
      if (_partialState) {
        if (dontMutatePrevState) {
          // $FlowFixMe: Idk how to type this properly.
          state = _assign({}, state, _partialState);
        } else {
          state = _assign(state, _partialState);
        }
        dontMutatePrevState = false;
      }
    }
    if (update.isForced) {
      queue.hasForceUpdate = true;
    }
    if (update.callback !== null) {
      // Append to list of callbacks.
      var _callbackList = queue.callbackList;
      if (_callbackList === null) {
        _callbackList = queue.callbackList = [];
      }
      _callbackList.push(update);
    }
    update = update.next;
  }

  if (queue.callbackList !== null) {
    workInProgress.effectTag |= Callback;
  } else if (queue.first === null && !queue.hasForceUpdate) {
    // The queue is empty. We can reset it.
    workInProgress.updateQueue = null;
  }

  if (!didSkip) {
    didSkip = true;
    queue.baseState = state;
  }

  {
    // No longer processing.
    queue.isProcessing = false;
  }

  return state;
}

function commitCallbacks(queue, context) {
  var callbackList = queue.callbackList;
  if (callbackList === null) {
    return;
  }
  // Set the list to null to make sure they don't get called more than once.
  queue.callbackList = null;
  for (var i = 0; i < callbackList.length; i++) {
    var update = callbackList[i];
    var _callback = update.callback;
    // This update might be processed again. Clear the callback so it's only
    // called once.
    update.callback = null;
    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;
    _callback.call(context);
  }
}

var fakeInternalInstance = {};
var isArray = Array.isArray;

{
  var didWarnAboutStateAssignmentForComponent = {};

  var warnOnInvalidCallback = function (callback, callerName) {
    warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
  };

  // This is so gross but it's at least non-critical and can be removed if
  // it causes problems. This is meant to give a nicer error message for
  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
  // ...)) which otherwise throws a "_processChildContext is not a function"
  // exception.
  Object.defineProperty(fakeInternalInstance, '_processChildContext', {
    enumerable: false,
    value: function () {
      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');
    }
  });
  Object.freeze(fakeInternalInstance);
}

var ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {
  // Class component state updater
  var updater = {
    isMounted: isMounted,
    enqueueSetState: function (instance, partialState, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'setState');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: partialState,
        callback: callback,
        isReplace: false,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    enqueueReplaceState: function (instance, state, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'replaceState');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: state,
        callback: callback,
        isReplace: true,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    enqueueForceUpdate: function (instance, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'forceUpdate');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: null,
        callback: callback,
        isReplace: false,
        isForced: true,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    }
  };

  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {
    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {
      // If the workInProgress already has an Update effect, return true
      return true;
    }

    var instance = workInProgress.stateNode;
    var type = workInProgress.type;
    if (typeof instance.shouldComponentUpdate === 'function') {
      startPhaseTimer(workInProgress, 'shouldComponentUpdate');
      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);
      stopPhaseTimer();

      {
        warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');
      }

      return shouldUpdate;
    }

    if (type.prototype && type.prototype.isPureReactComponent) {
      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
    }

    return true;
  }

  function checkClassInstance(workInProgress) {
    var instance = workInProgress.stateNode;
    var type = workInProgress.type;
    {
      var name = getComponentName(workInProgress);
      var renderPresent = instance.render;

      if (!renderPresent) {
        if (type.prototype && typeof type.prototype.render === 'function') {
          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
        } else {
          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
        }
      }

      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
      warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
      warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
      var noInstancePropTypes = !instance.propTypes;
      warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
      var noInstanceContextTypes = !instance.contextTypes;
      warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';
      warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
        warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');
      }
      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';
      warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
      var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';
      warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';
      warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
      var hasMutatedProps = instance.props !== workInProgress.pendingProps;
      warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
      var noInstanceDefaultProps = !instance.defaultProps;
      warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
    }

    var state = instance.state;
    if (state && (typeof state !== 'object' || isArray(state))) {
      invariant(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));
    }
    if (typeof instance.getChildContext === 'function') {
      !(typeof workInProgress.type.childContextTypes === 'object') ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', getComponentName(workInProgress)) : void 0;
    }
  }

  function resetInputPointers(workInProgress, instance) {
    instance.props = workInProgress.memoizedProps;
    instance.state = workInProgress.memoizedState;
  }

  function adoptClassInstance(workInProgress, instance) {
    instance.updater = updater;
    workInProgress.stateNode = instance;
    // The instance needs access to the fiber so that it can schedule updates
    set(instance, workInProgress);
    {
      instance._reactInternalInstance = fakeInternalInstance;
    }
  }

  function constructClassInstance(workInProgress, props) {
    var ctor = workInProgress.type;
    var unmaskedContext = getUnmaskedContext(workInProgress);
    var needsContext = isContextConsumer(workInProgress);
    var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;
    var instance = new ctor(props, context);
    adoptClassInstance(workInProgress, instance);

    // Cache unmasked context so we can avoid recreating masked context unless necessary.
    // ReactFiberContext usually updates this cache but can't for newly-created instances.
    if (needsContext) {
      cacheContext(workInProgress, unmaskedContext, context);
    }

    return instance;
  }

  function callComponentWillMount(workInProgress, instance) {
    startPhaseTimer(workInProgress, 'componentWillMount');
    var oldState = instance.state;
    instance.componentWillMount();

    stopPhaseTimer();

    if (oldState !== instance.state) {
      {
        warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress));
      }
      updater.enqueueReplaceState(instance, instance.state, null);
    }
  }

  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {
    startPhaseTimer(workInProgress, 'componentWillReceiveProps');
    var oldState = instance.state;
    instance.componentWillReceiveProps(newProps, newContext);
    stopPhaseTimer();

    if (instance.state !== oldState) {
      {
        var componentName = getComponentName(workInProgress) || 'Component';
        if (!didWarnAboutStateAssignmentForComponent[componentName]) {
          warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
          didWarnAboutStateAssignmentForComponent[componentName] = true;
        }
      }
      updater.enqueueReplaceState(instance, instance.state, null);
    }
  }

  // Invokes the mount life-cycles on a previously never rendered instance.
  function mountClassInstance(workInProgress, renderExpirationTime) {
    var current = workInProgress.alternate;

    {
      checkClassInstance(workInProgress);
    }

    var instance = workInProgress.stateNode;
    var state = instance.state || null;

    var props = workInProgress.pendingProps;
    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    var unmaskedContext = getUnmaskedContext(workInProgress);

    instance.props = props;
    instance.state = workInProgress.memoizedState = state;
    instance.refs = emptyObject;
    instance.context = getMaskedContext(workInProgress, unmaskedContext);

    if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {
      workInProgress.internalContextTag |= AsyncUpdates;
    }

    if (typeof instance.componentWillMount === 'function') {
      callComponentWillMount(workInProgress, instance);
      // If we had additional state updates during this life-cycle, let's
      // process them now.
      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null) {
        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);
      }
    }
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.effectTag |= Update;
    }
  }

  // Called on a preexisting class instance. Returns false if a resumed render
  // could be reused.
  // function resumeMountClassInstance(
  //   workInProgress: Fiber,
  //   priorityLevel: PriorityLevel,
  // ): boolean {
  //   const instance = workInProgress.stateNode;
  //   resetInputPointers(workInProgress, instance);

  //   let newState = workInProgress.memoizedState;
  //   let newProps = workInProgress.pendingProps;
  //   if (!newProps) {
  //     // If there isn't any new props, then we'll reuse the memoized props.
  //     // This could be from already completed work.
  //     newProps = workInProgress.memoizedProps;
  //     invariant(
  //       newProps != null,
  //       'There should always be pending or memoized props. This error is ' +
  //         'likely caused by a bug in React. Please file an issue.',
  //     );
  //   }
  //   const newUnmaskedContext = getUnmaskedContext(workInProgress);
  //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);

  //   const oldContext = instance.context;
  //   const oldProps = workInProgress.memoizedProps;

  //   if (
  //     typeof instance.componentWillReceiveProps === 'function' &&
  //     (oldProps !== newProps || oldContext !== newContext)
  //   ) {
  //     callComponentWillReceiveProps(
  //       workInProgress,
  //       instance,
  //       newProps,
  //       newContext,
  //     );
  //   }

  //   // Process the update queue before calling shouldComponentUpdate
  //   const updateQueue = workInProgress.updateQueue;
  //   if (updateQueue !== null) {
  //     newState = processUpdateQueue(
  //       workInProgress,
  //       updateQueue,
  //       instance,
  //       newState,
  //       newProps,
  //       priorityLevel,
  //     );
  //   }

  //   // TODO: Should we deal with a setState that happened after the last
  //   // componentWillMount and before this componentWillMount? Probably
  //   // unsupported anyway.

  //   if (
  //     !checkShouldComponentUpdate(
  //       workInProgress,
  //       workInProgress.memoizedProps,
  //       newProps,
  //       workInProgress.memoizedState,
  //       newState,
  //       newContext,
  //     )
  //   ) {
  //     // Update the existing instance's state, props, and context pointers even
  //     // though we're bailing out.
  //     instance.props = newProps;
  //     instance.state = newState;
  //     instance.context = newContext;
  //     return false;
  //   }

  //   // Update the input pointers now so that they are correct when we call
  //   // componentWillMount
  //   instance.props = newProps;
  //   instance.state = newState;
  //   instance.context = newContext;

  //   if (typeof instance.componentWillMount === 'function') {
  //     callComponentWillMount(workInProgress, instance);
  //     // componentWillMount may have called setState. Process the update queue.
  //     const newUpdateQueue = workInProgress.updateQueue;
  //     if (newUpdateQueue !== null) {
  //       newState = processUpdateQueue(
  //         workInProgress,
  //         newUpdateQueue,
  //         instance,
  //         newState,
  //         newProps,
  //         priorityLevel,
  //       );
  //     }
  //   }

  //   if (typeof instance.componentDidMount === 'function') {
  //     workInProgress.effectTag |= Update;
  //   }

  //   instance.state = newState;

  //   return true;
  // }

  // Invokes the update life-cycles and returns false if it shouldn't rerender.
  function updateClassInstance(current, workInProgress, renderExpirationTime) {
    var instance = workInProgress.stateNode;
    resetInputPointers(workInProgress, instance);

    var oldProps = workInProgress.memoizedProps;
    var newProps = workInProgress.pendingProps;
    if (!newProps) {
      // If there aren't any new props, then we'll reuse the memoized props.
      // This could be from already completed work.
      newProps = oldProps;
      !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    var oldContext = instance.context;
    var newUnmaskedContext = getUnmaskedContext(workInProgress);
    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);

    // Note: During these life-cycles, instance.props/instance.state are what
    // ever the previously attempted to render - not the "current". However,
    // during componentDidUpdate we pass the "current" props.

    if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);
    }

    // Compute the next state using the memoized state and the update queue.
    var oldState = workInProgress.memoizedState;
    // TODO: Previous state can be null.
    var newState = void 0;
    if (workInProgress.updateQueue !== null) {
      newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);
    } else {
      newState = oldState;
    }

    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {
      // If an update was already in progress, we should schedule an Update
      // effect even though we're bailing out, so that cWU/cDU are called.
      if (typeof instance.componentDidUpdate === 'function') {
        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
          workInProgress.effectTag |= Update;
        }
      }
      return false;
    }

    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);

    if (shouldUpdate) {
      if (typeof instance.componentWillUpdate === 'function') {
        startPhaseTimer(workInProgress, 'componentWillUpdate');
        instance.componentWillUpdate(newProps, newState, newContext);
        stopPhaseTimer();
      }
      if (typeof instance.componentDidUpdate === 'function') {
        workInProgress.effectTag |= Update;
      }
    } else {
      // If an update was already in progress, we should schedule an Update
      // effect even though we're bailing out, so that cWU/cDU are called.
      if (typeof instance.componentDidUpdate === 'function') {
        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
          workInProgress.effectTag |= Update;
        }
      }

      // If shouldComponentUpdate returned false, we should still update the
      // memoized props/state to indicate that this work can be reused.
      memoizeProps(workInProgress, newProps);
      memoizeState(workInProgress, newState);
    }

    // Update the existing instance's state, props, and context pointers even
    // if shouldComponentUpdate returns false.
    instance.props = newProps;
    instance.state = newState;
    instance.context = newContext;

    return shouldUpdate;
  }

  return {
    adoptClassInstance: adoptClassInstance,
    constructClassInstance: constructClassInstance,
    mountClassInstance: mountClassInstance,
    // resumeMountClassInstance,
    updateClassInstance: updateClassInstance
  };
};

// The Symbol used to tag the special React types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_PORTAL_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.portal') || 0xeaca;

function createPortal$1(children, containerInfo,
// TODO: figure out the API for cross-renderer implementation.
implementation) {
  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  return {
    // This tag allow us to uniquely identify this as a React Portal
    $$typeof: REACT_PORTAL_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}

var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


{
  var didWarnAboutMaps = false;
  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */
  var ownerHasKeyUseWarning = {};
  var ownerHasFunctionTypeWarning = {};

  var warnForMissingKey = function (child) {
    if (child === null || typeof child !== 'object') {
      return;
    }
    if (!child._store || child._store.validated || child.key != null) {
      return;
    }
    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    child._store.validated = true;

    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');
    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }
    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

    warning(false, 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());
  };
}

var isArray$1 = Array.isArray;

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE;
var REACT_CALL_TYPE;
var REACT_RETURN_TYPE;
var REACT_FRAGMENT_TYPE;
if (typeof Symbol === 'function' && Symbol['for']) {
  REACT_ELEMENT_TYPE = Symbol['for']('react.element');
  REACT_CALL_TYPE = Symbol['for']('react.call');
  REACT_RETURN_TYPE = Symbol['for']('react.return');
  REACT_FRAGMENT_TYPE = Symbol['for']('react.fragment');
} else {
  REACT_ELEMENT_TYPE = 0xeac7;
  REACT_CALL_TYPE = 0xeac8;
  REACT_RETURN_TYPE = 0xeac9;
  REACT_FRAGMENT_TYPE = 0xeacb;
}

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var iteratorFn = ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
  return null;
}

function coerceRef(current, element) {
  var mixedRef = element.ref;
  if (mixedRef !== null && typeof mixedRef !== 'function') {
    if (element._owner) {
      var owner = element._owner;
      var inst = void 0;
      if (owner) {
        var ownerFiber = owner;
        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;
        inst = ownerFiber.stateNode;
      }
      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;
      var stringRef = '' + mixedRef;
      // Check if previous string ref matches new string ref
      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {
        return current.ref;
      }
      var ref = function (value) {
        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
        if (value === null) {
          delete refs[stringRef];
        } else {
          refs[stringRef] = value;
        }
      };
      ref._stringRef = stringRef;
      return ref;
    } else {
      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;
      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;
    }
  }
  return mixedRef;
}

function throwOnInvalidObjectType(returnFiber, newChild) {
  if (returnFiber.type !== 'textarea') {
    var addendum = '';
    {
      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');
    }
    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);
  }
}

function warnOnFunctionType() {
  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');

  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;

  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');
}

// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldClone, shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    }
    if (!shouldClone) {
      // When we're reconciling in place we have a work in progress copy. We
      // actually want the current copy. If there is no current copy, then we
      // don't need to track deletion side-effects.
      if (childToDelete.alternate === null) {
        return;
      }
      childToDelete = childToDelete.alternate;
    }
    // Deletions are added in reversed order so we add it to the front.
    // At this point, the return fiber's effect list is empty except for
    // deletions, so we can just append the deletion to the list. The remaining
    // effects aren't added until the complete phase. Once we implement
    // resuming, this may not be true.
    var last = returnFiber.lastEffect;
    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
    childToDelete.nextEffect = null;
    childToDelete.effectTag = Deletion;
  }

  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    }

    // TODO: For the shouldClone case, this could be micro-optimized a bit by
    // assuming that after the first child we've already added everything.
    var childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }

  function mapRemainingChildren(returnFiber, currentFirstChild) {
    // Add the remaining children to a temporary map so that we can find them by
    // keys quickly. Implicit (null) keys get added to this set with their index
    var existingChildren = new Map();

    var existingChild = currentFirstChild;
    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }
      existingChild = existingChild.sibling;
    }
    return existingChildren;
  }

  function useFiber(fiber, pendingProps, expirationTime) {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    if (shouldClone) {
      var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
      clone.index = 0;
      clone.sibling = null;
      return clone;
    } else {
      // We override the expiration time even if it is earlier, because if
      // we're reconciling at a later time that means that this was
      // down-prioritized.
      fiber.expirationTime = expirationTime;
      fiber.effectTag = NoEffect;
      fiber.index = 0;
      fiber.sibling = null;
      fiber.pendingProps = pendingProps;
      return fiber;
    }
  }

  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects) {
      // Noop.
      return lastPlacedIndex;
    }
    var current = newFiber.alternate;
    if (current !== null) {
      var oldIndex = current.index;
      if (oldIndex < lastPlacedIndex) {
        // This is a move.
        newFiber.effectTag = Placement;
        return lastPlacedIndex;
      } else {
        // This item can stay in place.
        return oldIndex;
      }
    } else {
      // This is an insertion.
      newFiber.effectTag = Placement;
      return lastPlacedIndex;
    }
  }

  function placeSingleChild(newFiber) {
    // This is simpler for the single child case. We only need to do a
    // placement for inserting new children.
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.effectTag = Placement;
    }
    return newFiber;
  }

  function updateTextNode(returnFiber, current, textContent, expirationTime) {
    if (current === null || current.tag !== HostText) {
      // Insert
      var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, textContent, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateElement(returnFiber, current, element, expirationTime) {
    if (current !== null && current.type === element.type) {
      // Move based on index
      var existing = useFiber(current, element.props, expirationTime);
      existing.ref = coerceRef(current, element);
      existing['return'] = returnFiber;
      {
        existing._debugSource = element._source;
        existing._debugOwner = element._owner;
      }
      return existing;
    } else {
      // Insert
      var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      created.ref = coerceRef(current, element);
      created['return'] = returnFiber;
      return created;
    }
  }

  function updateCall(returnFiber, current, call, expirationTime) {
    // TODO: Should this also compare handler to determine whether to reuse?
    if (current === null || current.tag !== CallComponent) {
      // Insert
      var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Move based on index
      var existing = useFiber(current, call, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateReturn(returnFiber, current, returnNode, expirationTime) {
    if (current === null || current.tag !== ReturnComponent) {
      // Insert
      var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
      created.type = returnNode.value;
      created['return'] = returnFiber;
      return created;
    } else {
      // Move based on index
      var existing = useFiber(current, null, expirationTime);
      existing.type = returnNode.value;
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updatePortal(returnFiber, current, portal, expirationTime) {
    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
      // Insert
      var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, portal.children || [], expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateFragment(returnFiber, current, fragment, expirationTime, key) {
    if (current === null || current.tag !== Fragment) {
      // Insert
      var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, fragment, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function createChild(returnFiber, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);
              _created['return'] = returnFiber;
              return _created;
            } else {
              var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);
              _created2.ref = coerceRef(null, newChild);
              _created2['return'] = returnFiber;
              return _created2;
            }
          }

        case REACT_CALL_TYPE:
          {
            var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);
            _created3['return'] = returnFiber;
            return _created3;
          }

        case REACT_RETURN_TYPE:
          {
            var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);
            _created4.type = newChild.value;
            _created4['return'] = returnFiber;
            return _created4;
          }

        case REACT_PORTAL_TYPE:
          {
            var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);
            _created5['return'] = returnFiber;
            return _created5;
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);
        _created6['return'] = returnFiber;
        return _created6;
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
    // Update the fiber if the keys match, otherwise return null.

    var key = oldFiber !== null ? oldFiber.key : null;

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      if (key !== null) {
        return null;
      }
      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.key === key) {
              if (newChild.type === REACT_FRAGMENT_TYPE) {
                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
              }
              return updateElement(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_CALL_TYPE:
          {
            if (newChild.key === key) {
              return updateCall(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_RETURN_TYPE:
          {
            // Returns don't have keys. If the previous node is implicitly keyed
            // we can continue to replace it without aborting even if it is not a
            // yield.
            if (key === null) {
              return updateReturn(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_PORTAL_TYPE:
          {
            if (newChild.key === key) {
              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        if (key !== null) {
          return null;
        }

        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys, so we neither have to check the old nor
      // new node for the key. If both are text nodes, they match.
      var matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
            }
            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
          }

        case REACT_CALL_TYPE:
          {
            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);
          }

        case REACT_RETURN_TYPE:
          {
            // Returns don't have keys, so we neither have to check the old nor
            // new node for the key. If both are returns, they match.
            var _matchedFiber3 = existingChildren.get(newIdx) || null;
            return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);
          }

        case REACT_PORTAL_TYPE:
          {
            var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _matchedFiber5 = existingChildren.get(newIdx) || null;
        return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  /**
   * Warns if there is a duplicate or missing key
   */
  function warnOnInvalidKey(child, knownKeys) {
    {
      if (typeof child !== 'object' || child === null) {
        return knownKeys;
      }
      switch (child.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_CALL_TYPE:
        case REACT_PORTAL_TYPE:
          warnForMissingKey(child);
          var key = child.key;
          if (typeof key !== 'string') {
            break;
          }
          if (knownKeys === null) {
            knownKeys = new Set();
            knownKeys.add(key);
            break;
          }
          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }
          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());
          break;
        default:
          break;
      }
    }
    return knownKeys;
  }

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
    // This algorithm can't optimize by searching from boths ends since we
    // don't have backpointers on fibers. I'm trying to see how far we can get
    // with that model. If it ends up not being worth the tradeoffs, we can
    // add it later.

    // Even with a two ended optimization, we'd want to optimize for the case
    // where there are few changes and brute force the comparison instead of
    // going for the Map. It'd like to explore hitting that path first in
    // forward-only mode and only go for the Map once we notice that we need
    // lots of look ahead. This doesn't handle reversal as well as two ended
    // search but that's unusual. Besides, for the two ended optimization to
    // work on Iterables, we'd need to copy the whole set.

    // In this first iteration, we'll just live with hitting the bad case
    // (adding everything to a Map) in for every insert/move.

    // If you change this code, also update reconcileChildrenIterator() which
    // uses the same algorithm.

    {
      // First, validate keys.
      var knownKeys = null;
      for (var i = 0; i < newChildren.length; i++) {
        var child = newChildren[i];
        knownKeys = warnOnInvalidKey(child, knownKeys);
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
        if (!_newFiber) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber;
        } else {
          previousNewFiber.sibling = _newFiber;
        }
        previousNewFiber = _newFiber;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; newIdx < newChildren.length; newIdx++) {
      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);
      if (_newFiber2) {
        if (shouldTrackSideEffects) {
          if (_newFiber2.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber2;
        } else {
          previousNewFiber.sibling = _newFiber2;
        }
        previousNewFiber = _newFiber2;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
    // This is the same implementation as reconcileChildrenArray(),
    // but using the iterator instead.

    var iteratorFn = getIteratorFn(newChildrenIterable);
    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    {
      // Warn about using Maps as children
      if (typeof newChildrenIterable.entries === 'function') {
        var possibleMap = newChildrenIterable;
        if (possibleMap.entries === iteratorFn) {
          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());
          didWarnAboutMaps = true;
        }
      }

      // First, validate keys.
      // We'll get a different iterator later for the main pass.
      var _newChildren = iteratorFn.call(newChildrenIterable);
      if (_newChildren) {
        var knownKeys = null;
        var _step = _newChildren.next();
        for (; !_step.done; _step = _newChildren.next()) {
          var child = _step.value;
          knownKeys = warnOnInvalidKey(child, knownKeys);
        }
      }
    }

    var newChildren = iteratorFn.call(newChildrenIterable);
    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;

    var step = newChildren.next();
    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (!oldFiber) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (step.done) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; !step.done; newIdx++, step = newChildren.next()) {
        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
        if (_newFiber3 === null) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber3;
        } else {
          previousNewFiber.sibling = _newFiber3;
        }
        previousNewFiber = _newFiber3;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; !step.done; newIdx++, step = newChildren.next()) {
      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
      if (_newFiber4 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber4.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber4;
        } else {
          previousNewFiber.sibling = _newFiber4;
        }
        previousNewFiber = _newFiber4;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
    // There's no need to check for keys on text nodes since we don't have a
    // way to define them.
    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
      // We already have an existing node so let's just update it and delete
      // the rest.
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      var existing = useFiber(currentFirstChild, textContent, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
    // The existing first child is not a text node so we need to create one
    // and delete the existing ones.
    deleteRemainingChildren(returnFiber, currentFirstChild);
    var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
    var key = element.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
          existing.ref = coerceRef(child, element);
          existing['return'] = returnFiber;
          {
            existing._debugSource = element._source;
            existing._debugOwner = element._owner;
          }
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);
      created['return'] = returnFiber;
      return created;
    } else {
      var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      _created7.ref = coerceRef(currentFirstChild, element);
      _created7['return'] = returnFiber;
      return _created7;
    }
  }

  function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {
    var key = call.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === CallComponent) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, call, expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {
    // There's no need to check for keys on yields since they're stateless.
    var child = currentFirstChild;
    if (child !== null) {
      if (child.tag === ReturnComponent) {
        deleteRemainingChildren(returnFiber, child.sibling);
        var existing = useFiber(child, null, expirationTime);
        existing.type = returnNode.value;
        existing['return'] = returnFiber;
        return existing;
      } else {
        deleteRemainingChildren(returnFiber, child);
      }
    }

    var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
    created.type = returnNode.value;
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
    var key = portal.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, portal.children || [], expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  // This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
    // This function is not recursive.
    // If the top level item is an array, we treat it as a set of children,
    // not as a fragment. Nested arrays on the other hand will be treated as
    // fragment nodes. Recursion happens at the normal flow.

    // Handle top level unkeyed fragments as if they were arrays.
    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
    // We treat the ambiguous cases above the same.
    if (enableReactFragment && typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {
      newChild = newChild.props.children;
    }

    // Handle object types
    var isObject = typeof newChild === 'object' && newChild !== null;

    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

        case REACT_CALL_TYPE:
          return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_RETURN_TYPE:
          return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_PORTAL_TYPE:
          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
      }
    }

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));
    }

    if (isArray$1(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }
    if (typeof newChild === 'undefined') {
      // If the new child is undefined, and the return fiber is a composite
      // component, throw an error. If Fiber return types are disabled,
      // we already threw above.
      switch (returnFiber.tag) {
        case ClassComponent:
          {
            {
              var instance = returnFiber.stateNode;
              if (instance.render._isMockFunction) {
                // We allow auto-mocks to proceed as if they're returning null.
                break;
              }
            }
          }
        // Intentionally fall through to the next case, which handles both
        // functions and classes
        // eslint-disable-next-lined no-fallthrough
        case FunctionalComponent:
          {
            var Component = returnFiber.type;
            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');
          }
      }
    }

    // Remaining cases are all treated as empty.
    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }

  return reconcileChildFibers;
}

var reconcileChildFibers = ChildReconciler(true, true);

var reconcileChildFibersInPlace = ChildReconciler(false, true);

var mountChildFibersInPlace = ChildReconciler(false, false);

function cloneChildFibers(current, workInProgress) {
  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;

  if (workInProgress.child === null) {
    return;
  }

  var currentChild = workInProgress.child;
  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
  workInProgress.child = newChild;

  newChild['return'] = workInProgress;
  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
    newChild['return'] = workInProgress;
  }
  newChild.sibling = null;
}

{
  var warnedAboutStatelessRefs = {};
}

var ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {
  var shouldSetTextContent = config.shouldSetTextContent,
      useSyncScheduling = config.useSyncScheduling,
      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;
  var pushHostContext = hostContext.pushHostContext,
      pushHostContainer = hostContext.pushHostContainer;
  var enterHydrationState = hydrationContext.enterHydrationState,
      resetHydrationState = hydrationContext.resetHydrationState,
      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;

  var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),
      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,
      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,
      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,
      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;

  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.


  function reconcileChildren(current, workInProgress, nextChildren) {
    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);
  }

  function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {
    if (current === null) {
      // If this is a fresh new component that hasn't been rendered yet, we
      // won't update its child set by applying minimal side-effects. Instead,
      // we will add them all to the child before it gets rendered. That means
      // we can optimize this reconciliation pass by not tracking side-effects.
      workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);
    } else if (current.child === workInProgress.child) {
      // If the current child is the same as the work in progress, it means that
      // we haven't yet started any work on these children. Therefore, we use
      // the clone algorithm to create a copy of all the current children.

      // If we had any progressed work already, that is invalid at this point so
      // let's throw it out.
      workInProgress.child = reconcileChildFibers(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);
    } else {
      // If, on the other hand, it is already using a clone, that means we've
      // already begun some work on this tree and we can continue where we left
      // off by reconciling against the existing children.
      workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);
    }
  }

  function updateFragment(current, workInProgress) {
    var nextChildren = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextChildren === null) {
        nextChildren = workInProgress.memoizedProps;
      }
    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }
    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextChildren);
    return workInProgress.child;
  }

  function markRef(current, workInProgress) {
    var ref = workInProgress.ref;
    if (ref !== null && (!current || current.ref !== ref)) {
      // Schedule a Ref effect
      workInProgress.effectTag |= Ref;
    }
  }

  function updateFunctionalComponent(current, workInProgress) {
    var fn = workInProgress.type;
    var nextProps = workInProgress.pendingProps;

    var memoizedProps = workInProgress.memoizedProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextProps === null) {
        nextProps = memoizedProps;
      }
    } else {
      if (nextProps === null || memoizedProps === nextProps) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      // TODO: consider bringing fn.shouldComponentUpdate() back.
      // It used to be here.
    }

    var unmaskedContext = getUnmaskedContext(workInProgress);
    var context = getMaskedContext(workInProgress, unmaskedContext);

    var nextChildren;

    {
      ReactCurrentOwner.current = workInProgress;
      ReactDebugCurrentFiber.setCurrentPhase('render');
      nextChildren = fn(nextProps, context);
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextProps);
    return workInProgress.child;
  }

  function updateClassComponent(current, workInProgress, renderExpirationTime) {
    // Push context providers early to prevent context stack mismatches.
    // During mounting we don't know the child context yet as the instance doesn't exist.
    // We will invalidate the child context in finishClassComponent() right after rendering.
    var hasContext = pushContextProvider(workInProgress);

    var shouldUpdate = void 0;
    if (current === null) {
      if (!workInProgress.stateNode) {
        // In the initial pass we might need to construct the instance.
        constructClassInstance(workInProgress, workInProgress.pendingProps);
        mountClassInstance(workInProgress, renderExpirationTime);
        shouldUpdate = true;
      } else {
        invariant(false, 'Resuming work not yet implemented.');
        // In a resume, we'll already have an instance we can reuse.
        // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
      }
    } else {
      shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
    }
    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);
  }

  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {
    // Refs should update even if shouldComponentUpdate returns false
    markRef(current, workInProgress);

    if (!shouldUpdate) {
      // Context providers should defer to sCU for rendering
      if (hasContext) {
        invalidateContextProvider(workInProgress, false);
      }

      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var instance = workInProgress.stateNode;

    // Rerender
    ReactCurrentOwner.current = workInProgress;
    var nextChildren = void 0;
    {
      ReactDebugCurrentFiber.setCurrentPhase('render');
      nextChildren = instance.render();
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren);
    // Memoize props and state using the values we just used to render.
    // TODO: Restructure so we never read values from the instance.
    memoizeState(workInProgress, instance.state);
    memoizeProps(workInProgress, instance.props);

    // The context might have changed so we need to recalculate it.
    if (hasContext) {
      invalidateContextProvider(workInProgress, true);
    }

    return workInProgress.child;
  }

  function pushHostRootContext(workInProgress) {
    var root = workInProgress.stateNode;
    if (root.pendingContext) {
      pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
    } else if (root.context) {
      // Should always be set
      pushTopLevelContextObject(workInProgress, root.context, false);
    }
    pushHostContainer(workInProgress, root.containerInfo);
  }

  function updateHostRoot(current, workInProgress, renderExpirationTime) {
    pushHostRootContext(workInProgress);
    var updateQueue = workInProgress.updateQueue;
    if (updateQueue !== null) {
      var prevState = workInProgress.memoizedState;
      var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);
      if (prevState === state) {
        // If the state is the same as before, that's a bailout because we had
        // no work that expires at this time.
        resetHydrationState();
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      var element = state.element;
      var root = workInProgress.stateNode;
      if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
        // If we don't have any current children this might be the first pass.
        // We always try to hydrate. If this isn't a hydration pass there won't
        // be any children to hydrate which is effectively the same thing as
        // not hydrating.

        // This is a bit of a hack. We track the host root as a placement to
        // know that we're currently in a mounting state. That way isMounted
        // works as expected. We must reset this before committing.
        // TODO: Delete this when we delete isMounted and findDOMNode.
        workInProgress.effectTag |= Placement;

        // Ensure that children mount into this root without tracking
        // side-effects. This ensures that we don't store Placement effects on
        // nodes that will be hydrated.
        workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, element, renderExpirationTime);
      } else {
        // Otherwise reset hydration state in case we aborted and resumed another
        // root.
        resetHydrationState();
        reconcileChildren(current, workInProgress, element);
      }
      memoizeState(workInProgress, state);
      return workInProgress.child;
    }
    resetHydrationState();
    // If there is no update queue, that's a bailout because the root has no props.
    return bailoutOnAlreadyFinishedWork(current, workInProgress);
  }

  function updateHostComponent(current, workInProgress, renderExpirationTime) {
    pushHostContext(workInProgress);

    if (current === null) {
      tryToClaimNextHydratableInstance(workInProgress);
    }

    var type = workInProgress.type;
    var memoizedProps = workInProgress.memoizedProps;
    var nextProps = workInProgress.pendingProps;
    if (nextProps === null) {
      nextProps = memoizedProps;
      !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    var prevProps = current !== null ? current.memoizedProps : null;

    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
    } else if (nextProps === null || memoizedProps === nextProps) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var nextChildren = nextProps.children;
    var isDirectTextChild = shouldSetTextContent(type, nextProps);

    if (isDirectTextChild) {
      // We special case a direct text child of a host node. This is a common
      // case. We won't handle it as a reified child. We will instead handle
      // this in the host environment that also have access to this prop. That
      // avoids allocating another HostText fiber and traversing it.
      nextChildren = null;
    } else if (prevProps && shouldSetTextContent(type, prevProps)) {
      // If we're switching from a direct text child to a normal child, or to
      // empty, we need to schedule the text content to be reset.
      workInProgress.effectTag |= ContentReset;
    }

    markRef(current, workInProgress);

    // Check the host config to see if the children are offscreen/hidden.
    if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {
      // Down-prioritize the children.
      workInProgress.expirationTime = Never;
      // Bailout and come back to this fiber later.
      return null;
    }

    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextProps);
    return workInProgress.child;
  }

  function updateHostText(current, workInProgress) {
    if (current === null) {
      tryToClaimNextHydratableInstance(workInProgress);
    }
    var nextProps = workInProgress.pendingProps;
    if (nextProps === null) {
      nextProps = workInProgress.memoizedProps;
    }
    memoizeProps(workInProgress, nextProps);
    // Nothing to do here. This is terminal. We'll do the completion step
    // immediately after.
    return null;
  }

  function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {
    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    var fn = workInProgress.type;
    var props = workInProgress.pendingProps;
    var unmaskedContext = getUnmaskedContext(workInProgress);
    var context = getMaskedContext(workInProgress, unmaskedContext);

    var value;

    {
      if (fn.prototype && typeof fn.prototype.render === 'function') {
        var componentName = getComponentName(workInProgress);
        warning(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);
      }
      ReactCurrentOwner.current = workInProgress;
      value = fn(props, context);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;

    if (typeof value === 'object' && value !== null && typeof value.render === 'function') {
      // Proceed under the assumption that this is a class instance
      workInProgress.tag = ClassComponent;

      // Push context providers early to prevent context stack mismatches.
      // During mounting we don't know the child context yet as the instance doesn't exist.
      // We will invalidate the child context in finishClassComponent() right after rendering.
      var hasContext = pushContextProvider(workInProgress);
      adoptClassInstance(workInProgress, value);
      mountClassInstance(workInProgress, renderExpirationTime);
      return finishClassComponent(current, workInProgress, true, hasContext);
    } else {
      // Proceed under the assumption that this is a functional component
      workInProgress.tag = FunctionalComponent;
      {
        var Component = workInProgress.type;

        if (Component) {
          warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');
        }
        if (workInProgress.ref !== null) {
          var info = '';
          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();
          if (ownerName) {
            info += '\n\nCheck the render method of `' + ownerName + '`.';
          }

          var warningKey = ownerName || workInProgress._debugID || '';
          var debugSource = workInProgress._debugSource;
          if (debugSource) {
            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
          }
          if (!warnedAboutStatelessRefs[warningKey]) {
            warnedAboutStatelessRefs[warningKey] = true;
            warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());
          }
        }
      }
      reconcileChildren(current, workInProgress, value);
      memoizeProps(workInProgress, props);
      return workInProgress.child;
    }
  }

  function updateCallComponent(current, workInProgress, renderExpirationTime) {
    var nextCall = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextCall === null) {
        nextCall = current && current.memoizedProps;
        !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
    } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {
      nextCall = workInProgress.memoizedProps;
      // TODO: When bailing out, we might need to return the stateNode instead
      // of the child. To check it for work.
      // return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var nextChildren = nextCall.children;

    // The following is a fork of reconcileChildrenAtExpirationTime but using
    // stateNode to store the child.
    if (current === null) {
      workInProgress.stateNode = mountChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    } else if (current.child === workInProgress.child) {
      workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    } else {
      workInProgress.stateNode = reconcileChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    }

    memoizeProps(workInProgress, nextCall);
    // This doesn't take arbitrary time so we could synchronously just begin
    // eagerly do the work of workInProgress.child as an optimization.
    return workInProgress.stateNode;
  }

  function updatePortalComponent(current, workInProgress, renderExpirationTime) {
    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
    var nextChildren = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextChildren === null) {
        nextChildren = current && current.memoizedProps;
        !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    if (current === null) {
      // Portals are special because we don't append the children during mount
      // but at commit. Therefore we need to track insertions which the normal
      // flow doesn't do during mount. This doesn't happen at the root because
      // the root always starts with a "current" with a null child.
      // TODO: Consider unifying this with how the root works.
      workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);
      memoizeProps(workInProgress, nextChildren);
    } else {
      reconcileChildren(current, workInProgress, nextChildren);
      memoizeProps(workInProgress, nextChildren);
    }
    return workInProgress.child;
  }

  /*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */

  function bailoutOnAlreadyFinishedWork(current, workInProgress) {
    cancelWorkTimer(workInProgress);

    // TODO: We should ideally be able to bail out early if the children have no
    // more work to do. However, since we don't have a separation of this
    // Fiber's priority and its children yet - we don't know without doing lots
    // of the same work we do anyway. Once we have that separation we can just
    // bail out here if the children has no more work at this priority level.
    // if (workInProgress.priorityOfChildren <= priorityLevel) {
    //   // If there are side-effects in these children that have not yet been
    //   // committed we need to ensure that they get properly transferred up.
    //   if (current && current.child !== workInProgress.child) {
    //     reuseChildrenEffects(workInProgress, child);
    //   }
    //   return null;
    // }

    cloneChildFibers(current, workInProgress);
    return workInProgress.child;
  }

  function bailoutOnLowPriority(current, workInProgress) {
    cancelWorkTimer(workInProgress);

    // TODO: Handle HostComponent tags here as well and call pushHostContext()?
    // See PR 8590 discussion for context
    switch (workInProgress.tag) {
      case HostRoot:
        pushHostRootContext(workInProgress);
        break;
      case ClassComponent:
        pushContextProvider(workInProgress);
        break;
      case HostPortal:
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        break;
    }
    // TODO: What if this is currently in progress?
    // How can that happen? How is this not being cloned?
    return null;
  }

  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead
  function memoizeProps(workInProgress, nextProps) {
    workInProgress.memoizedProps = nextProps;
  }

  function memoizeState(workInProgress, nextState) {
    workInProgress.memoizedState = nextState;
    // Don't reset the updateQueue, in case there are pending updates. Resetting
    // is handled by processUpdateQueue.
  }

  function beginWork(current, workInProgress, renderExpirationTime) {
    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
      return bailoutOnLowPriority(current, workInProgress);
    }

    switch (workInProgress.tag) {
      case IndeterminateComponent:
        return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);
      case FunctionalComponent:
        return updateFunctionalComponent(current, workInProgress);
      case ClassComponent:
        return updateClassComponent(current, workInProgress, renderExpirationTime);
      case HostRoot:
        return updateHostRoot(current, workInProgress, renderExpirationTime);
      case HostComponent:
        return updateHostComponent(current, workInProgress, renderExpirationTime);
      case HostText:
        return updateHostText(current, workInProgress);
      case CallHandlerPhase:
        // This is a restart. Reset the tag to the initial phase.
        workInProgress.tag = CallComponent;
      // Intentionally fall through since this is now the same.
      case CallComponent:
        return updateCallComponent(current, workInProgress, renderExpirationTime);
      case ReturnComponent:
        // A return component is just a placeholder, we can just run through the
        // next one immediately.
        return null;
      case HostPortal:
        return updatePortalComponent(current, workInProgress, renderExpirationTime);
      case Fragment:
        return updateFragment(current, workInProgress);
      default:
        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  function beginFailedWork(current, workInProgress, renderExpirationTime) {
    // Push context providers here to avoid a push/pop context mismatch.
    switch (workInProgress.tag) {
      case ClassComponent:
        pushContextProvider(workInProgress);
        break;
      case HostRoot:
        pushHostRootContext(workInProgress);
        break;
      default:
        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
    }

    // Add an error effect so we can handle the error during the commit phase
    workInProgress.effectTag |= Err;

    // This is a weird case where we do "resume" work — work that failed on
    // our first attempt. Because we no longer have a notion of "progressed
    // deletions," reset the child to the current child to make sure we delete
    // it again. TODO: Find a better way to handle this, perhaps during a more
    // general overhaul of error handling.
    if (current === null) {
      workInProgress.child = null;
    } else if (workInProgress.child !== current.child) {
      workInProgress.child = current.child;
    }

    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
      return bailoutOnLowPriority(current, workInProgress);
    }

    // If we don't bail out, we're going be recomputing our children so we need
    // to drop our effect list.
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;

    // Unmount the current children as if the component rendered null
    var nextChildren = null;
    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);

    if (workInProgress.tag === ClassComponent) {
      var instance = workInProgress.stateNode;
      workInProgress.memoizedProps = instance.props;
      workInProgress.memoizedState = instance.state;
    }

    return workInProgress.child;
  }

  return {
    beginWork: beginWork,
    beginFailedWork: beginFailedWork
  };
};

var ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {
  var createInstance = config.createInstance,
      createTextInstance = config.createTextInstance,
      appendInitialChild = config.appendInitialChild,
      finalizeInitialChildren = config.finalizeInitialChildren,
      prepareUpdate = config.prepareUpdate,
      mutation = config.mutation,
      persistence = config.persistence;
  var getRootHostContainer = hostContext.getRootHostContainer,
      popHostContext = hostContext.popHostContext,
      getHostContext = hostContext.getHostContext,
      popHostContainer = hostContext.popHostContainer;
  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,
      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,
      popHydrationState = hydrationContext.popHydrationState;


  function markUpdate(workInProgress) {
    // Tag the fiber with an update effect. This turns a Placement into
    // an UpdateAndPlacement.
    workInProgress.effectTag |= Update;
  }

  function markRef(workInProgress) {
    workInProgress.effectTag |= Ref;
  }

  function appendAllReturns(returns, workInProgress) {
    var node = workInProgress.stateNode;
    if (node) {
      node['return'] = workInProgress;
    }
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {
        invariant(false, 'A call cannot have host component children.');
      } else if (node.tag === ReturnComponent) {
        returns.push(node.type);
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === workInProgress) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {
    var call = workInProgress.memoizedProps;
    !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    // First step of the call has completed. Now we need to do the second.
    // TODO: It would be nice to have a multi stage call represented by a
    // single component, or at least tail call optimize nested ones. Currently
    // that requires additional fields that we don't want to add to the fiber.
    // So this requires nested handlers.
    // Note: This doesn't mutate the alternate node. I don't think it needs to
    // since this stage is reset for every pass.
    workInProgress.tag = CallHandlerPhase;

    // Build up the returns.
    // TODO: Compare this to a generator or opaque helpers like Children.
    var returns = [];
    appendAllReturns(returns, workInProgress);
    var fn = call.handler;
    var props = call.props;
    var nextChildren = fn(props, returns);

    var currentFirstChild = current !== null ? current.child : null;
    workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);
    return workInProgress.child;
  }

  function appendAllChildren(parent, workInProgress) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText) {
        appendInitialChild(parent, node.stateNode);
      } else if (node.tag === HostPortal) {
        // If we have a portal child, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === workInProgress) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === workInProgress) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  var updateHostContainer = void 0;
  var updateHostComponent = void 0;
  var updateHostText = void 0;
  if (mutation) {
    if (enableMutatingReconciler) {
      // Mutation mode
      updateHostContainer = function (workInProgress) {
        // Noop
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // TODO: Type this specific to this type of component.
        workInProgress.updateQueue = updatePayload;
        // If the update payload indicates that there is a change or if there
        // is a new ref we mark this as an update. All the work is done in commitWork.
        if (updatePayload) {
          markUpdate(workInProgress);
        }
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        // If the text differs, mark it as an update. All the work in done in commitWork.
        if (oldText !== newText) {
          markUpdate(workInProgress);
        }
      };
    } else {
      invariant(false, 'Mutating reconciler is disabled.');
    }
  } else if (persistence) {
    if (enablePersistentReconciler) {
      // Persistent host tree mode
      var cloneInstance = persistence.cloneInstance,
          createContainerChildSet = persistence.createContainerChildSet,
          appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,
          finalizeContainerChildren = persistence.finalizeContainerChildren;

      // An unfortunate fork of appendAllChildren because we have two different parent types.

      var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {
        // We only have the top Fiber that was created but we need recurse down its
        // children to find all the terminal nodes.
        var node = workInProgress.child;
        while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
            appendChildToContainerChildSet(containerChildSet, node.stateNode);
          } else if (node.tag === HostPortal) {
            // If we have a portal child, then we don't want to traverse
            // down its children. Instead, we'll get insertions from each child in
            // the portal directly.
          } else if (node.child !== null) {
            node.child['return'] = node;
            node = node.child;
            continue;
          }
          if (node === workInProgress) {
            return;
          }
          while (node.sibling === null) {
            if (node['return'] === null || node['return'] === workInProgress) {
              return;
            }
            node = node['return'];
          }
          node.sibling['return'] = node['return'];
          node = node.sibling;
        }
      };
      updateHostContainer = function (workInProgress) {
        var portalOrRoot = workInProgress.stateNode;
        var childrenUnchanged = workInProgress.firstEffect === null;
        if (childrenUnchanged) {
          // No changes, just reuse the existing instance.
        } else {
          var container = portalOrRoot.containerInfo;
          var newChildSet = createContainerChildSet(container);
          if (finalizeContainerChildren(container, newChildSet)) {
            markUpdate(workInProgress);
          }
          portalOrRoot.pendingChildren = newChildSet;
          // If children might have changed, we have to add them all to the set.
          appendAllChildrenToContainer(newChildSet, workInProgress);
          // Schedule an update on the container to swap out the container.
          markUpdate(workInProgress);
        }
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // If there are no effects associated with this node, then none of our children had any updates.
        // This guarantees that we can reuse all of them.
        var childrenUnchanged = workInProgress.firstEffect === null;
        var currentInstance = current.stateNode;
        if (childrenUnchanged && updatePayload === null) {
          // No changes, just reuse the existing instance.
          // Note that this might release a previous clone.
          workInProgress.stateNode = currentInstance;
        } else {
          var recyclableInstance = workInProgress.stateNode;
          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);
          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {
            markUpdate(workInProgress);
          }
          workInProgress.stateNode = newInstance;
          if (childrenUnchanged) {
            // If there are no other effects in this tree, we need to flag this node as having one.
            // Even though we're not going to use it for anything.
            // Otherwise parents won't know that there are new children to propagate upwards.
            markUpdate(workInProgress);
          } else {
            // If children might have changed, we have to add them all to the set.
            appendAllChildren(newInstance, workInProgress);
          }
        }
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        if (oldText !== newText) {
          // If the text content differs, we'll create a new text instance for it.
          var rootContainerInstance = getRootHostContainer();
          var currentHostContext = getHostContext();
          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
          // We'll have to mark it as having an effect, even though we won't use the effect for anything.
          // This lets the parents know that at least one of their children has changed.
          markUpdate(workInProgress);
        }
      };
    } else {
      invariant(false, 'Persistent reconciler is disabled.');
    }
  } else {
    if (enableNoopReconciler) {
      // No host operations
      updateHostContainer = function (workInProgress) {
        // Noop
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // Noop
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        // Noop
      };
    } else {
      invariant(false, 'Noop reconciler is disabled.');
    }
  }

  function completeWork(current, workInProgress, renderExpirationTime) {
    // Get the latest props.
    var newProps = workInProgress.pendingProps;
    if (newProps === null) {
      newProps = workInProgress.memoizedProps;
    } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {
      // Reset the pending props, unless this was a down-prioritization.
      workInProgress.pendingProps = null;
    }

    switch (workInProgress.tag) {
      case FunctionalComponent:
        return null;
      case ClassComponent:
        {
          // We are leaving this subtree, so pop context if any.
          popContextProvider(workInProgress);
          return null;
        }
      case HostRoot:
        {
          popHostContainer(workInProgress);
          popTopLevelContextObject(workInProgress);
          var fiberRoot = workInProgress.stateNode;
          if (fiberRoot.pendingContext) {
            fiberRoot.context = fiberRoot.pendingContext;
            fiberRoot.pendingContext = null;
          }

          if (current === null || current.child === null) {
            // If we hydrated, pop so that we can delete any remaining children
            // that weren't hydrated.
            popHydrationState(workInProgress);
            // This resets the hacky state to fix isMounted before committing.
            // TODO: Delete this when we delete isMounted and findDOMNode.
            workInProgress.effectTag &= ~Placement;
          }
          updateHostContainer(workInProgress);
          return null;
        }
      case HostComponent:
        {
          popHostContext(workInProgress);
          var rootContainerInstance = getRootHostContainer();
          var type = workInProgress.type;
          if (current !== null && workInProgress.stateNode != null) {
            // If we have an alternate, that means this is an update and we need to
            // schedule a side-effect to do the updates.
            var oldProps = current.memoizedProps;
            // If we get updated because one of our children updated, we don't
            // have newProps so we'll have to reuse them.
            // TODO: Split the update API as separate for the props vs. children.
            // Even better would be if children weren't special cased at all tho.
            var instance = workInProgress.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);

            updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);

            if (current.ref !== workInProgress.ref) {
              markRef(workInProgress);
            }
          } else {
            if (!newProps) {
              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              // This can happen when we abort work.
              return null;
            }

            var _currentHostContext = getHostContext();
            // TODO: Move createInstance to beginWork and keep it on a context
            // "stack" as the parent. Then append children as we go in beginWork
            // or completeWork depending on we want to add then top->down or
            // bottom->up. Top->down is faster in IE11.
            var wasHydrated = popHydrationState(workInProgress);
            if (wasHydrated) {
              // TODO: Move this and createInstance step into the beginPhase
              // to consolidate.
              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {
                // If changes to the hydrated node needs to be applied at the
                // commit-phase we mark this as such.
                markUpdate(workInProgress);
              }
            } else {
              var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);

              appendAllChildren(_instance, workInProgress);

              // Certain renderers require commit-time effects for initial mount.
              // (eg DOM renderer supports auto-focus for certain elements).
              // Make sure such renderers get scheduled for later work.
              if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {
                markUpdate(workInProgress);
              }
              workInProgress.stateNode = _instance;
            }

            if (workInProgress.ref !== null) {
              // If there is a ref on a host node we need to schedule a callback
              markRef(workInProgress);
            }
          }
          return null;
        }
      case HostText:
        {
          var newText = newProps;
          if (current && workInProgress.stateNode != null) {
            var oldText = current.memoizedProps;
            // If we have an alternate, that means this is an update and we need
            // to schedule a side-effect to do the updates.
            updateHostText(current, workInProgress, oldText, newText);
          } else {
            if (typeof newText !== 'string') {
              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              // This can happen when we abort work.
              return null;
            }
            var _rootContainerInstance = getRootHostContainer();
            var _currentHostContext2 = getHostContext();
            var _wasHydrated = popHydrationState(workInProgress);
            if (_wasHydrated) {
              if (prepareToHydrateHostTextInstance(workInProgress)) {
                markUpdate(workInProgress);
              }
            } else {
              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);
            }
          }
          return null;
        }
      case CallComponent:
        return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);
      case CallHandlerPhase:
        // Reset the tag to now be a first phase call.
        workInProgress.tag = CallComponent;
        return null;
      case ReturnComponent:
        // Does nothing.
        return null;
      case Fragment:
        return null;
      case HostPortal:
        popHostContainer(workInProgress);
        updateHostContainer(workInProgress);
        return null;
      // Error cases
      case IndeterminateComponent:
        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');
      // eslint-disable-next-line no-fallthrough
      default:
        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  return {
    completeWork: completeWork
  };
};

var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;
var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;
var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;


var ReactFiberCommitWork = function (config, captureError) {
  var getPublicInstance = config.getPublicInstance,
      mutation = config.mutation,
      persistence = config.persistence;


  var callComponentWillUnmountWithTimer = function (current, instance) {
    startPhaseTimer(current, 'componentWillUnmount');
    instance.props = current.memoizedProps;
    instance.state = current.memoizedState;
    instance.componentWillUnmount();
    stopPhaseTimer();
  };

  // Capture errors so they don't interrupt unmounting.
  function safelyCallComponentWillUnmount(current, instance) {
    {
      invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);
      if (hasCaughtError$1()) {
        var unmountError = clearCaughtError$1();
        captureError(current, unmountError);
      }
    }
  }

  function safelyDetachRef(current) {
    var ref = current.ref;
    if (ref !== null) {
      {
        invokeGuardedCallback$2(null, ref, null, null);
        if (hasCaughtError$1()) {
          var refError = clearCaughtError$1();
          captureError(current, refError);
        }
      }
    }
  }

  function commitLifeCycles(current, finishedWork) {
    switch (finishedWork.tag) {
      case ClassComponent:
        {
          var instance = finishedWork.stateNode;
          if (finishedWork.effectTag & Update) {
            if (current === null) {
              startPhaseTimer(finishedWork, 'componentDidMount');
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidMount();
              stopPhaseTimer();
            } else {
              var prevProps = current.memoizedProps;
              var prevState = current.memoizedState;
              startPhaseTimer(finishedWork, 'componentDidUpdate');
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidUpdate(prevProps, prevState);
              stopPhaseTimer();
            }
          }
          var updateQueue = finishedWork.updateQueue;
          if (updateQueue !== null) {
            commitCallbacks(updateQueue, instance);
          }
          return;
        }
      case HostRoot:
        {
          var _updateQueue = finishedWork.updateQueue;
          if (_updateQueue !== null) {
            var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;
            commitCallbacks(_updateQueue, _instance);
          }
          return;
        }
      case HostComponent:
        {
          var _instance2 = finishedWork.stateNode;

          // Renderers may schedule work to be done after host components are mounted
          // (eg DOM renderer may schedule auto-focus for inputs and form controls).
          // These effects should only be committed when components are first mounted,
          // aka when there is no current/alternate.
          if (current === null && finishedWork.effectTag & Update) {
            var type = finishedWork.type;
            var props = finishedWork.memoizedProps;
            commitMount(_instance2, type, props, finishedWork);
          }

          return;
        }
      case HostText:
        {
          // We have no life-cycles associated with text.
          return;
        }
      case HostPortal:
        {
          // We have no life-cycles associated with portals.
          return;
        }
      default:
        {
          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
        }
    }
  }

  function commitAttachRef(finishedWork) {
    var ref = finishedWork.ref;
    if (ref !== null) {
      var instance = finishedWork.stateNode;
      switch (finishedWork.tag) {
        case HostComponent:
          ref(getPublicInstance(instance));
          break;
        default:
          ref(instance);
      }
    }
  }

  function commitDetachRef(current) {
    var currentRef = current.ref;
    if (currentRef !== null) {
      currentRef(null);
    }
  }

  // User-originating errors (lifecycles and refs) should not interrupt
  // deletion, so don't let them throw. Host-originating errors should
  // interrupt deletion, so it's okay
  function commitUnmount(current) {
    if (typeof onCommitUnmount === 'function') {
      onCommitUnmount(current);
    }

    switch (current.tag) {
      case ClassComponent:
        {
          safelyDetachRef(current);
          var instance = current.stateNode;
          if (typeof instance.componentWillUnmount === 'function') {
            safelyCallComponentWillUnmount(current, instance);
          }
          return;
        }
      case HostComponent:
        {
          safelyDetachRef(current);
          return;
        }
      case CallComponent:
        {
          commitNestedUnmounts(current.stateNode);
          return;
        }
      case HostPortal:
        {
          // TODO: this is recursive.
          // We are also not using this parent because
          // the portal will get pushed immediately.
          if (enableMutatingReconciler && mutation) {
            unmountHostComponents(current);
          } else if (enablePersistentReconciler && persistence) {
            emptyPortalContainer(current);
          }
          return;
        }
    }
  }

  function commitNestedUnmounts(root) {
    // While we're inside a removed host node we don't want to call
    // removeChild on the inner nodes because they're removed by the top
    // call anyway. We also want to call componentWillUnmount on all
    // composites before this host node is removed from the tree. Therefore
    var node = root;
    while (true) {
      commitUnmount(node);
      // Visit children because they may contain more composite or host nodes.
      // Skip portals because commitUnmount() currently visits them recursively.
      if (node.child !== null && (
      // If we use mutation we drill down into portals using commitUnmount above.
      // If we don't use mutation we drill down into portals here instead.
      !mutation || node.tag !== HostPortal)) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === root) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === root) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function detachFiber(current) {
    // Cut off the return pointers to disconnect it from the tree. Ideally, we
    // should clear the child pointer of the parent alternate to let this
    // get GC:ed but we don't know which for sure which parent is the current
    // one so we'll settle for GC:ing the subtree of this child. This child
    // itself will be GC:ed when the parent updates the next time.
    current['return'] = null;
    current.child = null;
    if (current.alternate) {
      current.alternate.child = null;
      current.alternate['return'] = null;
    }
  }

  if (!mutation) {
    var commitContainer = void 0;
    if (persistence) {
      var replaceContainerChildren = persistence.replaceContainerChildren,
          createContainerChildSet = persistence.createContainerChildSet;

      var emptyPortalContainer = function (current) {
        var portal = current.stateNode;
        var containerInfo = portal.containerInfo;

        var emptyChildSet = createContainerChildSet(containerInfo);
        replaceContainerChildren(containerInfo, emptyChildSet);
      };
      commitContainer = function (finishedWork) {
        switch (finishedWork.tag) {
          case ClassComponent:
            {
              return;
            }
          case HostComponent:
            {
              return;
            }
          case HostText:
            {
              return;
            }
          case HostRoot:
          case HostPortal:
            {
              var portalOrRoot = finishedWork.stateNode;
              var containerInfo = portalOrRoot.containerInfo,
                  _pendingChildren = portalOrRoot.pendingChildren;

              replaceContainerChildren(containerInfo, _pendingChildren);
              return;
            }
          default:
            {
              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
            }
        }
      };
    } else {
      commitContainer = function (finishedWork) {
        // Noop
      };
    }
    if (enablePersistentReconciler || enableNoopReconciler) {
      return {
        commitResetTextContent: function (finishedWork) {},
        commitPlacement: function (finishedWork) {},
        commitDeletion: function (current) {
          // Detach refs and call componentWillUnmount() on the whole subtree.
          commitNestedUnmounts(current);
          detachFiber(current);
        },
        commitWork: function (current, finishedWork) {
          commitContainer(finishedWork);
        },

        commitLifeCycles: commitLifeCycles,
        commitAttachRef: commitAttachRef,
        commitDetachRef: commitDetachRef
      };
    } else if (persistence) {
      invariant(false, 'Persistent reconciler is disabled.');
    } else {
      invariant(false, 'Noop reconciler is disabled.');
    }
  }
  var commitMount = mutation.commitMount,
      commitUpdate = mutation.commitUpdate,
      resetTextContent = mutation.resetTextContent,
      commitTextUpdate = mutation.commitTextUpdate,
      appendChild = mutation.appendChild,
      appendChildToContainer = mutation.appendChildToContainer,
      insertBefore = mutation.insertBefore,
      insertInContainerBefore = mutation.insertInContainerBefore,
      removeChild = mutation.removeChild,
      removeChildFromContainer = mutation.removeChildFromContainer;


  function getHostParentFiber(fiber) {
    var parent = fiber['return'];
    while (parent !== null) {
      if (isHostParent(parent)) {
        return parent;
      }
      parent = parent['return'];
    }
    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');
  }

  function isHostParent(fiber) {
    return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
  }

  function getHostSibling(fiber) {
    // We're going to search forward into the tree until we find a sibling host
    // node. Unfortunately, if multiple insertions are done in a row we have to
    // search past them. This leads to exponential search for the next sibling.
    var node = fiber;
    siblings: while (true) {
      // If we didn't find anything, let's try the next sibling.
      while (node.sibling === null) {
        if (node['return'] === null || isHostParent(node['return'])) {
          // If we pop out of the root or hit the parent the fiber we are the
          // last sibling.
          return null;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
      while (node.tag !== HostComponent && node.tag !== HostText) {
        // If it is not host node and, we might have a host node inside it.
        // Try to search down until we find one.
        if (node.effectTag & Placement) {
          // If we don't have a child, try the siblings instead.
          continue siblings;
        }
        // If we don't have a child, try the siblings instead.
        // We also skip portals because they are not part of this host tree.
        if (node.child === null || node.tag === HostPortal) {
          continue siblings;
        } else {
          node.child['return'] = node;
          node = node.child;
        }
      }
      // Check if this host node is stable or about to be placed.
      if (!(node.effectTag & Placement)) {
        // Found it!
        return node.stateNode;
      }
    }
  }

  function commitPlacement(finishedWork) {
    // Recursively insert all host nodes into the parent.
    var parentFiber = getHostParentFiber(finishedWork);
    var parent = void 0;
    var isContainer = void 0;
    switch (parentFiber.tag) {
      case HostComponent:
        parent = parentFiber.stateNode;
        isContainer = false;
        break;
      case HostRoot:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = true;
        break;
      case HostPortal:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = true;
        break;
      default:
        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');
    }
    if (parentFiber.effectTag & ContentReset) {
      // Reset the text content of the parent before doing any insertions
      resetTextContent(parent);
      // Clear ContentReset from the effect tag
      parentFiber.effectTag &= ~ContentReset;
    }

    var before = getHostSibling(finishedWork);
    // We only have the top Fiber that was inserted but we need recurse down its
    // children to find all the terminal nodes.
    var node = finishedWork;
    while (true) {
      if (node.tag === HostComponent || node.tag === HostText) {
        if (before) {
          if (isContainer) {
            insertInContainerBefore(parent, node.stateNode, before);
          } else {
            insertBefore(parent, node.stateNode, before);
          }
        } else {
          if (isContainer) {
            appendChildToContainer(parent, node.stateNode);
          } else {
            appendChild(parent, node.stateNode);
          }
        }
      } else if (node.tag === HostPortal) {
        // If the insertion itself is a portal, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === finishedWork) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === finishedWork) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function unmountHostComponents(current) {
    // We only have the top Fiber that was inserted but we need recurse down its
    var node = current;

    // Each iteration, currentParent is populated with node's host parent if not
    // currentParentIsValid.
    var currentParentIsValid = false;
    var currentParent = void 0;
    var currentParentIsContainer = void 0;

    while (true) {
      if (!currentParentIsValid) {
        var parent = node['return'];
        findParent: while (true) {
          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          switch (parent.tag) {
            case HostComponent:
              currentParent = parent.stateNode;
              currentParentIsContainer = false;
              break findParent;
            case HostRoot:
              currentParent = parent.stateNode.containerInfo;
              currentParentIsContainer = true;
              break findParent;
            case HostPortal:
              currentParent = parent.stateNode.containerInfo;
              currentParentIsContainer = true;
              break findParent;
          }
          parent = parent['return'];
        }
        currentParentIsValid = true;
      }

      if (node.tag === HostComponent || node.tag === HostText) {
        commitNestedUnmounts(node);
        // After all the children have unmounted, it is now safe to remove the
        // node from the tree.
        if (currentParentIsContainer) {
          removeChildFromContainer(currentParent, node.stateNode);
        } else {
          removeChild(currentParent, node.stateNode);
        }
        // Don't visit children because we already visited them.
      } else if (node.tag === HostPortal) {
        // When we go into a portal, it becomes the parent to remove from.
        // We will reassign it back when we pop the portal on the way up.
        currentParent = node.stateNode.containerInfo;
        // Visit children because portals might contain host components.
        if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
      } else {
        commitUnmount(node);
        // Visit children because we may find more host components below.
        if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
      }
      if (node === current) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === current) {
          return;
        }
        node = node['return'];
        if (node.tag === HostPortal) {
          // When we go out of the portal, we need to restore the parent.
          // Since we don't keep a stack of them, we will search for it.
          currentParentIsValid = false;
        }
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function commitDeletion(current) {
    // Recursively delete all host nodes from the parent.
    // Detach refs and call componentWillUnmount() on the whole subtree.
    unmountHostComponents(current);
    detachFiber(current);
  }

  function commitWork(current, finishedWork) {
    switch (finishedWork.tag) {
      case ClassComponent:
        {
          return;
        }
      case HostComponent:
        {
          var instance = finishedWork.stateNode;
          if (instance != null) {
            // Commit the work prepared earlier.
            var newProps = finishedWork.memoizedProps;
            // For hydration we reuse the update path but we treat the oldProps
            // as the newProps. The updatePayload will contain the real change in
            // this case.
            var oldProps = current !== null ? current.memoizedProps : newProps;
            var type = finishedWork.type;
            // TODO: Type the updateQueue to be specific to host components.
            var updatePayload = finishedWork.updateQueue;
            finishedWork.updateQueue = null;
            if (updatePayload !== null) {
              commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
            }
          }
          return;
        }
      case HostText:
        {
          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          var textInstance = finishedWork.stateNode;
          var newText = finishedWork.memoizedProps;
          // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.
          var oldText = current !== null ? current.memoizedProps : newText;
          commitTextUpdate(textInstance, oldText, newText);
          return;
        }
      case HostRoot:
        {
          return;
        }
      default:
        {
          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
        }
    }
  }

  function commitResetTextContent(current) {
    resetTextContent(current.stateNode);
  }

  if (enableMutatingReconciler) {
    return {
      commitResetTextContent: commitResetTextContent,
      commitPlacement: commitPlacement,
      commitDeletion: commitDeletion,
      commitWork: commitWork,
      commitLifeCycles: commitLifeCycles,
      commitAttachRef: commitAttachRef,
      commitDetachRef: commitDetachRef
    };
  } else {
    invariant(false, 'Mutating reconciler is disabled.');
  }
};

var NO_CONTEXT = {};

var ReactFiberHostContext = function (config) {
  var getChildHostContext = config.getChildHostContext,
      getRootHostContext = config.getRootHostContext;


  var contextStackCursor = createCursor(NO_CONTEXT);
  var contextFiberStackCursor = createCursor(NO_CONTEXT);
  var rootInstanceStackCursor = createCursor(NO_CONTEXT);

  function requiredContext(c) {
    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    return c;
  }

  function getRootHostContainer() {
    var rootInstance = requiredContext(rootInstanceStackCursor.current);
    return rootInstance;
  }

  function pushHostContainer(fiber, nextRootInstance) {
    // Push current root instance onto the stack;
    // This allows us to reset root when portals are popped.
    push(rootInstanceStackCursor, nextRootInstance, fiber);

    var nextRootContext = getRootHostContext(nextRootInstance);

    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, nextRootContext, fiber);
  }

  function popHostContainer(fiber) {
    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
    pop(rootInstanceStackCursor, fiber);
  }

  function getHostContext() {
    var context = requiredContext(contextStackCursor.current);
    return context;
  }

  function pushHostContext(fiber) {
    var rootInstance = requiredContext(rootInstanceStackCursor.current);
    var context = requiredContext(contextStackCursor.current);
    var nextContext = getChildHostContext(context, fiber.type, rootInstance);

    // Don't push this Fiber's context unless it's unique.
    if (context === nextContext) {
      return;
    }

    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, nextContext, fiber);
  }

  function popHostContext(fiber) {
    // Do not pop unless this Fiber provided the current context.
    // pushHostContext() only pushes Fibers that provide unique contexts.
    if (contextFiberStackCursor.current !== fiber) {
      return;
    }

    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
  }

  function resetHostContainer() {
    contextStackCursor.current = NO_CONTEXT;
    rootInstanceStackCursor.current = NO_CONTEXT;
  }

  return {
    getHostContext: getHostContext,
    getRootHostContainer: getRootHostContainer,
    popHostContainer: popHostContainer,
    popHostContext: popHostContext,
    pushHostContainer: pushHostContainer,
    pushHostContext: pushHostContext,
    resetHostContainer: resetHostContainer
  };
};

var ReactFiberHydrationContext = function (config) {
  var shouldSetTextContent = config.shouldSetTextContent,
      hydration = config.hydration;

  // If this doesn't have hydration mode.

  if (!hydration) {
    return {
      enterHydrationState: function () {
        return false;
      },
      resetHydrationState: function () {},
      tryToClaimNextHydratableInstance: function () {},
      prepareToHydrateHostInstance: function () {
        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
      },
      prepareToHydrateHostTextInstance: function () {
        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
      },
      popHydrationState: function (fiber) {
        return false;
      }
    };
  }

  var canHydrateInstance = hydration.canHydrateInstance,
      canHydrateTextInstance = hydration.canHydrateTextInstance,
      getNextHydratableSibling = hydration.getNextHydratableSibling,
      getFirstHydratableChild = hydration.getFirstHydratableChild,
      hydrateInstance = hydration.hydrateInstance,
      hydrateTextInstance = hydration.hydrateTextInstance,
      didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,
      didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,
      didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,
      didNotHydrateInstance = hydration.didNotHydrateInstance,
      didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,
      didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,
      didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,
      didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;

  // The deepest Fiber on the stack involved in a hydration context.
  // This may have been an insertion or a hydration.

  var hydrationParentFiber = null;
  var nextHydratableInstance = null;
  var isHydrating = false;

  function enterHydrationState(fiber) {
    var parentInstance = fiber.stateNode.containerInfo;
    nextHydratableInstance = getFirstHydratableChild(parentInstance);
    hydrationParentFiber = fiber;
    isHydrating = true;
    return true;
  }

  function deleteHydratableInstance(returnFiber, instance) {
    {
      switch (returnFiber.tag) {
        case HostRoot:
          didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
          break;
        case HostComponent:
          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
          break;
      }
    }

    var childToDelete = createFiberFromHostInstanceForDeletion();
    childToDelete.stateNode = instance;
    childToDelete['return'] = returnFiber;
    childToDelete.effectTag = Deletion;

    // This might seem like it belongs on progressedFirstDeletion. However,
    // these children are not part of the reconciliation list of children.
    // Even if we abort and rereconcile the children, that will try to hydrate
    // again and the nodes are still in the host tree so these will be
    // recreated.
    if (returnFiber.lastEffect !== null) {
      returnFiber.lastEffect.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
  }

  function insertNonHydratedInstance(returnFiber, fiber) {
    fiber.effectTag |= Placement;
    {
      switch (returnFiber.tag) {
        case HostRoot:
          {
            var parentContainer = returnFiber.stateNode.containerInfo;
            switch (fiber.tag) {
              case HostComponent:
                var type = fiber.type;
                var props = fiber.pendingProps;
                didNotFindHydratableContainerInstance(parentContainer, type, props);
                break;
              case HostText:
                var text = fiber.pendingProps;
                didNotFindHydratableContainerTextInstance(parentContainer, text);
                break;
            }
            break;
          }
        case HostComponent:
          {
            var parentType = returnFiber.type;
            var parentProps = returnFiber.memoizedProps;
            var parentInstance = returnFiber.stateNode;
            switch (fiber.tag) {
              case HostComponent:
                var _type = fiber.type;
                var _props = fiber.pendingProps;
                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                break;
              case HostText:
                var _text = fiber.pendingProps;
                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                break;
            }
            break;
          }
        default:
          return;
      }
    }
  }

  function tryHydrate(fiber, nextInstance) {
    switch (fiber.tag) {
      case HostComponent:
        {
          var type = fiber.type;
          var props = fiber.pendingProps;
          var instance = canHydrateInstance(nextInstance, type, props);
          if (instance !== null) {
            fiber.stateNode = instance;
            return true;
          }
          return false;
        }
      case HostText:
        {
          var text = fiber.pendingProps;
          var textInstance = canHydrateTextInstance(nextInstance, text);
          if (textInstance !== null) {
            fiber.stateNode = textInstance;
            return true;
          }
          return false;
        }
      default:
        return false;
    }
  }

  function tryToClaimNextHydratableInstance(fiber) {
    if (!isHydrating) {
      return;
    }
    var nextInstance = nextHydratableInstance;
    if (!nextInstance) {
      // Nothing to hydrate. Make it an insertion.
      insertNonHydratedInstance(hydrationParentFiber, fiber);
      isHydrating = false;
      hydrationParentFiber = fiber;
      return;
    }
    if (!tryHydrate(fiber, nextInstance)) {
      // If we can't hydrate this instance let's try the next one.
      // We use this as a heuristic. It's based on intuition and not data so it
      // might be flawed or unnecessary.
      nextInstance = getNextHydratableSibling(nextInstance);
      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
        // Nothing to hydrate. Make it an insertion.
        insertNonHydratedInstance(hydrationParentFiber, fiber);
        isHydrating = false;
        hydrationParentFiber = fiber;
        return;
      }
      // We matched the next one, we'll now assume that the first one was
      // superfluous and we'll delete it. Since we can't eagerly delete it
      // we'll have to schedule a deletion. To do that, this node needs a dummy
      // fiber associated with it.
      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);
    }
    hydrationParentFiber = fiber;
    nextHydratableInstance = getFirstHydratableChild(nextInstance);
  }

  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
    var instance = fiber.stateNode;
    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
    // TODO: Type this specific to this type of component.
    fiber.updateQueue = updatePayload;
    // If the update payload indicates that there is a change or if there
    // is a new ref we mark this as an update.
    if (updatePayload !== null) {
      return true;
    }
    return false;
  }

  function prepareToHydrateHostTextInstance(fiber) {
    var textInstance = fiber.stateNode;
    var textContent = fiber.memoizedProps;
    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
    {
      if (shouldUpdate) {
        // We assume that prepareToHydrateHostTextInstance is called in a context where the
        // hydration parent is the parent host component of this host text.
        var returnFiber = hydrationParentFiber;
        if (returnFiber !== null) {
          switch (returnFiber.tag) {
            case HostRoot:
              {
                var parentContainer = returnFiber.stateNode.containerInfo;
                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                break;
              }
            case HostComponent:
              {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                break;
              }
          }
        }
      }
    }
    return shouldUpdate;
  }

  function popToNextHostParent(fiber) {
    var parent = fiber['return'];
    while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
      parent = parent['return'];
    }
    hydrationParentFiber = parent;
  }

  function popHydrationState(fiber) {
    if (fiber !== hydrationParentFiber) {
      // We're deeper than the current hydration context, inside an inserted
      // tree.
      return false;
    }
    if (!isHydrating) {
      // If we're not currently hydrating but we're in a hydration context, then
      // we were an insertion and now need to pop up reenter hydration of our
      // siblings.
      popToNextHostParent(fiber);
      isHydrating = true;
      return false;
    }

    var type = fiber.type;

    // If we have any remaining hydratable nodes, we need to delete them now.
    // We only do this deeper than head and body since they tend to have random
    // other nodes in them. We also ignore components with pure text content in
    // side of them.
    // TODO: Better heuristic.
    if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
      var nextInstance = nextHydratableInstance;
      while (nextInstance) {
        deleteHydratableInstance(fiber, nextInstance);
        nextInstance = getNextHydratableSibling(nextInstance);
      }
    }

    popToNextHostParent(fiber);
    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
    return true;
  }

  function resetHydrationState() {
    hydrationParentFiber = null;
    nextHydratableInstance = null;
    isHydrating = false;
  }

  return {
    enterHydrationState: enterHydrationState,
    resetHydrationState: resetHydrationState,
    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,
    prepareToHydrateHostInstance: prepareToHydrateHostInstance,
    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,
    popHydrationState: popHydrationState
  };
};

// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation = {
  debugTool: null
};

var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

var defaultShowDialog = function (capturedError) {
  return true;
};

var showDialog = defaultShowDialog;

function logCapturedError(capturedError) {
  var logError = showDialog(capturedError);

  // Allow injected showDialog() to prevent default console.error logging.
  // This enables renderers like ReactNative to better manage redbox behavior.
  if (logError === false) {
    return;
  }

  {
    var componentName = capturedError.componentName,
        componentStack = capturedError.componentStack,
        errorBoundaryName = capturedError.errorBoundaryName,
        errorBoundaryFound = capturedError.errorBoundaryFound,
        willRetry = capturedError.willRetry;


    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';

    var errorBoundaryMessage = void 0;
    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
    if (errorBoundaryFound && errorBoundaryName) {
      if (willRetry) {
        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');
      } else {
        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';
      }
    } else {
      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';
    }
    var combinedMessage = '' + componentNameMessage + componentStack + '\n\n' + ('' + errorBoundaryMessage);

    // In development, we provide our own message with just the component stack.
    // We don't include the original error message and JS stack because the browser
    // has already printed it. Even if the application swallows the error, it is still
    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
    console.error(combinedMessage);
  }
}

var invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;
var hasCaughtError = ReactErrorUtils.hasCaughtError;
var clearCaughtError = ReactErrorUtils.clearCaughtError;


{
  var didWarnAboutStateTransition = false;
  var didWarnSetStateChildContext = false;
  var didWarnStateUpdateForUnmountedComponent = {};

  var warnAboutUpdateOnUnmounted = function (fiber) {
    var componentName = getComponentName(fiber) || 'ReactClass';
    if (didWarnStateUpdateForUnmountedComponent[componentName]) {
      return;
    }
    warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease ' + 'check the code for the %s component.', componentName);
    didWarnStateUpdateForUnmountedComponent[componentName] = true;
  };

  var warnAboutInvalidUpdates = function (instance) {
    switch (ReactDebugCurrentFiber.phase) {
      case 'getChildContext':
        if (didWarnSetStateChildContext) {
          return;
        }
        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');
        didWarnSetStateChildContext = true;
        break;
      case 'render':
        if (didWarnAboutStateTransition) {
          return;
        }
        warning(false, 'Cannot update during an existing state transition (such as within ' + "`render` or another component's constructor). Render methods should " + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');
        didWarnAboutStateTransition = true;
        break;
    }
  };
}

var ReactFiberScheduler = function (config) {
  var hostContext = ReactFiberHostContext(config);
  var hydrationContext = ReactFiberHydrationContext(config);
  var popHostContainer = hostContext.popHostContainer,
      popHostContext = hostContext.popHostContext,
      resetHostContainer = hostContext.resetHostContainer;

  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),
      beginWork = _ReactFiberBeginWork.beginWork,
      beginFailedWork = _ReactFiberBeginWork.beginFailedWork;

  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),
      completeWork = _ReactFiberCompleteWo.completeWork;

  var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),
      commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,
      commitPlacement = _ReactFiberCommitWork.commitPlacement,
      commitDeletion = _ReactFiberCommitWork.commitDeletion,
      commitWork = _ReactFiberCommitWork.commitWork,
      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,
      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,
      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;

  var now = config.now,
      scheduleDeferredCallback = config.scheduleDeferredCallback,
      useSyncScheduling = config.useSyncScheduling,
      prepareForCommit = config.prepareForCommit,
      resetAfterCommit = config.resetAfterCommit;

  // Represents the current time in ms.

  var startTime = now();
  var mostRecentCurrentTime = msToExpirationTime(0);

  // Represents the expiration time that incoming updates should use. (If this
  // is NoWork, use the default strategy: async updates in async mode, sync
  // updates in sync mode.)
  var expirationContext = NoWork;

  var isWorking = false;

  // The next work in progress fiber that we're currently working on.
  var nextUnitOfWork = null;
  var nextRoot = null;
  // The time at which we're currently rendering work.
  var nextRenderExpirationTime = NoWork;

  // The next fiber with an effect that we're currently committing.
  var nextEffect = null;

  // Keep track of which fibers have captured an error that need to be handled.
  // Work is removed from this collection after componentDidCatch is called.
  var capturedErrors = null;
  // Keep track of which fibers have failed during the current batch of work.
  // This is a different set than capturedErrors, because it is not reset until
  // the end of the batch. This is needed to propagate errors correctly if a
  // subtree fails more than once.
  var failedBoundaries = null;
  // Error boundaries that captured an error during the current commit.
  var commitPhaseBoundaries = null;
  var firstUncaughtError = null;
  var didFatal = false;

  var isCommitting = false;
  var isUnmounting = false;

  // Used for performance tracking.
  var interruptedBy = null;

  function resetContextStack() {
    // Reset the stack
    reset$1();
    // Reset the cursors
    resetContext();
    resetHostContainer();
  }

  function commitAllHostEffects() {
    while (nextEffect !== null) {
      {
        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);
      }
      recordEffect();

      var effectTag = nextEffect.effectTag;
      if (effectTag & ContentReset) {
        commitResetTextContent(nextEffect);
      }

      if (effectTag & Ref) {
        var current = nextEffect.alternate;
        if (current !== null) {
          commitDetachRef(current);
        }
      }

      // The following switch statement is only concerned about placement,
      // updates, and deletions. To avoid needing to add a case for every
      // possible bitmap value, we remove the secondary effects from the
      // effect tag and switch on that value.
      var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);
      switch (primaryEffectTag) {
        case Placement:
          {
            commitPlacement(nextEffect);
            // Clear the "placement" from effect tag so that we know that this is inserted, before
            // any life-cycles like componentDidMount gets called.
            // TODO: findDOMNode doesn't rely on this any more but isMounted
            // does and isMounted is deprecated anyway so we should be able
            // to kill this.
            nextEffect.effectTag &= ~Placement;
            break;
          }
        case PlacementAndUpdate:
          {
            // Placement
            commitPlacement(nextEffect);
            // Clear the "placement" from effect tag so that we know that this is inserted, before
            // any life-cycles like componentDidMount gets called.
            nextEffect.effectTag &= ~Placement;

            // Update
            var _current = nextEffect.alternate;
            commitWork(_current, nextEffect);
            break;
          }
        case Update:
          {
            var _current2 = nextEffect.alternate;
            commitWork(_current2, nextEffect);
            break;
          }
        case Deletion:
          {
            isUnmounting = true;
            commitDeletion(nextEffect);
            isUnmounting = false;
            break;
          }
      }
      nextEffect = nextEffect.nextEffect;
    }

    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
  }

  function commitAllLifeCycles() {
    while (nextEffect !== null) {
      var effectTag = nextEffect.effectTag;

      if (effectTag & (Update | Callback)) {
        recordEffect();
        var current = nextEffect.alternate;
        commitLifeCycles(current, nextEffect);
      }

      if (effectTag & Ref) {
        recordEffect();
        commitAttachRef(nextEffect);
      }

      if (effectTag & Err) {
        recordEffect();
        commitErrorHandling(nextEffect);
      }

      var next = nextEffect.nextEffect;
      // Ensure that we clean these up so that we don't accidentally keep them.
      // I'm not actually sure this matters because we can't reset firstEffect
      // and lastEffect since they're on every node, not just the effectful
      // ones. So we have to clean everything as we reuse nodes anyway.
      nextEffect.nextEffect = null;
      // Ensure that we reset the effectTag here so that we can rely on effect
      // tags to reason about the current life-cycle.
      nextEffect = next;
    }
  }

  function commitRoot(finishedWork) {
    // We keep track of this so that captureError can collect any boundaries
    // that capture an error during the commit phase. The reason these aren't
    // local to this function is because errors that occur during cWU are
    // captured elsewhere, to prevent the unmount from being interrupted.
    isWorking = true;
    isCommitting = true;
    startCommitTimer();

    var root = finishedWork.stateNode;
    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    root.isReadyForCommit = false;

    // Reset this to null before calling lifecycles
    ReactCurrentOwner.current = null;

    var firstEffect = void 0;
    if (finishedWork.effectTag > PerformedWork) {
      // A fiber's effect list consists only of its children, not itself. So if
      // the root has an effect, we need to add it to the end of the list. The
      // resulting list is the set that would belong to the root's parent, if
      // it had one; that is, all the effects in the tree including the root.
      if (finishedWork.lastEffect !== null) {
        finishedWork.lastEffect.nextEffect = finishedWork;
        firstEffect = finishedWork.firstEffect;
      } else {
        firstEffect = finishedWork;
      }
    } else {
      // There is no effect on the root.
      firstEffect = finishedWork.firstEffect;
    }

    prepareForCommit();

    // Commit all the side-effects within a tree. We'll do this in two passes.
    // The first pass performs all the host insertions, updates, deletions and
    // ref unmounts.
    nextEffect = firstEffect;
    startCommitHostEffectsTimer();
    while (nextEffect !== null) {
      var didError = false;
      var _error = void 0;
      {
        invokeGuardedCallback$1(null, commitAllHostEffects, null);
        if (hasCaughtError()) {
          didError = true;
          _error = clearCaughtError();
        }
      }
      if (didError) {
        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        captureError(nextEffect, _error);
        // Clean-up
        if (nextEffect !== null) {
          nextEffect = nextEffect.nextEffect;
        }
      }
    }
    stopCommitHostEffectsTimer();

    resetAfterCommit();

    // The work-in-progress tree is now the current tree. This must come after
    // the first pass of the commit phase, so that the previous tree is still
    // current during componentWillUnmount, but before the second pass, so that
    // the finished work is current during componentDidMount/Update.
    root.current = finishedWork;

    // In the second pass we'll perform all life-cycles and ref callbacks.
    // Life-cycles happen as a separate pass so that all placements, updates,
    // and deletions in the entire tree have already been invoked.
    // This pass also triggers any renderer-specific initial effects.
    nextEffect = firstEffect;
    startCommitLifeCyclesTimer();
    while (nextEffect !== null) {
      var _didError = false;
      var _error2 = void 0;
      {
        invokeGuardedCallback$1(null, commitAllLifeCycles, null);
        if (hasCaughtError()) {
          _didError = true;
          _error2 = clearCaughtError();
        }
      }
      if (_didError) {
        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        captureError(nextEffect, _error2);
        if (nextEffect !== null) {
          nextEffect = nextEffect.nextEffect;
        }
      }
    }

    isCommitting = false;
    isWorking = false;
    stopCommitLifeCyclesTimer();
    stopCommitTimer();
    if (typeof onCommitRoot === 'function') {
      onCommitRoot(finishedWork.stateNode);
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
    }

    // If we caught any errors during this commit, schedule their boundaries
    // to update.
    if (commitPhaseBoundaries) {
      commitPhaseBoundaries.forEach(scheduleErrorRecovery);
      commitPhaseBoundaries = null;
    }

    if (firstUncaughtError !== null) {
      var _error3 = firstUncaughtError;
      firstUncaughtError = null;
      onUncaughtError(_error3);
    }

    var remainingTime = root.current.expirationTime;

    if (remainingTime === NoWork) {
      capturedErrors = null;
      failedBoundaries = null;
    }

    return remainingTime;
  }

  function resetExpirationTime(workInProgress, renderTime) {
    if (renderTime !== Never && workInProgress.expirationTime === Never) {
      // The children of this component are hidden. Don't bubble their
      // expiration times.
      return;
    }

    // Check for pending updates.
    var newExpirationTime = getUpdateExpirationTime(workInProgress);

    // TODO: Calls need to visit stateNode

    // Bubble up the earliest expiration time.
    var child = workInProgress.child;
    while (child !== null) {
      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {
        newExpirationTime = child.expirationTime;
      }
      child = child.sibling;
    }
    workInProgress.expirationTime = newExpirationTime;
  }

  function completeUnitOfWork(workInProgress) {
    while (true) {
      // The current, flushed, state of this fiber is the alternate.
      // Ideally nothing should rely on this, but relying on it here
      // means that we don't need an additional field on the work in
      // progress.
      var current = workInProgress.alternate;
      {
        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
      }
      var next = completeWork(current, workInProgress, nextRenderExpirationTime);
      {
        ReactDebugCurrentFiber.resetCurrentFiber();
      }

      var returnFiber = workInProgress['return'];
      var siblingFiber = workInProgress.sibling;

      resetExpirationTime(workInProgress, nextRenderExpirationTime);

      if (next !== null) {
        stopWorkTimer(workInProgress);
        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
        }
        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        return next;
      }

      if (returnFiber !== null) {
        // Append all the effects of the subtree and this fiber onto the effect
        // list of the parent. The completion order of the children affects the
        // side-effect order.
        if (returnFiber.firstEffect === null) {
          returnFiber.firstEffect = workInProgress.firstEffect;
        }
        if (workInProgress.lastEffect !== null) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
          }
          returnFiber.lastEffect = workInProgress.lastEffect;
        }

        // If this fiber had side-effects, we append it AFTER the children's
        // side-effects. We can perform certain side-effects earlier if
        // needed, by doing multiple passes over the effect list. We don't want
        // to schedule our own side-effect on our own list because if end up
        // reusing children we'll schedule this effect onto itself since we're
        // at the end.
        var effectTag = workInProgress.effectTag;
        // Skip both NoWork and PerformedWork tags when creating the effect list.
        // PerformedWork effect is read by React DevTools but shouldn't be committed.
        if (effectTag > PerformedWork) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress;
          } else {
            returnFiber.firstEffect = workInProgress;
          }
          returnFiber.lastEffect = workInProgress;
        }
      }

      stopWorkTimer(workInProgress);
      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
      }

      if (siblingFiber !== null) {
        // If there is more work to do in this returnFiber, do that next.
        return siblingFiber;
      } else if (returnFiber !== null) {
        // If there's no more work in this returnFiber. Complete the returnFiber.
        workInProgress = returnFiber;
        continue;
      } else {
        // We've reached the root.
        var root = workInProgress.stateNode;
        root.isReadyForCommit = true;
        return null;
      }
    }

    // Without this explicit null return Flow complains of invalid return type
    // TODO Remove the above while(true) loop
    // eslint-disable-next-line no-unreachable
    return null;
  }

  function performUnitOfWork(workInProgress) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;

    // See if beginning this work spawns more work.
    startWorkTimer(workInProgress);
    {
      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
    }
    var next = beginWork(current, workInProgress, nextRenderExpirationTime);
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
    }

    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      next = completeUnitOfWork(workInProgress);
    }

    ReactCurrentOwner.current = null;

    return next;
  }

  function performFailedUnitOfWork(workInProgress) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;

    // See if beginning this work spawns more work.
    startWorkTimer(workInProgress);
    {
      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
    }
    var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
    }

    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      next = completeUnitOfWork(workInProgress);
    }

    ReactCurrentOwner.current = null;

    return next;
  }

  function workLoop(expirationTime) {
    if (capturedErrors !== null) {
      // If there are unhandled errors, switch to the slow work loop.
      // TODO: How to avoid this check in the fast path? Maybe the renderer
      // could keep track of which roots have unhandled errors and call a
      // forked version of renderRoot.
      slowWorkLoopThatChecksForFailedWork(expirationTime);
      return;
    }
    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
      return;
    }

    if (nextRenderExpirationTime <= mostRecentCurrentTime) {
      // Flush all expired work.
      while (nextUnitOfWork !== null) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    } else {
      // Flush asynchronous work until the deadline runs out of time.
      while (nextUnitOfWork !== null && !shouldYield()) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    }
  }

  function slowWorkLoopThatChecksForFailedWork(expirationTime) {
    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
      return;
    }

    if (nextRenderExpirationTime <= mostRecentCurrentTime) {
      // Flush all expired work.
      while (nextUnitOfWork !== null) {
        if (hasCapturedError(nextUnitOfWork)) {
          // Use a forked version of performUnitOfWork
          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
        } else {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    } else {
      // Flush asynchronous work until the deadline runs out of time.
      while (nextUnitOfWork !== null && !shouldYield()) {
        if (hasCapturedError(nextUnitOfWork)) {
          // Use a forked version of performUnitOfWork
          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
        } else {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    }
  }

  function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {
    // We're going to restart the error boundary that captured the error.
    // Conceptually, we're unwinding the stack. We need to unwind the
    // context stack, too.
    unwindContexts(failedWork, boundary);

    // Restart the error boundary using a forked version of
    // performUnitOfWork that deletes the boundary's children. The entire
    // failed subree will be unmounted. During the commit phase, a special
    // lifecycle method is called on the error boundary, which triggers
    // a re-render.
    nextUnitOfWork = performFailedUnitOfWork(boundary);

    // Continue working.
    workLoop(expirationTime);
  }

  function renderRoot(root, expirationTime) {
    !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    isWorking = true;

    // We're about to mutate the work-in-progress tree. If the root was pending
    // commit, it no longer is: we'll need to complete it again.
    root.isReadyForCommit = false;

    // Check if we're starting from a fresh stack, or if we're resuming from
    // previously yielded work.
    if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {
      // Reset the stack and start working from the root.
      resetContextStack();
      nextRoot = root;
      nextRenderExpirationTime = expirationTime;
      nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);
    }

    startWorkLoopTimer(nextUnitOfWork);

    var didError = false;
    var error = null;
    {
      invokeGuardedCallback$1(null, workLoop, null, expirationTime);
      if (hasCaughtError()) {
        didError = true;
        error = clearCaughtError();
      }
    }

    // An error was thrown during the render phase.
    while (didError) {
      if (didFatal) {
        // This was a fatal error. Don't attempt to recover from it.
        firstUncaughtError = error;
        break;
      }

      var failedWork = nextUnitOfWork;
      if (failedWork === null) {
        // An error was thrown but there's no current unit of work. This can
        // happen during the commit phase if there's a bug in the renderer.
        didFatal = true;
        continue;
      }

      // "Capture" the error by finding the nearest boundary. If there is no
      // error boundary, we use the root.
      var boundary = captureError(failedWork, error);
      !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;

      if (didFatal) {
        // The error we just captured was a fatal error. This happens
        // when the error propagates to the root more than once.
        continue;
      }

      didError = false;
      error = null;
      {
        invokeGuardedCallback$1(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);
        if (hasCaughtError()) {
          didError = true;
          error = clearCaughtError();
          continue;
        }
      }
      // We're finished working. Exit the error loop.
      break;
    }

    var uncaughtError = firstUncaughtError;

    // We're done performing work. Time to clean up.
    stopWorkLoopTimer(interruptedBy);
    interruptedBy = null;
    isWorking = false;
    didFatal = false;
    firstUncaughtError = null;

    if (uncaughtError !== null) {
      onUncaughtError(uncaughtError);
    }

    return root.isReadyForCommit ? root.current.alternate : null;
  }

  // Returns the boundary that captured the error, or null if the error is ignored
  function captureError(failedWork, error) {
    // It is no longer valid because we exited the user code.
    ReactCurrentOwner.current = null;
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }

    // Search for the nearest error boundary.
    var boundary = null;

    // Passed to logCapturedError()
    var errorBoundaryFound = false;
    var willRetry = false;
    var errorBoundaryName = null;

    // Host containers are a special case. If the failed work itself is a host
    // container, then it acts as its own boundary. In all other cases, we
    // ignore the work itself and only search through the parents.
    if (failedWork.tag === HostRoot) {
      boundary = failedWork;

      if (isFailedBoundary(failedWork)) {
        // If this root already failed, there must have been an error when
        // attempting to unmount it. This is a worst-case scenario and
        // should only be possible if there's a bug in the renderer.
        didFatal = true;
      }
    } else {
      var node = failedWork['return'];
      while (node !== null && boundary === null) {
        if (node.tag === ClassComponent) {
          var instance = node.stateNode;
          if (typeof instance.componentDidCatch === 'function') {
            errorBoundaryFound = true;
            errorBoundaryName = getComponentName(node);

            // Found an error boundary!
            boundary = node;
            willRetry = true;
          }
        } else if (node.tag === HostRoot) {
          // Treat the root like a no-op error boundary
          boundary = node;
        }

        if (isFailedBoundary(node)) {
          // This boundary is already in a failed state.

          // If we're currently unmounting, that means this error was
          // thrown while unmounting a failed subtree. We should ignore
          // the error.
          if (isUnmounting) {
            return null;
          }

          // If we're in the commit phase, we should check to see if
          // this boundary already captured an error during this commit.
          // This case exists because multiple errors can be thrown during
          // a single commit without interruption.
          if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {
            // If so, we should ignore this error.
            return null;
          }

          // The error should propagate to the next boundary -— we keep looking.
          boundary = null;
          willRetry = false;
        }

        node = node['return'];
      }
    }

    if (boundary !== null) {
      // Add to the collection of failed boundaries. This lets us know that
      // subsequent errors in this subtree should propagate to the next boundary.
      if (failedBoundaries === null) {
        failedBoundaries = new Set();
      }
      failedBoundaries.add(boundary);

      // This method is unsafe outside of the begin and complete phases.
      // We might be in the commit phase when an error is captured.
      // The risk is that the return path from this Fiber may not be accurate.
      // That risk is acceptable given the benefit of providing users more context.
      var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);
      var _componentName = getComponentName(failedWork);

      // Add to the collection of captured errors. This is stored as a global
      // map of errors and their component stack location keyed by the boundaries
      // that capture them. We mostly use this Map as a Set; it's a Map only to
      // avoid adding a field to Fiber to store the error.
      if (capturedErrors === null) {
        capturedErrors = new Map();
      }

      var capturedError = {
        componentName: _componentName,
        componentStack: _componentStack,
        error: error,
        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,
        errorBoundaryFound: errorBoundaryFound,
        errorBoundaryName: errorBoundaryName,
        willRetry: willRetry
      };

      capturedErrors.set(boundary, capturedError);

      try {
        logCapturedError(capturedError);
      } catch (e) {
        // Prevent cycle if logCapturedError() throws.
        // A cycle may still occur if logCapturedError renders a component that throws.
        console.error(e);
      }

      // If we're in the commit phase, defer scheduling an update on the
      // boundary until after the commit is complete
      if (isCommitting) {
        if (commitPhaseBoundaries === null) {
          commitPhaseBoundaries = new Set();
        }
        commitPhaseBoundaries.add(boundary);
      } else {
        // Otherwise, schedule an update now.
        // TODO: Is this actually necessary during the render phase? Is it
        // possible to unwind and continue rendering at the same priority,
        // without corrupting internal state?
        scheduleErrorRecovery(boundary);
      }
      return boundary;
    } else if (firstUncaughtError === null) {
      // If no boundary is found, we'll need to throw the error
      firstUncaughtError = error;
    }
    return null;
  }

  function hasCapturedError(fiber) {
    // TODO: capturedErrors should store the boundary instance, to avoid needing
    // to check the alternate.
    return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));
  }

  function isFailedBoundary(fiber) {
    // TODO: failedBoundaries should store the boundary instance, to avoid
    // needing to check the alternate.
    return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));
  }

  function commitErrorHandling(effectfulFiber) {
    var capturedError = void 0;
    if (capturedErrors !== null) {
      capturedError = capturedErrors.get(effectfulFiber);
      capturedErrors['delete'](effectfulFiber);
      if (capturedError == null) {
        if (effectfulFiber.alternate !== null) {
          effectfulFiber = effectfulFiber.alternate;
          capturedError = capturedErrors.get(effectfulFiber);
          capturedErrors['delete'](effectfulFiber);
        }
      }
    }

    !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    switch (effectfulFiber.tag) {
      case ClassComponent:
        var instance = effectfulFiber.stateNode;

        var info = {
          componentStack: capturedError.componentStack
        };

        // Allow the boundary to handle the error, usually by scheduling
        // an update to itself
        instance.componentDidCatch(capturedError.error, info);
        return;
      case HostRoot:
        if (firstUncaughtError === null) {
          firstUncaughtError = capturedError.error;
        }
        return;
      default:
        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  function unwindContexts(from, to) {
    var node = from;
    while (node !== null) {
      switch (node.tag) {
        case ClassComponent:
          popContextProvider(node);
          break;
        case HostComponent:
          popHostContext(node);
          break;
        case HostRoot:
          popHostContainer(node);
          break;
        case HostPortal:
          popHostContainer(node);
          break;
      }
      if (node === to || node.alternate === to) {
        stopFailedWorkTimer(node);
        break;
      } else {
        stopWorkTimer(node);
      }
      node = node['return'];
    }
  }

  function computeAsyncExpiration() {
    // Given the current clock time, returns an expiration time. We use rounding
    // to batch like updates together.
    // Should complete within ~1000ms. 1200ms max.
    var currentTime = recalculateCurrentTime();
    var expirationMs = 1000;
    var bucketSizeMs = 200;
    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);
  }

  function computeExpirationForFiber(fiber) {
    var expirationTime = void 0;
    if (expirationContext !== NoWork) {
      // An explicit expiration context was set;
      expirationTime = expirationContext;
    } else if (isWorking) {
      if (isCommitting) {
        // Updates that occur during the commit phase should have sync priority
        // by default.
        expirationTime = Sync;
      } else {
        // Updates during the render phase should expire at the same time as
        // the work that is being rendered.
        expirationTime = nextRenderExpirationTime;
      }
    } else {
      // No explicit expiration context was set, and we're not currently
      // performing work. Calculate a new expiration time.
      if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {
        // This is a sync update
        expirationTime = Sync;
      } else {
        // This is an async update
        expirationTime = computeAsyncExpiration();
      }
    }
    return expirationTime;
  }

  function scheduleWork(fiber, expirationTime) {
    return scheduleWorkImpl(fiber, expirationTime, false);
  }

  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {
    recordScheduleUpdate();

    {
      if (!isErrorRecovery && fiber.tag === ClassComponent) {
        var instance = fiber.stateNode;
        warnAboutInvalidUpdates(instance);
      }
    }

    var node = fiber;
    while (node !== null) {
      // Walk the parent path to the root and update each node's
      // expiration time.
      if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {
        node.expirationTime = expirationTime;
      }
      if (node.alternate !== null) {
        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {
          node.alternate.expirationTime = expirationTime;
        }
      }
      if (node['return'] === null) {
        if (node.tag === HostRoot) {
          var root = node.stateNode;
          if (!isWorking && root === nextRoot && expirationTime <= nextRenderExpirationTime) {
            // Restart the root from the top.
            if (nextUnitOfWork !== null) {
              // This is an interruption. (Used for performance tracking.)
              interruptedBy = fiber;
            }
            nextRoot = null;
            nextUnitOfWork = null;
            nextRenderExpirationTime = NoWork;
          }
          requestWork(root, expirationTime);
        } else {
          {
            if (!isErrorRecovery && fiber.tag === ClassComponent) {
              warnAboutUpdateOnUnmounted(fiber);
            }
          }
          return;
        }
      }
      node = node['return'];
    }
  }

  function scheduleErrorRecovery(fiber) {
    scheduleWorkImpl(fiber, Sync, true);
  }

  function recalculateCurrentTime() {
    // Subtract initial time so it fits inside 32bits
    var ms = now() - startTime;
    mostRecentCurrentTime = msToExpirationTime(ms);
    return mostRecentCurrentTime;
  }

  function deferredUpdates(fn) {
    var previousExpirationContext = expirationContext;
    expirationContext = computeAsyncExpiration();
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }

  function syncUpdates(fn) {
    var previousExpirationContext = expirationContext;
    expirationContext = Sync;
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }

  // TODO: Everything below this is written as if it has been lifted to the
  // renderers. I'll do this in a follow-up.

  // Linked-list of roots
  var firstScheduledRoot = null;
  var lastScheduledRoot = null;

  var isCallbackScheduled = false;
  var isRendering = false;
  var nextFlushedRoot = null;
  var nextFlushedExpirationTime = NoWork;
  var deadlineDidExpire = false;
  var hasUnhandledError = false;
  var unhandledError = null;
  var deadline = null;

  var isBatchingUpdates = false;
  var isUnbatchingUpdates = false;

  // Use these to prevent an infinite loop of nested updates
  var NESTED_UPDATE_LIMIT = 1000;
  var nestedUpdateCount = 0;

  var timeHeuristicForUnitOfWork = 1;

  // requestWork is called by the scheduler whenever a root receives an update.
  // It's up to the renderer to call renderRoot at some point in the future.
  function requestWork(root, expirationTime) {
    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
      invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');
    }

    // Add the root to the schedule.
    // Check if this root is already part of the schedule.
    if (root.nextScheduledRoot === null) {
      // This root is not already scheduled. Add it.
      root.remainingExpirationTime = expirationTime;
      if (lastScheduledRoot === null) {
        firstScheduledRoot = lastScheduledRoot = root;
        root.nextScheduledRoot = root;
      } else {
        lastScheduledRoot.nextScheduledRoot = root;
        lastScheduledRoot = root;
        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
      }
    } else {
      // This root is already scheduled, but its priority may have increased.
      var remainingExpirationTime = root.remainingExpirationTime;
      if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {
        // Update the priority.
        root.remainingExpirationTime = expirationTime;
      }
    }

    if (isRendering) {
      // Prevent reentrancy. Remaining work will be scheduled at the end of
      // the currently rendering batch.
      return;
    }

    if (isBatchingUpdates) {
      // Flush work at the end of the batch.
      if (isUnbatchingUpdates) {
        // ...unless we're inside unbatchedUpdates, in which case we should
        // flush it now.
        performWorkOnRoot(root, Sync);
      }
      return;
    }

    // TODO: Get rid of Sync and use current time?
    if (expirationTime === Sync) {
      performWork(Sync, null);
    } else if (!isCallbackScheduled) {
      isCallbackScheduled = true;
      startRequestCallbackTimer();
      scheduleDeferredCallback(performAsyncWork);
    }
  }

  function findHighestPriorityRoot() {
    var highestPriorityWork = NoWork;
    var highestPriorityRoot = null;

    if (lastScheduledRoot !== null) {
      var previousScheduledRoot = lastScheduledRoot;
      var root = firstScheduledRoot;
      while (root !== null) {
        var remainingExpirationTime = root.remainingExpirationTime;
        if (remainingExpirationTime === NoWork) {
          // This root no longer has work. Remove it from the scheduler.

          // TODO: This check is redudant, but Flow is confused by the branch
          // below where we set lastScheduledRoot to null, even though we break
          // from the loop right after.
          !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          if (root === root.nextScheduledRoot) {
            // This is the only root in the list.
            root.nextScheduledRoot = null;
            firstScheduledRoot = lastScheduledRoot = null;
            break;
          } else if (root === firstScheduledRoot) {
            // This is the first root in the list.
            var next = root.nextScheduledRoot;
            firstScheduledRoot = next;
            lastScheduledRoot.nextScheduledRoot = next;
            root.nextScheduledRoot = null;
          } else if (root === lastScheduledRoot) {
            // This is the last root in the list.
            lastScheduledRoot = previousScheduledRoot;
            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
            root.nextScheduledRoot = null;
            break;
          } else {
            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
            root.nextScheduledRoot = null;
          }
          root = previousScheduledRoot.nextScheduledRoot;
        } else {
          if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {
            // Update the priority, if it's higher
            highestPriorityWork = remainingExpirationTime;
            highestPriorityRoot = root;
          }
          if (root === lastScheduledRoot) {
            break;
          }
          previousScheduledRoot = root;
          root = root.nextScheduledRoot;
        }
      }
    }

    // If the next root is the same as the previous root, this is a nested
    // update. To prevent an infinite loop, increment the nested update count.
    var previousFlushedRoot = nextFlushedRoot;
    if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {
      nestedUpdateCount++;
    } else {
      // Reset whenever we switch roots.
      nestedUpdateCount = 0;
    }
    nextFlushedRoot = highestPriorityRoot;
    nextFlushedExpirationTime = highestPriorityWork;
  }

  function performAsyncWork(dl) {
    performWork(NoWork, dl);
  }

  function performWork(minExpirationTime, dl) {
    deadline = dl;

    // Keep working on roots until there's no more work, or until the we reach
    // the deadline.
    findHighestPriorityRoot();

    if (enableUserTimingAPI && deadline !== null) {
      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();
      stopRequestCallbackTimer(didExpire);
    }

    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
      // Find the next highest priority work.
      findHighestPriorityRoot();
    }

    // We're done flushing work. Either we ran out of time in this callback,
    // or there's no more work left with sufficient priority.

    // If we're inside a callback, set this to false since we just completed it.
    if (deadline !== null) {
      isCallbackScheduled = false;
    }
    // If there's work left over, schedule a new callback.
    if (nextFlushedRoot !== null && !isCallbackScheduled) {
      isCallbackScheduled = true;
      startRequestCallbackTimer();
      scheduleDeferredCallback(performAsyncWork);
    }

    // Clean-up.
    deadline = null;
    deadlineDidExpire = false;
    nestedUpdateCount = 0;

    if (hasUnhandledError) {
      var _error4 = unhandledError;
      unhandledError = null;
      hasUnhandledError = false;
      throw _error4;
    }
  }

  function performWorkOnRoot(root, expirationTime) {
    !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    isRendering = true;

    // Check if this is async work or sync/expired work.
    // TODO: Pass current time as argument to renderRoot, commitRoot
    if (expirationTime <= recalculateCurrentTime()) {
      // Flush sync work.
      var finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        // This root is already complete. We can commit it.
        root.finishedWork = null;
        root.remainingExpirationTime = commitRoot(finishedWork);
      } else {
        root.finishedWork = null;
        finishedWork = renderRoot(root, expirationTime);
        if (finishedWork !== null) {
          // We've completed the root. Commit it.
          root.remainingExpirationTime = commitRoot(finishedWork);
        }
      }
    } else {
      // Flush async work.
      var _finishedWork = root.finishedWork;
      if (_finishedWork !== null) {
        // This root is already complete. We can commit it.
        root.finishedWork = null;
        root.remainingExpirationTime = commitRoot(_finishedWork);
      } else {
        root.finishedWork = null;
        _finishedWork = renderRoot(root, expirationTime);
        if (_finishedWork !== null) {
          // We've completed the root. Check the deadline one more time
          // before committing.
          if (!shouldYield()) {
            // Still time left. Commit the root.
            root.remainingExpirationTime = commitRoot(_finishedWork);
          } else {
            // There's no time left. Mark this root as complete. We'll come
            // back and commit it later.
            root.finishedWork = _finishedWork;
          }
        }
      }
    }

    isRendering = false;
  }

  // When working on async work, the reconciler asks the renderer if it should
  // yield execution. For DOM, we implement this with requestIdleCallback.
  function shouldYield() {
    if (deadline === null) {
      return false;
    }
    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {
      return false;
    }
    deadlineDidExpire = true;
    return true;
  }

  // TODO: Not happy about this hook. Conceptually, renderRoot should return a
  // tuple of (isReadyForCommit, didError, error)
  function onUncaughtError(error) {
    !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    // Unschedule this root so we don't work on it again until there's
    // another update.
    nextFlushedRoot.remainingExpirationTime = NoWork;
    if (!hasUnhandledError) {
      hasUnhandledError = true;
      unhandledError = error;
    }
  }

  // TODO: Batching should be implemented at the renderer level, not inside
  // the reconciler.
  function batchedUpdates(fn, a) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = true;
    try {
      return fn(a);
    } finally {
      isBatchingUpdates = previousIsBatchingUpdates;
      if (!isBatchingUpdates && !isRendering) {
        performWork(Sync, null);
      }
    }
  }

  // TODO: Batching should be implemented at the renderer level, not inside
  // the reconciler.
  function unbatchedUpdates(fn) {
    if (isBatchingUpdates && !isUnbatchingUpdates) {
      isUnbatchingUpdates = true;
      try {
        return fn();
      } finally {
        isUnbatchingUpdates = false;
      }
    }
    return fn();
  }

  // TODO: Batching should be implemented at the renderer level, not within
  // the reconciler.
  function flushSync(fn) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = true;
    try {
      return syncUpdates(fn);
    } finally {
      isBatchingUpdates = previousIsBatchingUpdates;
      !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;
      performWork(Sync, null);
    }
  }

  return {
    computeAsyncExpiration: computeAsyncExpiration,
    computeExpirationForFiber: computeExpirationForFiber,
    scheduleWork: scheduleWork,
    batchedUpdates: batchedUpdates,
    unbatchedUpdates: unbatchedUpdates,
    flushSync: flushSync,
    deferredUpdates: deferredUpdates
  };
};

{
  var didWarnAboutNestedUpdates = false;
}

// 0 is PROD, 1 is DEV.
// Might add PROFILE later.


function getContextForSubtree(parentComponent) {
  if (!parentComponent) {
    return emptyObject;
  }

  var fiber = get(parentComponent);
  var parentContext = findCurrentUnmaskedContext(fiber);
  return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;
}

var ReactFiberReconciler$1 = function (config) {
  var getPublicInstance = config.getPublicInstance;

  var _ReactFiberScheduler = ReactFiberScheduler(config),
      computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,
      computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,
      scheduleWork = _ReactFiberScheduler.scheduleWork,
      batchedUpdates = _ReactFiberScheduler.batchedUpdates,
      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,
      flushSync = _ReactFiberScheduler.flushSync,
      deferredUpdates = _ReactFiberScheduler.deferredUpdates;

  function scheduleTopLevelUpdate(current, element, callback) {
    {
      if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {
        didWarnAboutNestedUpdates = true;
        warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');
      }
    }

    callback = callback === undefined ? null : callback;
    {
      warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
    }

    var expirationTime = void 0;
    // Check if the top-level element is an async wrapper component. If so,
    // treat updates to the root as async. This is a bit weird but lets us
    // avoid a separate `renderAsync` API.
    if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {
      expirationTime = computeAsyncExpiration();
    } else {
      expirationTime = computeExpirationForFiber(current);
    }

    var update = {
      expirationTime: expirationTime,
      partialState: { element: element },
      callback: callback,
      isReplace: false,
      isForced: false,
      nextCallback: null,
      next: null
    };
    insertUpdateIntoFiber(current, update);
    scheduleWork(current, expirationTime);
  }

  function findHostInstance(fiber) {
    var hostFiber = findCurrentHostFiber(fiber);
    if (hostFiber === null) {
      return null;
    }
    return hostFiber.stateNode;
  }

  return {
    createContainer: function (containerInfo, hydrate) {
      return createFiberRoot(containerInfo, hydrate);
    },
    updateContainer: function (element, container, parentComponent, callback) {
      // TODO: If this is a nested container, this won't be the root.
      var current = container.current;

      {
        if (ReactFiberInstrumentation_1.debugTool) {
          if (current.alternate === null) {
            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
          } else if (element === null) {
            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
          } else {
            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
          }
        }
      }

      var context = getContextForSubtree(parentComponent);
      if (container.context === null) {
        container.context = context;
      } else {
        container.pendingContext = context;
      }

      scheduleTopLevelUpdate(current, element, callback);
    },


    batchedUpdates: batchedUpdates,

    unbatchedUpdates: unbatchedUpdates,

    deferredUpdates: deferredUpdates,

    flushSync: flushSync,

    getPublicRootInstance: function (container) {
      var containerFiber = container.current;
      if (!containerFiber.child) {
        return null;
      }
      switch (containerFiber.child.tag) {
        case HostComponent:
          return getPublicInstance(containerFiber.child.stateNode);
        default:
          return containerFiber.child.stateNode;
      }
    },


    findHostInstance: findHostInstance,

    findHostInstanceWithNoPortals: function (fiber) {
      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
      if (hostFiber === null) {
        return null;
      }
      return hostFiber.stateNode;
    },
    injectIntoDevTools: function (devToolsConfig) {
      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;

      return injectInternals(_assign({}, devToolsConfig, {
        findHostInstanceByFiber: function (fiber) {
          return findHostInstance(fiber);
        },
        findFiberByHostInstance: function (instance) {
          if (!findFiberByHostInstance) {
            // Might not be implemented by the renderer.
            return null;
          }
          return findFiberByHostInstance(instance);
        }
      }));
    }
  };
};

var ReactFiberReconciler$2 = Object.freeze({
	default: ReactFiberReconciler$1
});

var ReactFiberReconciler$3 = ( ReactFiberReconciler$2 && ReactFiberReconciler$1 ) || ReactFiberReconciler$2;

// TODO: bundle Flow types with the package.



// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3;

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.1.1';

// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.

{
  if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {
    warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
  }
}

var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

var now = void 0;
if (hasNativePerformanceNow) {
  now = function () {
    return performance.now();
  };
} else {
  now = function () {
    return Date.now();
  };
}

// TODO: There's no way to cancel, because Fiber doesn't atm.
var rIC = void 0;

if (!ExecutionEnvironment.canUseDOM) {
  rIC = function (frameCallback) {
    setTimeout(function () {
      frameCallback({
        timeRemaining: function () {
          return Infinity;
        }
      });
    });
    return 0;
  };
} else if (typeof requestIdleCallback !== 'function') {
  // Polyfill requestIdleCallback.

  var scheduledRICCallback = null;

  var isIdleScheduled = false;
  var isAnimationFrameScheduled = false;

  var frameDeadline = 0;
  // We start out assuming that we run at 30fps but then the heuristic tracking
  // will adjust this value to a faster fps if we get more frequent animation
  // frames.
  var previousFrameTime = 33;
  var activeFrameTime = 33;

  var frameDeadlineObject;
  if (hasNativePerformanceNow) {
    frameDeadlineObject = {
      timeRemaining: function () {
        // We assume that if we have a performance timer that the rAF callback
        // gets a performance timer value. Not sure if this is always true.
        return frameDeadline - performance.now();
      }
    };
  } else {
    frameDeadlineObject = {
      timeRemaining: function () {
        // Fallback to Date.now()
        return frameDeadline - Date.now();
      }
    };
  }

  // We use the postMessage trick to defer idle work until after the repaint.
  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);
  var idleTick = function (event) {
    if (event.source !== window || event.data !== messageKey) {
      return;
    }
    isIdleScheduled = false;
    var callback = scheduledRICCallback;
    scheduledRICCallback = null;
    if (callback !== null) {
      callback(frameDeadlineObject);
    }
  };
  // Assumes that we have addEventListener in this environment. Might need
  // something better for old IE.
  window.addEventListener('message', idleTick, false);

  var animationTick = function (rafTime) {
    isAnimationFrameScheduled = false;
    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
      if (nextFrameTime < 8) {
        // Defensive coding. We don't support higher frame rates than 120hz.
        // If we get lower than that, it is probably a bug.
        nextFrameTime = 8;
      }
      // If one frame goes long, then the next one can be short to catch up.
      // If two frames are short in a row, then that's an indication that we
      // actually have a higher frame rate than what we're currently optimizing.
      // We adjust our heuristic dynamically accordingly. For example, if we're
      // running on 120hz display or 90hz VR display.
      // Take the max of the two in case one of them was an anomaly due to
      // missed frame deadlines.
      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
    } else {
      previousFrameTime = nextFrameTime;
    }
    frameDeadline = rafTime + activeFrameTime;
    if (!isIdleScheduled) {
      isIdleScheduled = true;
      window.postMessage(messageKey, '*');
    }
  };

  rIC = function (callback) {
    // This assumes that we only schedule one callback at a time because that's
    // how Fiber uses it.
    scheduledRICCallback = callback;
    if (!isAnimationFrameScheduled) {
      // If rAF didn't already schedule one, we need to schedule a frame.
      // TODO: If this rAF doesn't materialize because the browser throttles, we
      // might want to still have setTimeout trigger rIC as a backup to ensure
      // that we keep performing work.
      isAnimationFrameScheduled = true;
      requestAnimationFrame(animationTick);
    }
    return 0;
  };
} else {
  rIC = requestIdleCallback;
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  {
    warning(false, 'Invalid attribute name: `%s`', attributeName);
  }
  return false;
}

// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */





/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */
function getValueForProperty(node, name, expected) {
  {
    var propertyInfo = getPropertyInfo(name);
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod || propertyInfo.mustUseProperty) {
        return node[propertyInfo.propertyName];
      } else {
        var attributeName = propertyInfo.attributeName;

        var stringValue = null;

        if (propertyInfo.hasOverloadedBooleanValue) {
          if (node.hasAttribute(attributeName)) {
            var value = node.getAttribute(attributeName);
            if (value === '') {
              return true;
            }
            if (shouldIgnoreValue(propertyInfo, expected)) {
              return value;
            }
            if (value === '' + expected) {
              return expected;
            }
            return value;
          }
        } else if (node.hasAttribute(attributeName)) {
          if (shouldIgnoreValue(propertyInfo, expected)) {
            // We had an attribute but shouldn't have had one, so read it
            // for the error message.
            return node.getAttribute(attributeName);
          }
          if (propertyInfo.hasBooleanValue) {
            // If this was a boolean, it doesn't matter what the value is
            // the fact that we have it is the same as the expected.
            return expected;
          }
          // Even if this property uses a namespace we use getAttribute
          // because we assume its namespaced name is the same as our config.
          // To use getAttributeNS we need the local name which we don't have
          // in our config atm.
          stringValue = node.getAttribute(attributeName);
        }

        if (shouldIgnoreValue(propertyInfo, expected)) {
          return stringValue === null ? expected : stringValue;
        } else if (stringValue === '' + expected) {
          return expected;
        } else {
          return stringValue;
        }
      }
    }
  }
}

/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */
function getValueForAttribute(node, name, expected) {
  {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (!node.hasAttribute(name)) {
      return expected === undefined ? undefined : null;
    }
    var value = node.getAttribute(name);
    if (value === '' + expected) {
      return expected;
    }
    return value;
  }
}

/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */
function setValueForProperty(node, name, value) {
  var propertyInfo = getPropertyInfo(name);

  if (propertyInfo && shouldSetAttribute(name, value)) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, value);
    } else if (shouldIgnoreValue(propertyInfo, value)) {
      deleteValueForProperty(node, name);
      return;
    } else if (propertyInfo.mustUseProperty) {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyInfo.propertyName] = value;
    } else {
      var attributeName = propertyInfo.attributeName;
      var namespace = propertyInfo.attributeNamespace;
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // ('' + value) makes it output the correct toString()-value.
      if (namespace) {
        node.setAttributeNS(namespace, attributeName, '' + value);
      } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        node.setAttribute(attributeName, '');
      } else {
        node.setAttribute(attributeName, '' + value);
      }
    }
  } else {
    setValueForAttribute(node, name, shouldSetAttribute(name, value) ? value : null);
    return;
  }

  {
    
  }
}

function setValueForAttribute(node, name, value) {
  if (!isAttributeNameSafe(name)) {
    return;
  }
  if (value == null) {
    node.removeAttribute(name);
  } else {
    node.setAttribute(name, '' + value);
  }

  {
    
  }
}

/**
 * Deletes an attributes from a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */
function deleteValueForAttribute(node, name) {
  node.removeAttribute(name);
}

/**
 * Deletes the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */
function deleteValueForProperty(node, name) {
  var propertyInfo = getPropertyInfo(name);
  if (propertyInfo) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, undefined);
    } else if (propertyInfo.mustUseProperty) {
      var propName = propertyInfo.propertyName;
      if (propertyInfo.hasBooleanValue) {
        node[propName] = false;
      } else {
        node[propName] = '';
      }
    } else {
      node.removeAttribute(propertyInfo.attributeName);
    }
  } else {
    node.removeAttribute(name);
  }
}

var ReactControlledValuePropTypes = {
  checkPropTypes: null
};

{
  var hasReadOnlyValue = {
    button: true,
    checkbox: true,
    image: true,
    hidden: true,
    radio: true,
    reset: true,
    submit: true
  };

  var propTypes = {
    value: function (props, propName, componentName) {
      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    checked: function (props, propName, componentName) {
      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  };

  /**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */
  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {
    checkPropTypes(propTypes, props, 'prop', tagName, getStack);
  };
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */

function getHostProps(element, props) {
  var node = element;
  var value = props.value;
  var checked = props.checked;

  var hostProps = _assign({
    // Make sure we set .type before any other properties (setting .value
    // before .type means .value is lost in IE11 and below)
    type: undefined,
    // Make sure we set .step before .value (setting .value before .step
    // means .value is rounded on mount, based upon step precision)
    step: undefined,
    // Make sure we set .min & .max before .value (to ensure proper order
    // in corner cases such as min or max deriving from value, e.g. Issue #7170)
    min: undefined,
    max: undefined
  }, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: value != null ? value : node._wrapperState.initialValue,
    checked: checked != null ? checked : node._wrapperState.initialChecked
  });

  return hostProps;
}

function initWrapperState(element, props) {
  {
    ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum$3);

    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
      warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
      didWarnCheckedDefaultChecked = true;
    }
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
      didWarnValueDefaultValue = true;
    }
  }

  var defaultValue = props.defaultValue;
  var node = element;
  node._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: props.value != null ? props.value : defaultValue,
    controlled: isControlled(props)
  };
}

function updateWrapper(element, props) {
  var node = element;
  {
    var controlled = isControlled(props);

    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
      warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
      didWarnUncontrolledToControlled = true;
    }
    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
      warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
      didWarnControlledToUncontrolled = true;
    }
  }

  var checked = props.checked;
  if (checked != null) {
    setValueForProperty(node, 'checked', checked || false);
  }

  var value = props.value;
  if (value != null) {
    if (value === 0 && node.value === '') {
      node.value = '0';
      // Note: IE9 reports a number inputs as 'text', so check props instead.
    } else if (props.type === 'number') {
      // Simulate `input.valueAsNumber`. IE9 does not support it
      var valueAsNumber = parseFloat(node.value) || 0;

      if (
      // eslint-disable-next-line
      value != valueAsNumber ||
      // eslint-disable-next-line
      value == valueAsNumber && node.value != value) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        node.value = '' + value;
      }
    } else if (node.value !== '' + value) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      node.value = '' + value;
    }
  } else {
    if (props.value == null && props.defaultValue != null) {
      // In Chrome, assigning defaultValue to certain input types triggers input validation.
      // For number inputs, the display value loses trailing decimal points. For email inputs,
      // Chrome raises "The specified value <x> is not a valid email address".
      //
      // Here we check to see if the defaultValue has actually changed, avoiding these problems
      // when the user is inputting text
      //
      // https://github.com/facebook/react/issues/7253
      if (node.defaultValue !== '' + props.defaultValue) {
        node.defaultValue = '' + props.defaultValue;
      }
    }
    if (props.checked == null && props.defaultChecked != null) {
      node.defaultChecked = !!props.defaultChecked;
    }
  }
}

function postMountWrapper(element, props) {
  var node = element;

  // Detach value from defaultValue. We won't do anything if we're working on
  // submit or reset inputs as those values & defaultValues are linked. They
  // are not resetable nodes so this operation doesn't matter and actually
  // removes browser-default values (eg "Submit Query") when no value is
  // provided.

  switch (props.type) {
    case 'submit':
    case 'reset':
      break;
    case 'color':
    case 'date':
    case 'datetime':
    case 'datetime-local':
    case 'month':
    case 'time':
    case 'week':
      // This fixes the no-show issue on iOS Safari and Android Chrome:
      // https://github.com/facebook/react/issues/7233
      node.value = '';
      node.value = node.defaultValue;
      break;
    default:
      node.value = node.value;
      break;
  }

  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.
  var name = node.name;
  if (name !== '') {
    node.name = '';
  }
  node.defaultChecked = !node.defaultChecked;
  node.defaultChecked = !node.defaultChecked;
  if (name !== '') {
    node.name = name;
  }
}

function restoreControlledState$1(element, props) {
  var node = element;
  updateWrapper(node, props);
  updateNamedCousins(node, props);
}

function updateNamedCousins(rootNode, props) {
  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form. It might not even be in the
    // document. Let's just use the local `querySelectorAll` to ensure we don't
    // miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      updateWrapper(otherNode, otherProps);
    }
  }
}

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  // We can silently skip them because invalid DOM nesting warning
  // catches these cases in Fiber.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */

function validateProps(element, props) {
  // TODO (yungsters): Remove support for `selected` in <option>.
  {
    warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');
  }
}

function postMountWrapper$1(element, props) {
  // value="" should make a value attribute (#6219)
  if (props.value != null) {
    element.setAttribute('value', props.value);
  }
}

function getHostProps$1(element, props) {
  var hostProps = _assign({ children: undefined }, props);

  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


{
  var didWarnValueDefaultValue$1 = false;
}

function getDeclarationErrorAddendum() {
  var ownerName = getCurrentFiberOwnerName$3();
  if (ownerName) {
    return '\n\nCheck the render method of `' + ownerName + '`.';
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 */
function checkSelectPropTypes(props) {
  ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$4);

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
    } else if (!props.multiple && isArray) {
      warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
    }
  }
}

function updateOptions(node, multiple, propValue, setDefaultSelected) {
  var options = node.options;

  if (multiple) {
    var selectedValues = propValue;
    var selectedValue = {};
    for (var i = 0; i < selectedValues.length; i++) {
      // Prefix to avoid chaos with special keys.
      selectedValue['$' + selectedValues[i]] = true;
    }
    for (var _i = 0; _i < options.length; _i++) {
      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
      if (options[_i].selected !== selected) {
        options[_i].selected = selected;
      }
      if (selected && setDefaultSelected) {
        options[_i].defaultSelected = true;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    var _selectedValue = '' + propValue;
    var defaultSelected = null;
    for (var _i2 = 0; _i2 < options.length; _i2++) {
      if (options[_i2].value === _selectedValue) {
        options[_i2].selected = true;
        if (setDefaultSelected) {
          options[_i2].defaultSelected = true;
        }
        return;
      }
      if (defaultSelected === null && !options[_i2].disabled) {
        defaultSelected = options[_i2];
      }
    }
    if (defaultSelected !== null) {
      defaultSelected.selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */

function getHostProps$2(element, props) {
  return _assign({}, props, {
    value: undefined
  });
}

function initWrapperState$1(element, props) {
  var node = element;
  {
    checkSelectPropTypes(props);
  }

  var value = props.value;
  node._wrapperState = {
    initialValue: value != null ? value : props.defaultValue,
    wasMultiple: !!props.multiple
  };

  {
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
      warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValueDefaultValue$1 = true;
    }
  }
}

function postMountWrapper$2(element, props) {
  var node = element;
  node.multiple = !!props.multiple;
  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (props.defaultValue != null) {
    updateOptions(node, !!props.multiple, props.defaultValue, true);
  }
}

function postUpdateWrapper(element, props) {
  var node = element;
  // After the initial mount, we control selected-ness manually so don't pass
  // this value down
  node._wrapperState.initialValue = undefined;

  var wasMultiple = node._wrapperState.wasMultiple;
  node._wrapperState.wasMultiple = !!props.multiple;

  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (wasMultiple !== !!props.multiple) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(node, !!props.multiple, props.defaultValue, true);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
    }
  }
}

function restoreControlledState$2(element, props) {
  var node = element;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  }
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnValDefaultVal = false;

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */

function getHostProps$3(element, props) {
  var node = element;
  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;

  // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
  // solution. The value can be a boolean or object so that's why it's forced
  // to be a string.
  var hostProps = _assign({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: '' + node._wrapperState.initialValue
  });

  return hostProps;
}

function initWrapperState$2(element, props) {
  var node = element;
  {
    ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$5);
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
      warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValDefaultVal = true;
    }
  }

  var value = props.value;
  var initialValue = value;

  // Only bother fetching default value if we're going to use it
  if (value == null) {
    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = props.children;
    if (children != null) {
      {
        warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
      }
      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    initialValue = defaultValue;
  }

  node._wrapperState = {
    initialValue: '' + initialValue
  };
}

function updateWrapper$1(element, props) {
  var node = element;
  var value = props.value;
  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn't.
    var newValue = '' + value;

    // To avoid side effects (such as losing text selection), only set value if changed
    if (newValue !== node.value) {
      node.value = newValue;
    }
    if (props.defaultValue == null) {
      node.defaultValue = newValue;
    }
  }
  if (props.defaultValue != null) {
    node.defaultValue = props.defaultValue;
  }
}

function postMountWrapper$3(element, props) {
  var node = element;
  // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.
  var textContent = node.textContent;

  // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
  if (textContent === node._wrapperState.initialValue) {
    node.value = textContent;
  }
}

function restoreControlledState$3(element, props) {
  // DOM component is still mounted; update
  updateWrapper$1(element, props);
}

var HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

var Namespaces = {
  html: HTML_NAMESPACE$1,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
};

// Assumes there is no parent namespace.
function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;
    case 'math':
      return MATH_NAMESPACE;
    default:
      return HTML_NAMESPACE$1;
  }
}

function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }
  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE$1;
  }
  // By default, pass namespace below.
  return parentNamespace;
}

/* globals MSApp */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */
var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer = void 0;

/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node

  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

// code copied and modified from escape-html
/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;
      case 38:
        // &
        escape = '&amp;';
        break;
      case 39:
        // '
        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
        break;
      case 60:
        // <
        escape = '&lt;';
        break;
      case 62:
        // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// end code copied and modified from escape-html

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  if (typeof text === 'boolean' || typeof text === 'number') {
    // this shortcircuit helps perf for types that we know will never have
    // special characters, especially given that this function is used often
    // for numeric dom ids.
    return '' + text;
  }
  return escapeHtml(text);
}

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function (node, text) {
      if (node.nodeType === TEXT_NODE) {
        node.nodeValue = text;
        return;
      }
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

var setTextContent$1 = setTextContent;

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var warnValidStyle = emptyFunction$1;

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var warnHyphenatedStyleName = function (name, getStack) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());
  };

  var warnBadVendoredStyleName = function (name, getStack) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());
  };

  var warnStyleValueWithSemicolon = function (name, value, getStack) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    warning(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());
  };

  var warnStyleValueIsNaN = function (name, value, getStack) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());
  };

  var warnStyleValueIsInfinity = function (name, value, getStack) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;
    warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());
  };

  warnValidStyle = function (name, value, getStack) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, getStack);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, getStack);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, getStack);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value, getStack);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value, getStack);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

/**
 * Operations for dealing with CSS properties.
 */

/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */
function createDangerousStringForStyles(styles) {
  {
    var serialized = '';
    var delimiter = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (styleValue != null) {
        var isCustomProperty = styleName.indexOf('--') === 0;
        serialized += delimiter + hyphenateStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);

        delimiter = ';';
      }
    }
    return serialized || null;
  }
}

/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */
function setValueForStyles(node, styles, getStack) {
  var style = node.style;
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    var isCustomProperty = styleName.indexOf('--') === 0;
    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styles[styleName], getStack);
      }
    }
    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
    if (styleName === 'float') {
      styleName = 'cssFloat';
    }
    if (isCustomProperty) {
      style.setProperty(styleName, styleValue);
    } else {
      style[styleName] = styleValue;
    }
  }
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

var HTML$1 = '__html';

function assertValidProps(tag, props, getStack) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;
  }
  {
    warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack());
  }
  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getStack()) : void 0;
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }
  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this whitelist too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;
    default:
      return true;
  }
}

var ariaProperties = {
  'aria-current': 0, // state
  'aria-details': 0,
  'aria-disabled': 0, // state
  'aria-hidden': 0, // state
  'aria-invalid': 0, // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

var hasOwnProperty = Object.prototype.hasOwnProperty;

function getStackAddendum() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

function validateProperty(tagName, name) {
  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
    return true;
  }

  if (rARIACamel.test(name)) {
    var ariaName = 'aria-' + name.slice(4).toLowerCase();
    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (correctName == null) {
      warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== correctName) {
      warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  var invalidProps = [];

  for (var key in props) {
    var isValid = validateProperty(type, key);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
  } else if (invalidProps.length > 1) {
    warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;

function getStackAddendum$1() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

function validateProperties$1(type, props) {
  if (type !== 'input' && type !== 'textarea' && type !== 'select') {
    return;
  }

  if (props != null && props.value === null && !didWarnValueNull) {
    didWarnValueNull = true;
    if (type === 'select' && props.multiple) {
      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());
    } else {
      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());
    }
  }
}

// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  'class': 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  'default': 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  'for': 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',

  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  'in': 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  'typeof': 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

function getStackAddendum$2() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

{
  var warnedProperties$1 = {};
  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on[A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  var validateProperty$1 = function (tagName, name, value) {
    if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    if (registrationNameModules.hasOwnProperty(name)) {
      return true;
    }

    if (plugins.length === 0 && EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we might be in a server environment.
      // Don't check events in this case.
      return true;
    }

    var lowerCasedName = name.toLowerCase();
    var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;

    if (registrationName != null) {
      warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName.indexOf('on') === 0 && lowerCasedName.length > 2) {
      warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    // Let the ARIA attribute hook validate ARIA attributes
    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    var isReserved = isReservedProp(name);

    // Known attributes should match the casing specified in the property config.
    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];
      if (standardName !== name) {
        warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && !shouldAttributeAcceptBooleanValue(name)) {
      if (value) {
        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());
      } else {
        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Now that we've validated casing, do not validate
    // data types for reserved props
    if (isReserved) {
      return true;
    }

    // Warn when a known attribute is a bad type
    if (!shouldSetAttribute(name, value)) {
      warnedProperties$1[name] = true;
      return false;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props) {
  var unknownProps = [];
  for (var key in props) {
    var isValid = validateProperty$1(type, key, props[key]);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');
  if (unknownProps.length === 1) {
    warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
  } else if (unknownProps.length > 1) {
    warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
  }
};

function validateProperties$2(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnUnknownProperties(type, props);
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$1 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnInvalidHydration = false;
var didWarnShadyDOM = false;

var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
var SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
var AUTOFOCUS = 'autoFocus';
var CHILDREN = 'children';
var STYLE = 'style';
var HTML = '__html';

var HTML_NAMESPACE = Namespaces.html;


var getStack = emptyFunction$1.thatReturns('');

{
  getStack = getCurrentFiberStackAddendum$2;

  var warnedUnknownTags = {
    // Chrome is the only major browser not shipping <time>. But as of July
    // 2017 it intends to ship it due to widespread usage. We intentionally
    // *don't* warn for <time> even if it's unrecognized by Chrome because
    // it soon will be, and many apps have been using it anyway.
    time: true,
    // There are working polyfills for <dialog>. Let people use it.
    dialog: true
  };

  var validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props);
  };

  // HTML parsing normalizes CR and CRLF to LF.
  // It also can turn \u0000 into \uFFFD inside attributes.
  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
  // If we have a mismatch, it might be caused by that.
  // We will still patch up in this case but not fire the warning.
  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

  var normalizeMarkupForTextOrAttribute = function (markup) {
    var markupString = typeof markup === 'string' ? markup : '' + markup;
    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
  };

  var warnForTextDifference = function (serverText, clientText) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
    if (normalizedServerText === normalizedClientText) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
  };

  var warnForPropDifference = function (propName, serverValue, clientValue) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
    if (normalizedServerValue === normalizedClientValue) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
  };

  var warnForExtraAttributes = function (attributeNames) {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    var names = [];
    attributeNames.forEach(function (name) {
      names.push(name);
    });
    warning(false, 'Extra attributes from the server: %s', names);
  };

  var warnForInvalidEventListener = function (registrationName, listener) {
    if (listener === false) {
      warning(false, 'Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$2());
    } else {
      warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$2());
    }
  };

  // Parse the HTML and read it back to normalize the HTML string so that it
  // can be used for comparison.
  var normalizeHTML = function (parent, html) {
    // We could have created a separate document here to avoid
    // re-initializing custom elements if they exist. But this breaks
    // how <noscript> is being handled. So we use the same document.
    // See the discussion in https://github.com/facebook/react/pull/11157.
    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
    testElement.innerHTML = html;
    return testElement.innerHTML;
  };
}

function ensureListeningTo(rootContainerElement, registrationName) {
  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
  listenTo(registrationName, doc);
}

function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapClickOnNonInteractiveElement(node) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  // Just set it using the onclick property so that we don't have to manage any
  // bookkeeping for it. Not sure if we need to clear it when the listener is
  // removed.
  // TODO: Only do this for the relevant Safaris maybe?
  node.onclick = emptyFunction$1;
}

function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
  for (var propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = nextProps[propKey];
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      // Relies on `updateStylesByID` not mutating `styleUpdates`.
      setValueForStyles(domElement, nextProp, getStack);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      if (nextHtml != null) {
        setInnerHTML(domElement, nextHtml);
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string') {
        // Avoid setting initial textContent when the text is empty. In IE11 setting
        // textContent on a <textarea> will cause the placeholder to not
        // show within the <textarea> until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        var canSetTextContent = tag !== 'textarea' || nextProp !== '';
        if (canSetTextContent) {
          setTextContent$1(domElement, nextProp);
        }
      } else if (typeof nextProp === 'number') {
        setTextContent$1(domElement, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // We polyfill it separately on the client during commit.
      // We blacklist it here rather than in the property list because we emit it in SSR.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else if (isCustomComponentTag) {
      setValueForAttribute(domElement, propKey, nextProp);
    } else if (nextProp != null) {
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      setValueForProperty(domElement, propKey, nextProp);
    }
  }
}

function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
  // TODO: Handle wasCustomComponentTag
  for (var i = 0; i < updatePayload.length; i += 2) {
    var propKey = updatePayload[i];
    var propValue = updatePayload[i + 1];
    if (propKey === STYLE) {
      setValueForStyles(domElement, propValue, getStack);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      setInnerHTML(domElement, propValue);
    } else if (propKey === CHILDREN) {
      setTextContent$1(domElement, propValue);
    } else if (isCustomComponentTag) {
      if (propValue != null) {
        setValueForAttribute(domElement, propKey, propValue);
      } else {
        deleteValueForAttribute(domElement, propKey);
      }
    } else if (propValue != null) {
      setValueForProperty(domElement, propKey, propValue);
    } else {
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      deleteValueForProperty(domElement, propKey);
    }
  }
}

function createElement$1(type, props, rootContainerElement, parentNamespace) {
  // We create tags in the namespace of their parent container, except HTML
  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
  var domElement;
  var namespaceURI = parentNamespace;
  if (namespaceURI === HTML_NAMESPACE) {
    namespaceURI = getIntrinsicNamespace(type);
  }
  if (namespaceURI === HTML_NAMESPACE) {
    {
      var isCustomComponentTag = isCustomComponent(type, props);
      // Should this check be gated by parent namespace? Not sure we want to
      // allow <SVG> or <mATH>.
      warning(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' + 'in React.', type);
    }

    if (type === 'script') {
      // Create the script via .innerHTML so its "parser-inserted" flag is
      // set to true and it does not execute
      var div = ownerDocument.createElement('div');
      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
      // This is guaranteed to yield a script element.
      var firstChild = div.firstChild;
      domElement = div.removeChild(firstChild);
    } else if (typeof props.is === 'string') {
      // $FlowIssue `createElement` should be updated for Web Components
      domElement = ownerDocument.createElement(type, { is: props.is });
    } else {
      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
      // See discussion in https://github.com/facebook/react/pull/6896
      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
      domElement = ownerDocument.createElement(type);
    }
  } else {
    domElement = ownerDocument.createElementNS(namespaceURI, type);
  }

  {
    if (namespaceURI === HTML_NAMESPACE) {
      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
        warnedUnknownTags[type] = true;
        warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
      }
    }
  }

  return domElement;
}

function createTextNode$1(text, rootContainerElement) {
  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
}

function setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {
  var isCustomComponentTag = isCustomComponent(tag, rawProps);
  {
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  var props;
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent('topLoad', 'load', domElement);
      props = rawProps;
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          trapBubbledEvent(event, mediaEvents[event], domElement);
        }
      }
      props = rawProps;
      break;
    case 'source':
      trapBubbledEvent('topError', 'error', domElement);
      props = rawProps;
      break;
    case 'img':
    case 'image':
      trapBubbledEvent('topError', 'error', domElement);
      trapBubbledEvent('topLoad', 'load', domElement);
      props = rawProps;
      break;
    case 'form':
      trapBubbledEvent('topReset', 'reset', domElement);
      trapBubbledEvent('topSubmit', 'submit', domElement);
      props = rawProps;
      break;
    case 'details':
      trapBubbledEvent('topToggle', 'toggle', domElement);
      props = rawProps;
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      props = getHostProps(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      props = getHostProps$1(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      props = getHostProps$2(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      props = getHostProps$3(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    default:
      props = rawProps;
  }

  assertValidProps(tag, props, getStack);

  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'option':
      postMountWrapper$1(domElement, rawProps);
      break;
    case 'select':
      postMountWrapper$2(domElement, rawProps);
      break;
    default:
      if (typeof props.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }
}

// Calculate the diff between the two objects.
function diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
  {
    validatePropertiesInDevelopment(tag, nextRawProps);
  }

  var updatePayload = null;

  var lastProps;
  var nextProps;
  switch (tag) {
    case 'input':
      lastProps = getHostProps(domElement, lastRawProps);
      nextProps = getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'option':
      lastProps = getHostProps$1(domElement, lastRawProps);
      nextProps = getHostProps$1(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'select':
      lastProps = getHostProps$2(domElement, lastRawProps);
      nextProps = getHostProps$2(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'textarea':
      lastProps = getHostProps$3(domElement, lastRawProps);
      nextProps = getHostProps$3(domElement, nextRawProps);
      updatePayload = [];
      break;
    default:
      lastProps = lastRawProps;
      nextProps = nextRawProps;
      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  assertValidProps(tag, nextProps, getStack);

  var propKey;
  var styleName;
  var styleUpdates = null;
  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }
    if (propKey === STYLE) {
      var lastStyle = lastProps[propKey];
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }
          styleUpdates[styleName] = '';
        }
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {
      // Noop. This is handled by the clear text mechanism.
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // Noop. It doesn't work on updates anyway.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      // This is a special case. If any listener updates we need to ensure
      // that the "current" fiber pointer gets updated so we need a commit
      // to update this element.
      if (!updatePayload) {
        updatePayload = [];
      }
    } else {
      // For all other deleted properties we add it to the queue. We use
      // the whitelist in the commit phase instead.
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }
  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = lastProps != null ? lastProps[propKey] : undefined;
    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
      continue;
    }
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = '';
          }
        }
        // Update styles that changed since `lastProp`.
        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }
          updatePayload.push(propKey, styleUpdates);
        }
        styleUpdates = nextProp;
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      var lastHtml = lastProp ? lastProp[HTML] : undefined;
      if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);
        }
      } else {
        // TODO: It might be too late to clear this if we have children
        // inserted already.
      }
    } else if (propKey === CHILDREN) {
      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {
        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        // We eagerly listen to this even though we haven't committed yet.
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
      if (!updatePayload && lastProp !== nextProp) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" props pointer gets updated so we need a commit
        // to update this element.
        updatePayload = [];
      }
    } else {
      // For any other property we always add it to the queue and then we
      // filter it out using the whitelist during the commit.
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }
  if (styleUpdates) {
    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }
  return updatePayload;
}

// Apply the diff.
function updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
  // Apply the diff.
  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);

  // TODO: Ensure that an update gets scheduled if any of the special props
  // changed.
  switch (tag) {
    case 'input':
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      updateWrapper(domElement, nextRawProps);

      // We also check that we haven't missed a value update, such as a
      // Radio group shifting the checked value to another named radio input.
      updateValueIfChanged(domElement);
      break;
    case 'textarea':
      updateWrapper$1(domElement, nextRawProps);
      break;
    case 'select':
      // <select> value update needs to occur after <option> children
      // reconciliation
      postUpdateWrapper(domElement, nextRawProps);
      break;
  }
}

function diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
  {
    var suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;
    var isCustomComponentTag = isCustomComponent(tag, rawProps);
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent('topLoad', 'load', domElement);
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          trapBubbledEvent(event, mediaEvents[event], domElement);
        }
      }
      break;
    case 'source':
      trapBubbledEvent('topError', 'error', domElement);
      break;
    case 'img':
    case 'image':
      trapBubbledEvent('topError', 'error', domElement);
      trapBubbledEvent('topLoad', 'load', domElement);
      break;
    case 'form':
      trapBubbledEvent('topReset', 'reset', domElement);
      trapBubbledEvent('topSubmit', 'submit', domElement);
      break;
    case 'details':
      trapBubbledEvent('topToggle', 'toggle', domElement);
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
  }

  assertValidProps(tag, rawProps, getStack);

  {
    var extraAttributeNames = new Set();
    var attributes = domElement.attributes;
    for (var i = 0; i < attributes.length; i++) {
      var name = attributes[i].name.toLowerCase();
      switch (name) {
        // Built-in SSR attribute is whitelisted
        case 'data-reactroot':
          break;
        // Controlled attributes are not validated
        // TODO: Only ignore them on controlled tags.
        case 'value':
          break;
        case 'checked':
          break;
        case 'selected':
          break;
        default:
          // Intentionally use the original name.
          // See discussion in https://github.com/facebook/react/pull/10676.
          extraAttributeNames.add(attributes[i].name);
      }
    }
  }

  var updatePayload = null;
  for (var propKey in rawProps) {
    if (!rawProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = rawProps[propKey];
    if (propKey === CHILDREN) {
      // For text content children we compare against textContent. This
      // might match additional HTML that is hidden when we read it using
      // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
      // satisfies our requirement. Our requirement is not to produce perfect
      // HTML and attributes. Ideally we should preserve structure but it's
      // ok not to if the visible content is still enough to indicate what
      // even listeners these nodes might be wired up to.
      // TODO: Warn if there is more than a single textNode as a child.
      // TODO: Should we use domElement.firstChild.nodeValue to compare?
      if (typeof nextProp === 'string') {
        if (domElement.textContent !== nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, nextProp];
        }
      } else if (typeof nextProp === 'number') {
        if (domElement.textContent !== '' + nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, '' + nextProp];
        }
      }
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else {
      // Validate that the properties correspond to their expected values.
      var serverValue;
      var propertyInfo;
      if (suppressHydrationWarning) {
        // Don't bother comparing. We're ignoring all these warnings.
      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||
      // Controlled attributes are not validated
      // TODO: Only ignore them on controlled tags.
      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {
        // Noop
      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var rawHtml = nextProp ? nextProp[HTML] || '' : '';
        var serverHTML = domElement.innerHTML;
        var expectedHTML = normalizeHTML(domElement, rawHtml);
        if (expectedHTML !== serverHTML) {
          warnForPropDifference(propKey, serverHTML, expectedHTML);
        }
      } else if (propKey === STYLE) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames['delete'](propKey);
        var expectedStyle = createDangerousStringForStyles(nextProp);
        serverValue = domElement.getAttribute('style');
        if (expectedStyle !== serverValue) {
          warnForPropDifference(propKey, serverValue, expectedStyle);
        }
      } else if (isCustomComponentTag) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames['delete'](propKey.toLowerCase());
        serverValue = getValueForAttribute(domElement, propKey, nextProp);

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      } else if (shouldSetAttribute(propKey, nextProp)) {
        if (propertyInfo = getPropertyInfo(propKey)) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames['delete'](propertyInfo.attributeName);
          serverValue = getValueForProperty(domElement, propKey, nextProp);
        } else {
          var ownNamespace = parentNamespace;
          if (ownNamespace === HTML_NAMESPACE) {
            ownNamespace = getIntrinsicNamespace(tag);
          }
          if (ownNamespace === HTML_NAMESPACE) {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propKey.toLowerCase());
          } else {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propKey);
          }
          serverValue = getValueForAttribute(domElement, propKey, nextProp);
        }

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      }
    }
  }

  {
    // $FlowFixMe - Should be inferred as not undefined.
    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
      // $FlowFixMe - Should be inferred as not undefined.
      warnForExtraAttributes(extraAttributeNames);
    }
  }

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'select':
    case 'option':
      // For input and textarea we current always set the value property at
      // post mount to force it to diverge from attributes. However, for
      // option and select we don't quite do the same thing and select
      // is not resilient to the DOM state changing so we don't do that here.
      // TODO: Consider not doing this for input and textarea.
      break;
    default:
      if (typeof rawProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  return updatePayload;
}

function diffHydratedText$1(textNode, text) {
  var isDifferent = textNode.nodeValue !== text;
  return isDifferent;
}

function warnForUnmatchedText$1(textNode, text) {
  {
    warnForTextDifference(textNode.nodeValue, text);
  }
}

function warnForDeletedHydratableElement$1(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
  }
}

function warnForDeletedHydratableText$1(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedElement$1(parentNode, tag, props) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedText$1(parentNode, text) {
  {
    if (text === '') {
      // We expect to insert empty text nodes since they're not represented in
      // the HTML.
      // TODO: Remove this special case if we can just avoid inserting empty
      // text nodes.
      return;
    }
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
  }
}

function restoreControlledState(domElement, tag, props) {
  switch (tag) {
    case 'input':
      restoreControlledState$1(domElement, props);
      return;
    case 'textarea':
      restoreControlledState$3(domElement, props);
      return;
    case 'select':
      restoreControlledState$2(domElement, props);
      return;
  }
}

var ReactDOMFiberComponent = Object.freeze({
	createElement: createElement$1,
	createTextNode: createTextNode$1,
	setInitialProperties: setInitialProperties$1,
	diffProperties: diffProperties$1,
	updateProperties: updateProperties$1,
	diffHydratedProperties: diffHydratedProperties$1,
	diffHydratedText: diffHydratedText$1,
	warnForUnmatchedText: warnForUnmatchedText$1,
	warnForDeletedHydratableElement: warnForDeletedHydratableElement$1,
	warnForDeletedHydratableText: warnForDeletedHydratableText$1,
	warnForInsertedHydratedElement: warnForInsertedHydratedElement$1,
	warnForInsertedHydratedText: warnForInsertedHydratedText$1,
	restoreControlledState: restoreControlledState
});

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var validateDOMNesting = emptyFunction$1;

{
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childText, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var invalidParentOrAncestor = invalidParent || invalidAncestor;
    if (!invalidParentOrAncestor) {
      return;
    }

    var ancestorTag = invalidParentOrAncestor.tag;
    var addendum = getCurrentFiberStackAddendum$6();

    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;
    if (didWarn[warnKey]) {
      return;
    }
    didWarn[warnKey] = true;

    var tagDisplayName = childTag;
    var whitespaceInfo = '';
    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '<' + childTag + '>';
    }

    if (invalidParent) {
      var info = '';
      if (ancestorTag === 'table' && childTag === 'tr') {
        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
      }
      warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);
    } else {
      warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);
    }
  };

  // TODO: turn this into a named export
  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

var validateDOMNesting$1 = validateDOMNesting;

// TODO: direct imports like some-package/src/* are bad. Fix me.
var createElement = createElement$1;
var createTextNode = createTextNode$1;
var setInitialProperties = setInitialProperties$1;
var diffProperties = diffProperties$1;
var updateProperties = updateProperties$1;
var diffHydratedProperties = diffHydratedProperties$1;
var diffHydratedText = diffHydratedText$1;
var warnForUnmatchedText = warnForUnmatchedText$1;
var warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;
var warnForDeletedHydratableText = warnForDeletedHydratableText$1;
var warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;
var warnForInsertedHydratedText = warnForInsertedHydratedText$1;
var updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;
var precacheFiberNode = precacheFiberNode$1;
var updateFiberProps = updateFiberProps$1;


{
  var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
  if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
    warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
  }
}

injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);

var eventsEnabled = null;
var selectionInformation = null;

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
}

function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOCUMENT_NODE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function shouldHydrateDueToLegacyHeuristic(container) {
  var rootElement = getReactRootElementInContainer(container);
  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
}

function shouldAutoFocusHostComponent(type, props) {
  switch (type) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!props.autoFocus;
  }
  return false;
}

var DOMRenderer = reactReconciler({
  getRootHostContext: function (rootContainerInstance) {
    var type = void 0;
    var namespace = void 0;
    var nodeType = rootContainerInstance.nodeType;
    switch (nodeType) {
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        {
          type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
          var root = rootContainerInstance.documentElement;
          namespace = root ? root.namespaceURI : getChildNamespace(null, '');
          break;
        }
      default:
        {
          var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
          var ownNamespace = container.namespaceURI || null;
          type = container.tagName;
          namespace = getChildNamespace(ownNamespace, type);
          break;
        }
    }
    {
      var validatedTag = type.toLowerCase();
      var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);
      return { namespace: namespace, ancestorInfo: _ancestorInfo };
    }
    return namespace;
  },
  getChildHostContext: function (parentHostContext, type) {
    {
      var parentHostContextDev = parentHostContext;
      var _namespace = getChildNamespace(parentHostContextDev.namespace, type);
      var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);
      return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };
    }
    var parentNamespace = parentHostContext;
    return getChildNamespace(parentNamespace, type);
  },
  getPublicInstance: function (instance) {
    return instance;
  },
  prepareForCommit: function () {
    eventsEnabled = isEnabled();
    selectionInformation = getSelectionInformation();
    setEnabled(false);
  },
  resetAfterCommit: function () {
    restoreSelection(selectionInformation);
    selectionInformation = null;
    setEnabled(eventsEnabled);
    eventsEnabled = null;
  },
  createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
    var parentNamespace = void 0;
    {
      // TODO: take namespace into account when validating.
      var hostContextDev = hostContext;
      validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);
      if (typeof props.children === 'string' || typeof props.children === 'number') {
        var string = '' + props.children;
        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
        validateDOMNesting$1(null, string, ownAncestorInfo);
      }
      parentNamespace = hostContextDev.namespace;
    }
    var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
    precacheFiberNode(internalInstanceHandle, domElement);
    updateFiberProps(domElement, props);
    return domElement;
  },
  appendInitialChild: function (parentInstance, child) {
    parentInstance.appendChild(child);
  },
  finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {
    setInitialProperties(domElement, type, props, rootContainerInstance);
    return shouldAutoFocusHostComponent(type, props);
  },
  prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
    {
      var hostContextDev = hostContext;
      if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
        var string = '' + newProps.children;
        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
        validateDOMNesting$1(null, string, ownAncestorInfo);
      }
    }
    return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);
  },
  shouldSetTextContent: function (type, props) {
    return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';
  },
  shouldDeprioritizeSubtree: function (type, props) {
    return !!props.hidden;
  },
  createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {
    {
      var hostContextDev = hostContext;
      validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);
    }
    var textNode = createTextNode(text, rootContainerInstance);
    precacheFiberNode(internalInstanceHandle, textNode);
    return textNode;
  },


  now: now,

  mutation: {
    commitMount: function (domElement, type, newProps, internalInstanceHandle) {
      domElement.focus();
    },
    commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
      // Update the props handle so that we know which props are the ones with
      // with current event handlers.
      updateFiberProps(domElement, newProps);
      // Apply the diff to the DOM node.
      updateProperties(domElement, updatePayload, type, oldProps, newProps);
    },
    resetTextContent: function (domElement) {
      domElement.textContent = '';
    },
    commitTextUpdate: function (textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    },
    appendChild: function (parentInstance, child) {
      parentInstance.appendChild(child);
    },
    appendChildToContainer: function (container, child) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, container);
      } else {
        container.appendChild(child);
      }
    },
    insertBefore: function (parentInstance, child, beforeChild) {
      parentInstance.insertBefore(child, beforeChild);
    },
    insertInContainerBefore: function (container, child, beforeChild) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, beforeChild);
      } else {
        container.insertBefore(child, beforeChild);
      }
    },
    removeChild: function (parentInstance, child) {
      parentInstance.removeChild(child);
    },
    removeChildFromContainer: function (container, child) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.removeChild(child);
      } else {
        container.removeChild(child);
      }
    }
  },

  hydration: {
    canHydrateInstance: function (instance, type, props) {
      if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
        return null;
      }
      // This has now been refined to an element node.
      return instance;
    },
    canHydrateTextInstance: function (instance, text) {
      if (text === '' || instance.nodeType !== TEXT_NODE) {
        // Empty strings are not parsed by HTML so there won't be a correct match here.
        return null;
      }
      // This has now been refined to a text node.
      return instance;
    },
    getNextHydratableSibling: function (instance) {
      var node = instance.nextSibling;
      // Skip non-hydratable nodes.
      while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {
        node = node.nextSibling;
      }
      return node;
    },
    getFirstHydratableChild: function (parentInstance) {
      var next = parentInstance.firstChild;
      // Skip non-hydratable nodes.
      while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {
        next = next.nextSibling;
      }
      return next;
    },
    hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, instance);
      // TODO: Possibly defer this until the commit phase where all the events
      // get attached.
      updateFiberProps(instance, props);
      var parentNamespace = void 0;
      {
        var hostContextDev = hostContext;
        parentNamespace = hostContextDev.namespace;
      }
      return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);
    },
    hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, textInstance);
      return diffHydratedText(textInstance, text);
    },
    didNotMatchHydratedContainerTextInstance: function (parentContainer, textInstance, text) {
      {
        warnForUnmatchedText(textInstance, text);
      }
    },
    didNotMatchHydratedTextInstance: function (parentType, parentProps, parentInstance, textInstance, text) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForUnmatchedText(textInstance, text);
      }
    },
    didNotHydrateContainerInstance: function (parentContainer, instance) {
      {
        if (instance.nodeType === 1) {
          warnForDeletedHydratableElement(parentContainer, instance);
        } else {
          warnForDeletedHydratableText(parentContainer, instance);
        }
      }
    },
    didNotHydrateInstance: function (parentType, parentProps, parentInstance, instance) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        if (instance.nodeType === 1) {
          warnForDeletedHydratableElement(parentInstance, instance);
        } else {
          warnForDeletedHydratableText(parentInstance, instance);
        }
      }
    },
    didNotFindHydratableContainerInstance: function (parentContainer, type, props) {
      {
        warnForInsertedHydratedElement(parentContainer, type, props);
      }
    },
    didNotFindHydratableContainerTextInstance: function (parentContainer, text) {
      {
        warnForInsertedHydratedText(parentContainer, text);
      }
    },
    didNotFindHydratableInstance: function (parentType, parentProps, parentInstance, type, props) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForInsertedHydratedElement(parentInstance, type, props);
      }
    },
    didNotFindHydratableTextInstance: function (parentType, parentProps, parentInstance, text) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForInsertedHydratedText(parentInstance, text);
      }
    }
  },

  scheduleDeferredCallback: rIC,

  useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM
});

injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);

var warnedAboutHydrateAPI = false;

function renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;

  {
    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
      var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);
      if (hostInstance) {
        warning(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');
      }
    }

    var isRootRenderedBySomeReact = !!container._reactRootContainer;
    var rootEl = getReactRootElementInContainer(container);
    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));

    warning(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');

    warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');
  }

  var root = container._reactRootContainer;
  if (!root) {
    var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
    // First clear any existing content.
    if (!shouldHydrate) {
      var warned = false;
      var rootSibling = void 0;
      while (rootSibling = container.lastChild) {
        {
          if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
            warned = true;
            warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
          }
        }
        container.removeChild(rootSibling);
      }
    }
    {
      if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
        warnedAboutHydrateAPI = true;
        lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
      }
    }
    var newRoot = DOMRenderer.createContainer(container, shouldHydrate);
    root = container._reactRootContainer = newRoot;
    // Initial mount should not be batched.
    DOMRenderer.unbatchedUpdates(function () {
      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);
    });
  } else {
    DOMRenderer.updateContainer(children, root, parentComponent, callback);
  }
  return DOMRenderer.getPublicRootInstance(root);
}

function createPortal(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;
  // TODO: pass ReactDOM portal implementation as third argument
  return createPortal$1(children, container, null, key);
}

function ReactRoot(container, hydrate) {
  var root = DOMRenderer.createContainer(container, hydrate);
  this._reactRootContainer = root;
}
ReactRoot.prototype.render = function (children, callback) {
  var root = this._reactRootContainer;
  DOMRenderer.updateContainer(children, root, null, callback);
};
ReactRoot.prototype.unmount = function (callback) {
  var root = this._reactRootContainer;
  DOMRenderer.updateContainer(null, root, null, callback);
};

var ReactDOM = {
  createPortal: createPortal,

  findDOMNode: function (componentOrElement) {
    {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
        warning(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component');
        owner.stateNode._warnedAboutRefsInRender = true;
      }
    }
    if (componentOrElement == null) {
      return null;
    }
    if (componentOrElement.nodeType === ELEMENT_NODE) {
      return componentOrElement;
    }

    var inst = get(componentOrElement);
    if (inst) {
      return DOMRenderer.findHostInstance(inst);
    }

    if (typeof componentOrElement.render === 'function') {
      invariant(false, 'Unable to find node on an unmounted component.');
    } else {
      invariant(false, 'Element appears to be neither ReactComponent nor DOMNode. Keys: %s', Object.keys(componentOrElement));
    }
  },
  hydrate: function (element, container, callback) {
    // TODO: throw or warn if we couldn't hydrate?
    return renderSubtreeIntoContainer(null, element, container, true, callback);
  },
  render: function (element, container, callback) {
    return renderSubtreeIntoContainer(null, element, container, false, callback);
  },
  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {
    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;
    return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
  },
  unmountComponentAtNode: function (container) {
    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;

    if (container._reactRootContainer) {
      {
        var rootEl = getReactRootElementInContainer(container);
        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);
        warning(!renderedByDifferentReact, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.');
      }

      // Unmount should not be batched.
      DOMRenderer.unbatchedUpdates(function () {
        renderSubtreeIntoContainer(null, null, container, false, function () {
          container._reactRootContainer = null;
        });
      });
      // If you call unmountComponentAtNode twice in quick succession, you'll
      // get `true` twice. That's probably fine?
      return true;
    } else {
      {
        var _rootEl = getReactRootElementInContainer(container);
        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));

        // Check if the container itself is a React root node.
        var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

        warning(!hasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
      }

      return false;
    }
  },


  // Temporary alias since we already shipped React 16 RC with it.
  // TODO: remove in React 17.
  unstable_createPortal: createPortal,

  unstable_batchedUpdates: batchedUpdates,

  unstable_deferredUpdates: DOMRenderer.deferredUpdates,

  flushSync: DOMRenderer.flushSync,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    // For TapEventPlugin which is popular in open source
    EventPluginHub: EventPluginHub,
    // Used by test-utils
    EventPluginRegistry: EventPluginRegistry,
    EventPropagators: EventPropagators,
    ReactControlledComponent: ReactControlledComponent,
    ReactDOMComponentTree: ReactDOMComponentTree,
    ReactDOMEventListener: ReactDOMEventListener
  }
};

if (enableCreateRoot) {
  ReactDOM.createRoot = function createRoot(container, options) {
    var hydrate = options != null && options.hydrate === true;
    return new ReactRoot(container, hydrate);
  };
}

var foundDevTools = DOMRenderer.injectIntoDevTools({
  findFiberByHostInstance: getClosestInstanceFromNode,
  bundleType: 1,
  version: ReactVersion,
  rendererPackageName: 'react-dom'
});

{
  if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {
    // If we're in Chrome or Firefox, provide a download link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
      var protocol = window.location.protocol;
      // Don't warn in exotic cases like chrome-extension://.
      if (/^(https?|file):$/.test(protocol)) {
        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');
      }
    }
  }
}



var ReactDOM$2 = Object.freeze({
	default: ReactDOM
});

var ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom = ReactDOM$3['default'] ? ReactDOM$3['default'] : ReactDOM$3;

module.exports = reactDom;
  })();
}


/***/ }),

/***/ 82:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.1.1
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(36);
var invariant = __webpack_require__(23);
var emptyObject = __webpack_require__(48);
var warning = __webpack_require__(27);
var emptyFunction = __webpack_require__(22);
var checkPropTypes = __webpack_require__(37);

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.1.1';

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

// Exports React.Fragment
var enableReactFragment = false;
// Exports ReactDOM.createRoot



// Mutating mode (React DOM, React ART, React Native):

// Experimental noop mode (currently unused):

// Experimental persistent mode (CS):


// Only used in www builds.

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var constructor = publicInstance.constructor;
    var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
    var warningKey = componentName + '.' + callerName;
    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }
    warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

/**
 * Base class helpers for the updating state of a component.
 */
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
Component.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
        return undefined;
      }
    });
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

/**
 * Base class helpers for the updating state of a component.
 */
function PureComponent(props, context, updater) {
  // Duplicated from Component.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;
var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
// Avoid an extra prototype jump for these methods.
_assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;

function AsyncComponent(props, context, updater) {
  // Duplicated from Component.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
asyncComponentPrototype.constructor = AsyncComponent;
// Avoid an extra prototype jump for these methods.
_assign(asyncComponentPrototype, Component.prototype);
asyncComponentPrototype.unstable_isAsyncReactComponent = true;
asyncComponentPrototype.render = function () {
  return this.props.children;
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE$1 = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown;
var specialPropRefWarningShown;

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE$1,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    });
    // self and source are DEV only properties.
    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    });
    // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.
    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */
function createElement(type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE$1) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}

/**
 * Return a function that produces ReactElements of a given type.
 * See https://reactjs.org/docs/react-api.html#createfactory
 */


function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
}

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */
function cloneElement(element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}

/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE$1;
}

var ReactDebugCurrentFrame = {};

{
  // Component that is being worked on
  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var impl = ReactDebugCurrentFrame.getCurrentStack;
    if (impl) {
      return impl();
    }
    return null;
  };
}

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
var REACT_PORTAL_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.portal') || 0xeaca;
var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */
function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

var POOL_SIZE = 10;
var traverseContextPool = [];
function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
  if (traverseContextPool.length) {
    var traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
}

function releaseTraverseContext(traverseContext) {
  traverseContext.result = null;
  traverseContext.keyPrefix = null;
  traverseContext.func = null;
  traverseContext.context = null;
  traverseContext.count = 0;
  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext);
  }
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE || type === 'object' && children.$$typeof === REACT_PORTAL_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = ITERATOR_SYMBOL && children[ITERATOR_SYMBOL] || children[FAUX_ITERATOR_SYMBOL];
    if (typeof iteratorFn === 'function') {
      {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step;
      var ii = 0;
      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else if (type === 'object') {
      var addendum = '';
      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
      }
      var childrenString = '' + children;
      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof component === 'object' && component !== null && component.key != null) {
    // Explicit key
    return escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  releaseTraverseContext(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
  return children;
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'string') {
    return type;
  }
  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  return null;
}

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

{
  var currentlyValidatingElement = null;

  var getDisplayName = function (element) {
    if (element == null) {
      return '#empty';
    } else if (typeof element === 'string' || typeof element === 'number') {
      return '#text';
    } else if (typeof element.type === 'string') {
      return element.type;
    } else if (element.type === REACT_FRAGMENT_TYPE$1) {
      return 'React.Fragment';
    } else {
      return element.type.displayName || element.type.name || 'Unknown';
    }
  };

  var getStackAddendum = function () {
    var stack = '';
    if (currentlyValidatingElement) {
      var name = getDisplayName(currentlyValidatingElement);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
    }
    stack += ReactDebugCurrentFrame.getStackAddendum() || '';
    return stack;
  };

  var REACT_FRAGMENT_TYPE$1 = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.fragment') || 0xeacb;

  var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
}

var ITERATOR_SYMBOL$1 = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL$1 = '@@iterator'; // Before Symbol spec.

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current);
    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = '\n\nCheck the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
  }

  currentlyValidatingElement = element;
  {
    warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
  }
  currentlyValidatingElement = null;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = ITERATOR_SYMBOL$1 && node[ITERATOR_SYMBOL$1] || node[FAUX_ITERATOR_SYMBOL$1];
    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  var propTypes = componentClass.propTypes;

  if (propTypes) {
    currentlyValidatingElement = element;
    checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
    currentlyValidatingElement = null;
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
  }
}

/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */
function validateFragmentProps(fragment) {
  currentlyValidatingElement = fragment;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      if (!VALID_FRAGMENT_PROPS.has(key)) {
        warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (fragment.ref !== null) {
    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
  }

  currentlyValidatingElement = null;
}

function createElementWithValidation(type, props, children) {
  var validType = typeof type === 'string' || typeof type === 'function' || typeof type === 'symbol' || typeof type === 'number';
  // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.
  if (!validType) {
    var info = '';
    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendum(props);
    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    info += getStackAddendum() || '';

    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info);
  }

  var element = createElement.apply(this, arguments);

  // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.
  if (element == null) {
    return element;
  }

  // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)
  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (typeof type === 'symbol' && type === REACT_FRAGMENT_TYPE$1) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}

function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  // Legacy hook TODO: Warn if this is accessed
  validatedFactory.type = type;

  {
    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}

function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);
  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }
  validatePropTypes(newElement);
  return newElement;
}

var REACT_FRAGMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.fragment') || 0xeacb;

var React = {
  Children: {
    map: mapChildren,
    forEach: forEachChildren,
    count: countChildren,
    toArray: toArray,
    only: onlyChild
  },

  Component: Component,
  PureComponent: PureComponent,
  unstable_AsyncComponent: AsyncComponent,

  createElement: createElementWithValidation,
  cloneElement: cloneElementWithValidation,
  createFactory: createFactoryWithValidation,
  isValidElement: isValidElement,

  version: ReactVersion,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    ReactCurrentOwner: ReactCurrentOwner,
    // Used by renderers to avoid bundling object-assign twice in UMD bundles:
    assign: _assign
  }
};

if (enableReactFragment) {
  React.Fragment = REACT_FRAGMENT_TYPE;
}

{
  _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
    // These should not be included in production.
    ReactDebugCurrentFrame: ReactDebugCurrentFrame,
    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
    // TODO: remove in React 17.0.
    ReactComponentTreeHook: {}
  });
}



var React$2 = Object.freeze({
	default: React
});

var React$3 = ( React$2 && React ) || React$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var react = React$3['default'] ? React$3['default'] : React$3;

module.exports = react;
  })();
}


/***/ }),

/***/ 83:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),

/***/ 84:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(22);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (true) {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;

/***/ }),

/***/ 85:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */
function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),

/***/ 86:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(87);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),

/***/ 87:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(88);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),

/***/ 88:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),

/***/ 89:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),

/***/ 90:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(91);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),

/***/ 91:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),

/***/ 92:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var camelize = __webpack_require__(93);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),

/***/ 93:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ })

/******/ });